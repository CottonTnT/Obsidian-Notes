# 最短路问题的最优子结构


>[!abstract] 从动态规划的角度看 
最短路问题，以单源最短路为例
可以分为每个点距离原点为路径为1条的最短路
......
可以分为每个点距离原点为路径为n条的最短路
假设共 n 个点，求距离原点距离为 i 条路径的到 j 点的距离
f[i]\[j]  = min (f[i - 1]\[k] + d[k]\[j])   以此类推
故以此为基础, 其余最短算法为此法的分支与优化


---

# 与朴素 dijstra 的联系（处理的都是正权边）

>[!quote] 
>故由上述算法流程可知，每 i 轮找到的是点 j 距离原点距离路径为 i 条的最短路。
>Dijstra 算法用于求所有点距离原点的最短距离, 流程如下, 令总共 N 个点,已找到最短距离的点集为 P, 未找到的为 Q
>
>R 1, 从 Q 找到距离原点路径长度最多为 1 的最短距离的点, 并加入 P, 并更新原点到所有点的距离
>R2, 从 Q 找到距离原点路径长度最多为 2 的最短距离的点, ~
>....
>R N - 1 从 Q 找到距离原点路径长度最多为 N - 1 的最短距离的点, ~
>**实际上 dijstra 每 i 轮找到一个点距离源点的最短距离，且其最短距离的路径长度小于等于i**

## dijstra 的使用范围

单源最短路（“单源”很妙), 无负环图，可用于判定图中是否有负环


## 论证 (条件, 处理的都是正权边)

设源点为 s, 第一轮时，得到的便是从原点到经过一条边可达所有点, 设点集设为 V 1，经过的所有边的边集设为 U 1，则从中挑选最短的边 Esv, v 点在该轮计算出来的距离亦是从原点该点 v 的最短的距离, 如要找到第二个点到原点的最短距离，则只须将 v 点经过一点边可达的所有点 u V 1, 令该点集为 V 2, 再将 v 点到这些点的边（除去 Esv）+Esv 的距离的到的
边 u U 1, 所得的边集记为 U 2 (除去 Esv)，则从中挑选最短的边 Esp, 则此时 Esp 边便是从源点 s 到点 p 的最短距离,
然后再将点 p 经过一点边可达的所点......

便能找到源点距离所有点的最短距离

---


# 与 bellman-ford的联系

>[!quote] 
>故由上述算法流程可知，每 i 轮找的是 j 点距离原点距离路径为 i条的最短路。
>Bellman-ford 算法用于求所有点距离原点的最短距离, 流程如下 : 
>1)初始化所有点到源点的距离为∞, 把源点到自己的距离设置为 0；
 2)遍历 n 次; 每次遍历 m 条边，用每一条边去更新各点到源点的距离, 即松弛操作。
 **实际上 bf 算法每一轮通过松弛所有边，第 i 轮松弛即找到源点距离其他所有点的路径长度小于等于 i 的最短距离**

 
 

##  bellman-ford 的使用范围

- 搜索无负权环的带权有向图的单源节点到其他节点的所有最短路径。
- 检测负权环。
- 求有路径限制的最短路径距离 
- 求最长路


## 证明
Bellman-Ford 算法核心思想为对于长度为 k 的最短路径, 对所有边以任意顺序进行松弛 k 轮即可搜索得到该最短路径.使用归纳法证明如上结论.

> [!pros]
> 设从起点 s 到达顶点 t的最短路径为 s = v <sub>0</sub> − > v<sub> 1 </sub>− > . . . − > v <sub>k − 1</sub> − > v <sub>k</sub> = t 
> 1. 当 k 等于 0 时, 结论显然成立.
> 2. 设经过 k − 1 轮松弛, 所有长度为 k − 1 的最短路径已经被搜索得到. 则此时 
> distTo[v<sub>k-1</sub>]值为从 s 到节点 v <sub>k − 1</sub> 的最短路径. 在第 k 轮松弛中, distTo[v<sub>k</sub>] 的值肯定会被边 v <sub>k − 1</sub> − > v <sub>k</sub> 松弛, 因此 distTo[v<sub>k</sub>] <= distTo[v<sub>k-1</sub>] + W{v<sub>k-1,</sub> v<sub>k</sub>} ​.
> 又因为 distTo[v<sub>k</sub>]肯定不会小于最短路径长度, distTo[v<sub>k</sub>] >= distTo[v<sub>k-1</sub>] + W{v<sub>k-1</sub>, v<sub>k</sub>}​​, 因此 distTo[v<sub>k</sub>] 即为起点 s 到节点 t 的最短路径. 则在经过 k 轮松弛后, 长度为 k的最短路径被搜索得到.
> 
> 由于起点 s 无法到达图中的任一负权重环, 因此起点 s 到其他所有顶点的最短路径不包括环, 因此起点 s 到其他顶点的最短路径最多包括 V-1条边. 因此最多经过 V-1 轮松弛, 顶点 s 到其余顶点的最短路径便可搜索得到.


---

# 与 spfa 的联系 

>[!quote] 
>实际上, 在 Bellman-Ford 算法执行过程中, 每轮无需松弛所有边. 只有当前节点的distTo[]值在上一轮发生变化 (变得更小), 此轮对其邻边的松弛才有可能成功. 如果distTo[]值未变化, 则对其邻边的松弛结果与前轮松弛结果一致, 无需重复进行. 因此可以维护一个队列, 保存distTo[]值发生变化的顶点, 每轮迭代时只对这些顶点的邻边进行松弛.

 
 

##  spfa的使用范围

- 搜索无负权环的带权有向图的单源节点到其他节点的所有最短路径。
- 检测负权环。
- 求最长路


## Spfa 检测负环

### 方法 1
- 统计每个点入队的次数，如果某个点入队 n 次，则说明存在负环

### 方法 2
- 统计当前每个点的最短路中包含的边数。如果某点的最短路所包含的边数>=n, 则也说明有负环

### 玄学！

- 当所有点的入队次数超过 2 n 时，我们就认为图中很大可能时存在负环的


---

#  与多源最短路 floyd 算法之间的联系


## 单源最短路的动态规划问题
- 先从单源最短路考虑, 假设源点为 ${s_0}$ ,求源点到任意一点 $s_n$ 的最短路径为 $$
s_0{\rightarrow}s_1{\rightarrow}...{\rightarrow}s_n
$$
- 那么该路径 $\forall$ 子路径也应该是最短路径, 故求最短路问题具有最优子结构，根据这个性质，求解

### 方式一: 从边考虑 

$$
s_{0}到s_{j}最短路,共 n个点,该问题等同于求不超过n-1条路径从0到j的最短路 
$$
	由此可获得一个最优子结构 $$
f[i][j] = min(f[i - 1][j], f[i - 1][k]+d[k][j]),k\in\{1,n\}
$$即 $f[i][j]$ 表示不超过 i 条边, 从源点到 j 的最短距离

	此外bellman-ford更是在这种动态规划思想上的优化

### 方式二: 从点考虑

$$
s_0到s_j的最短路,其实该问题也可以转化为求s_0到s_j且经过不超过n个点的最短路,且由于最短路径子路径也是最短路的性质,即s_0
$$
	由此构造一个最优子结构 $$
	f[k][j] = min(f[k - 1][0][j], f[k - 1][0][k]+f[k-1][k][j])
$$
	及 $f[k][j]$ 表示经过不超过前 k 个点从源点到 j 的最短距离, 但怎么得到 $f[k-1][k][j]$ 呢？


## Floyd 算法

- 由前面的单源最短路的方式二受启发,  可得如下


![[Pasted image 20230429144401.png]]


##### 细节
-  $f[k][i][j]$ 中的 i, j 相当于两个虚拟的点

##### 用途

-  ![[Pasted image 20230508103603.png]]