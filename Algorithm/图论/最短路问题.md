### 最短路问题的最优子结构


>[!abstract] 从动态规划的角度看 
最短路问题，以单源最短路为例
可以分为每个点距离原点为路径为1条的最短路
......
可以分为每个点距离原点为路径为n条的最短路
假设共 n 个点，求距离原点距离为 i 条路径的到 j 点的距离
f[i]\[j]  = min (f[i - 1]\[k] + d[k]\[j])   以此类推
故以此为基础, 其余最短算法为此法的分支与优化


---

### 与朴素 dijstra 的联系（处理的都是正权边）

>[!quote] 
>故由上述算法流程可知，每 i 轮找到的是点 j 距离原点距离路径为 i 条的最短路。
>Dijstra 算法用于求所有点距离原点的最短距离, 流程如下, 令总共 N 个点,已找到最短距离的点集为 P, 未找到的为 Q
>
>R 1, 从 Q 找到距离原点路径长度最多为 1 的最短距离的点, 并加入 P, 并更新原点到所有点的距离
>R2, 从 Q 找到距离原点路径长度最多为 2 的最短距离的点, ~
>....
>R N - 1 从 Q 找到距离原点路径长度最多为 N - 1 的最短距离的点, ~
>**实际上 dijstra 每 i 轮找到一个点距离源点的最短距离，且其最短距离的路径长度小于等于i**

#### dijstra 的使用范围

单源最短路（“单源”很妙), 无负环图，可用于判定图中是否有负环


#### 论证 (条件, 处理的都是正权边)

设源点为 s, 第一轮时，得到的便是从原点到经过一条边可达所有点, 设点集设为 V 1，经过的所有边的边集设为 U 1，则从中挑选最短的边 Esv, v 点在该轮计算出来的距离亦是从原点该点 v 的最短的距离, 如要找到第二个点到原点的最短距离，则只须将 v 点经过一点边可达的所有点 u V 1, 令该点集为 V 2, 再将 v 点到这些点的边（除去 Esv）+Esv 的距离的到的
边 u U 1, 所得的边集记为 U 2 (除去 Esv)，则从中挑选最短的边 Esp, 则此时 Esp 边便是从源点 s 到点 p 的最短距离,
然后再将点 p 经过一点边可达的所点......

便能找到源点距离所有点的最短距离

---


### 与 bellman-ford的联系

>[!quote] 
>故由上述算法流程可知，每 i 轮找的是 j 点距离原点距离路径为 i条的最短路。
>Bellman-ford 算法用于求所有点距离原点的最短距离, 流程如下 : 
>1)初始化所有点到源点的距离为∞, 把源点到自己的距离设置为 0；
 2)遍历 n 次; 每次遍历 m 条边，用每一条边去更新各点到源点的距离, 即松弛操作。
 **实际上 bf 算法每一轮通过松弛所有边，第 i 轮松弛即找到源点距离其他所有点的路径长度小于等于 i 的最短距离**

 
 

####  bellman-ford 的使用范围

搜索无负权环的带权有向图的单源节点到其他节点的所有最短路径。检测负权环。求有路径限制的最短路径距离 



#### 证明
Bellman-Ford 算法核心思想为对于长度为 k 的最短路径, 对所有边以任意顺序进行松弛 k 轮即可搜索得到该最短路径.使用归纳法证明如上结论.

> [!pros]
> 设从起点 s 到达顶点 t的最短路径为 s = v <sub>0</sub> − > v<sub> 1 </sub>− > . . . − > v <sub>k − 1</sub> − > v <sub>k</sub> = t 
> 1. 当 k 等于 0 时, 结论显然成立.
> 2. 设经过 k − 1 轮松弛, 所有长度为 k − 1 的最短路径已经被搜索得到. 则此时 
> distTo[v<sub>k-1</sub>]值为从 s 到节点 v <sub>k − 1</sub> 的最短路径. 在第 k 轮松弛中, distTo[v<sub>k</sub>] 的值肯定会被边 v <sub>k − 1</sub> − > v <sub>k</sub> 松弛, 因此 distTo[v<sub>k</sub>] <= distTo[v<sub>k-1</sub>] + W{v<sub>k-1,</sub> v<sub>k</sub>} ​.
> 又因为 distTo[v<sub>k</sub>]肯定不会小于最短路径长度, distTo[v<sub>k</sub>] >= distTo[v<sub>k-1</sub>] + W{v<sub>k-1</sub>, v<sub>k</sub>}​​, 因此 distTo[v<sub>k</sub>] 即为起点 s 到节点 t 的最短路径. 则在经过 k 轮松弛后, 长度为 k的最短路径被搜索得到.
> 
> 由于起点 s 无法到达图中的任一负权重环, 因此起点 s 到其他所有顶点的最短路径不包括环, 因此起点 s 到其他顶点的最短路径最多包括 V-1条边. 因此最多经过 V-1 轮松弛, 顶点 s 到其余顶点的最短路径便可搜索得到.


---

### 与 spfa 的联系 

>[!quote] 
>实际上, 在 Bellman-Ford 算法执行过程中, 每轮无需松弛所有边. 只有当前节点的distTo[]值在上一轮发生变化 (变得更小), 此轮对其邻边的松弛才有可能成功. 如果distTo[]值未变化, 则对其邻边的松弛结果与前轮松弛结果一致, 无需重复进行. 因此可以维护一个队列, 保存distTo[]值发生变化的顶点, 每轮迭代时只对这些顶点的邻边进行松弛.

 
 

####  spfa的使用范围

搜索无负权环的带权有向图的单源节点到其他节点的所有最短路径。检测负权环。






---

