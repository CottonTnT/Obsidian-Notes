# 1 intent
- 求解两个字符串的  `匹配度`,
- 求解一个字符串的周期性
# 2 next 数组实质

假设字符串的下标为`1~k`, `next[i]`,$i\in{[1,k]},k>1$表示以`i`结尾的后缀中与`1`开头的前缀中最大的匹配长度值,即子串`1~i`的最长匹配的前后缀长度值

- 例`aaaaba`
```c
ne[0] = 0;
ne[1] = 0;
ne[2] = 1;
ne[3] = 2;
ne[4] = 3;
ne[5] = 0;
ne[6] = 1;//其实也没有意义
```

## 2.1 代码求解

```cpp
for(int i = 2, j = 0; i <= m; i++) //字符串从数组1下标开始
{
    while(j && p[i] != p[j+1]) j = next[j];
    //为何如此回退
	//以第i的为结尾的后缀与当时已j+1为结尾的最长前缀不匹配时，
	//	则需要知道已匹配j位结尾的前缀与已i-1结尾的后缀所匹配的最长前缀值是多少,这样回退的最少
    if(p[i] == p[j+1]) j++;
    next[i] = j;
}
```


### 2.1.1 关于 next 数组的周期性质

##### 2.1.1.1.1 引理

```thoery
对于某一字符串 S[1 ~ N]，在它众多的next[i]的“候选项”中，如果存在某一个next[i]，使得: i % (i−next[i])==0，
那么 S[1 ~ (i−next[i])] 可以为 S[1 ~ i] 的循环元而 i/(i−next[i]) 即是它的循环次数 K。
```
##### 2.1.1.1.2 证明如下


![[Pasted image 20230403165440.png]]

# 3 用途

## 3.1 1.判断一个串与另一个串的匹配度问题




