# 1 线程安全的对象声明周期管理


## 1.1 对象创建的线程安全:简单

对象构造要做到线程安全，唯一的要求是在构造期间不要泄露this 指针，即 

- 不要在构造函数中注册任何回调； 
- 也不要在构造函数中把this传给跨线程的对象； 
- 即便在构造函数的最后一行也不行。

原因如下:

1. 在构造函数执行期间对象还没有完成初始化，如果`this`被泄露（escape）给了其他对象（其自身创建的子对象除 外），那么别的线程有可能访问这个半成品对象，这会造成难以预料的后果*


2. 即使构造函数的最后一行也不要泄露`this`，因为`Foo`有可能是个*基类*，*基类先于派生类构造*，执行完`Foo::Foo()`的最后一行代码还会继续 执行派生类的构造函数，这时`most-derived class`的对象还处于构造中，仍然不安全。 

```c++
.// don`t do this
class Foo:public Observer {
public:
	Fool(Observable* s){
	    s->register_(this); //错误非线程安全
	}
	vitual void update();
}
```


应当使用 ==二段式构造==, 即`构造函数+initialize()`, 这虽然不符合C++教条，但是多线程下别无选择。另外，既然允 许二段式构造，那么构造函数不必主动抛异常，调用方靠`initialize()`的返 回值来判断对象是否构造成功，这能简化错误处理。

```c++
class Foo:public Observer {
public:
	Foo() ;
	//定义另外一个函数，处理回调函数的注册工作
	void observe(Observable* s){
		s->register_(this);
	}
	vitual void update();
}
```




## 1.2 当析构函数遇到多线程:困难


> [!NOTE] 析构安全三问
> 1. 在即将析构一个对象时，从何而知此刻是否有别的线程正在执行 该对象的成员函数？ 
> 2. 如何保证在执行成员函数期间，对象不会在另一个线程被析构？
> 3. 在调用某个对象的成员函数之前，如何得知这个对象还活着？它 的析构函数会不会碰巧执行到一半



对象析构，这在单线程里不构成问题，最多需要注意 避免空悬指针 和 野指针 。而在多线程程序中，存在了太多的竞态条件。对一般成员 函数而言，做到线程安全的办法是让它们顺次执行，而不要并发执行 （关键是不要同时读写共享状态），也就是让每个成员函数的临界区不重叠。这是显而易见的，不过有一个*隐含条件*或许不是每个人都能立刻 想到：*成员函数用来保护临界区的互斥器本身必须是有效的*。而析构函数破坏了这一假设，它会把mutex成员变量销毁掉。


考虑如下代码:

![[Pasted image 20240909003056.png]]

尽管线程`A`在销毁对象之后把指针置为了`NULL`，尽管线程B在调用`x`的 成员函数之前检查了指针`x`的值，但还是无法避免一种`race condition`：

1. 线程A执行到了析构函数的(1)处，已经持有了互斥锁，即将继 续往下执行。 

2. 线程B通过了if (x)检测，阻塞在(2)处。 接下来会发生什么，只有天晓得。因为析构函数会把mutex_销毁， 那么(2)处有可能永远阻塞下去，有可能进入“临界区”，然后`core dump`，或者发生其他更糟糕的情况。 这个例子至少说明delete对象之后把指针置为NULL根本没用


==故作为数据成员的`mutex`不能保护析构==


作为`class`数据成员的`MutexLock`只能用于同步本 `class`的其他数据成员的读和写，它不能保护安全地析构。因为 `MutexLock`成员的生命期最多与对象一样长，而析构动作可说是发生在 对象身故之后（或者身亡之时）。另外，对于基类对象，那么调用到基 类析构函数的时候，派生类对象的那部分已经析构了，那么基类对象拥有的q不能保护整个析构过程。*再说，析构过程本来也不应该需要保护，因为只有别的线程都访问不到这个对象时，析构才是安全的*。


 另外如果要同时读写一个`class`的两个对象，有潜在的死锁可能。比方说有`swap()`这个函数：

```c++
void swap(Counter& a, Counter& b){
	MutexLockGuard aLock(a.mutex_);//potential deal lock
	MutexLockGuard aLock(b.mutex_);
	...//swap
}
```
如果线程A执行`swap(a, b)`;而同时线程B执行`swap(b, a)`;，就有可能 死锁。`operator=()`也是类似的道理.

*一个函数如果要锁住相同类型的多个对象，为了保证始终按相同的顺序加锁，我们可以比较mutex对象的地址，始终先加锁地址较小的 mutex*。
