> 预处理器支持文本宏替换。也支持函数式文本宏替换

[文本替换宏 - cppreference.com](https://zh.cppreference.com/w/cpp/preprocessor/replace)


# 1 语法

  
1. `#define` 标识符 替换列表 ﻿(可选)
2. `#define` 标识符 ﻿`(`形参 ﻿`)` 替换列表 ﻿(可选)
3. `#define` 标识符 ﻿`(`形参 ﻿`, ...)` 替换列表 ﻿(可选)(C++11 起)
4. `#define` 标识符 ﻿`(...)` 替换列表 ﻿(可选)(C++11 起)
5. `#undef` 标识符


# 2 解释

##### 2.1.1.1.1 扫描与替换

- 扫描中*跟踪所替换的宏*。如果扫描找到了与这种宏相匹配的文本，则将其*标记为“将被忽略”（所有扫描都将忽略它）*。这就避免了发生递归。
```c++
#define A B 
#define B A 

A // 如果没有跟踪机制，会导致无限递归替换。
```
- 如果扫描遭到了函数式宏，则*其实参在放入替换列表之前先进行扫描*。但 `#` 和 `##` 运算符接受不经扫描的实参。
```cpp
//函数式宏是指带有参数的宏定义，例如：
#define MAX(a, b) ((a) > (b) ? (a) : (b))

//当使用这样的宏时，宏参数会在替换前被扫描和处理。如果参数本身包含其他宏，这些宏也会被替换。

#define X 10 
#define Y 20 
MAX(X, Y) // 实参 X 和 Y 会被先扫描，替换成 10 和 20，然后进行宏替换。

//`#` 运算符将宏参数转换为字符串，并且不对参数进行扫描替换：
#define TO_STRING(x) #x
TO_STRING(MAX(X, Y))  // 结果是 "MAX(X, Y)"，而不是 "((10) > (20) ? (10) : (20))"

//`##` 运算符用于连接两个宏参数，并且不对参数进行扫描替换：
#define CONCAT(a, b) a##b 
CONCAT(X, Y) // 结果是 XY，而不是 1020
```
- 宏替换之后，扫描所产生的文本。
```cpp
//当一个宏被替换后，替换结果文本仍然可能包含其他宏。这些宏将继续被扫描和替换，直到所有宏都被替换完成。例如：
#define A 10 
#define B A 
B // 第一步替换 B 为 A，第二步替换 A 为 10，最终结果是 10
```

