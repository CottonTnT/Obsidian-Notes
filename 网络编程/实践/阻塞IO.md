# 1 阻塞IO可能一直阻塞
下面使用 echo.cc、echo_client.cc 演示一个阻塞IO实验。
- [echo_clients.cc](https://github.com/CottonTnT/recipes/blob/master/tpc/bin/echo_client.cc)
- [echo.cc](https://github.com/CottonTnT/recipes/blob/master/tpc/bin/echo.cc)

实验在发送 20M 数据时，程序发生了阻塞

![[{73C2AC16-7155-40F2-BF2E-9DB831DECB15}.png]]
使用 `netstat` 命令查看它们各自的收发队列的情况

![[Pasted image 20241231140924.png]]

其主要原因在于：当`echo_server`不接收数据，或者处理速率比发送方的发送速率低导致其接收缓冲区已满（接收窗口win=0），进而导致`echo_client`发送方的发送缓冲区的数据不断堆积进而缓冲区满，此时`send()`将阻塞等待（等待发送缓冲区有空闲空间，即系统在等待对端接收缓冲区有空间）,而 `echo_server` 处理数据时,接受缓冲区已满, 此时`echo_server` 发送数据, `echo_client` 还阻塞在  `send` , 某一刻导致 `echo_client`端的接受缓冲区也满了, 但 `echo_client` 还阻塞在send(),无法取出接受缓冲区的数据,导致形成永久阻塞


这里我们看以查看一下tcp默认的缓冲区打下。
在 /proc/sys/net/ipv4/目录下有三个tcp缓冲区配置文件 tcp_mem tcp_wmem tcp_rmem
![[Pasted image 20241231150755.png]]

这里tcp默认的接收缓冲区为 6M 左右，因此在 echo 的接收缓冲区接近这个阈值时，再来数据就不收了。而由于服务端没有及时处理接收缓冲区的消息，使得客户端的发送缓冲区也满了。因此，客户端就阻塞在send()不再发送数据了。

在echo程序的设计上，服务端每次读4K数据，就向客户端发送一次消息，而客户端是一次发送完所有消息后，才接收服务端的消息。导致服务端向客户端发送的消息，没有及时的读取。

从程序的设计考虑，客户端发送一个20MB的数据是合法的，而服务端预先不知客户端请求数据的大小，采用了读取4K就响应一次的方式，最后导致的阻塞。因此我们在设计应用层协议时，应采取客户端先发送一个 header，告诉客户端请求的大小，然后服务端这边收到 header 后，准备一个符合请求大小的buffer，准备接收请求。然后客户端再发送请求至服务端，服务端这边接收到请求后，计算出一个响应，再按照相同的方式发送回客户端。
                        

# 2 为什么还需要业务层ACK机制


这个问题从操作系统(linux/windows/android/ios)实现TCP协议的原理角度来说明更合适
  
 1 在发送端应用层程序调用`send()`方法*成功*后，实际是*将数据写入了TCP发送缓冲区*, 故无法根据  `send`方法的返回值来确认消息是否已被对端应用甚至对端 接收缓冲区接受
 
 3 根据TCP协议的规定，在TCP连接良好的情况下，TCP发送缓冲区的数据是“有序的可靠的”到达TCP接收缓冲区，然后回调接收方应用层程序来通知数据到达；  
 
 4 但是在TCP连接断开的时候，在TCP的发送缓冲区和TCP的接收缓冲区中可能还有数据，那么操作系统如何处理呢？   
 
  - 对于`TCP`发送缓冲区中还未发送的数据，操作系统不会通知应用层程序进行处理（试想一下：send()函数已经返回成功了，后面再告诉你失败，这样的系统如何设计？太复杂了...），通常的处理手段就是直接回收TCP发送缓存区及其socket资源；
  - 对于`TCP`接收方来说，在还未监测到`TCP`连接断开的时候，因为`TCP`接收缓冲区不再写入数据了，所以会有足够的时间进行处理，但若未来得及处理就发现了连接断开，仍然会为了及时释放资源，直接回收TCP接收缓存区和对应的socket资源。  
  
总结一下就是： 发送方的应用层程序，调用`send()`方法返回成功的时候，数据实际是写入到了TCP的发送缓冲区，而非已经被接收方的应用层程序处理。怎么办呢？只能借助于应用层的ACK机制, 来确定对端应用层是否收到完整的数据。

# 3 send函数的阻塞和非阻塞

　　tcp协议本身是可靠的,并不等于应用程序用tcp发送数据就一定是可靠的.不管是否阻塞,send发送的大小,并不代表对端recv到多少的数据.  
　　在阻塞模式下, send函数的过程是将应用程序请求发送的数据拷贝到发送缓存中发送就返回.但由于发送缓存的存在,表现为:如果发送缓存大小比请求发送的大小要大,那么send函数立即返回,同时向网络中发送数据;否则,send会等待接收端对之前发送数据的确认,以便腾出缓存空间容纳新的待发送数据,再返回(接收端协议栈只要将数据收到接收缓存中,就会确认,并不一定要等待应用程序调用recv),如果一直没有空间能容纳待发送的数据,则一直阻塞;  
　　在非阻塞模式下,send函数的过程仅仅是将数据拷贝到协议栈的缓存区而已,如果缓存区可用空间不够,则尽能力的拷贝,立即返回成功拷贝的大小;如缓存区可用空间为0,则返回-1,同时设置errno为EAGAIN.


**（一）基础知识**

- IPv4 数据报最大大小是65535（16位），包括IPv4头部。
- IPv6 数据报最大大小是65575，包括40个字节的IPv4头部
- MTU，这是由硬件规定的，如以太网的MTU是1500字节，IPv4要求最小MTU是68字节，IPv6要求最小MTU是576字节
- path MTU： 指两台主机间的路径上最小MTU
- 分片（fragmentation)：指ip数据报大小超过相应链路的MTU,IPv4和IPv6都将对ip数据进行分片，到达目的主机后进行重组。
- IPv4头部的DF位用于设置分片还是不分片
- MSS：最大分节大小，向对方TCP通告被通告方在每个分节中能发送的最大TCP数据量。MSS的目的是告诉对方其重组缓冲区大小的实际值，从而避免分片。


# 4 UDP为什么没有缓冲区



- tcp socket的发送与接收缓冲区  

 　　应用程序可通过调用`send(write, sendmsg等)`利用tcp socket向网络发送应用数据，而tcp/ip协议栈再通过网络设备接口把已经组织成struct sk_buff的应用数据(tcp数据报)真正发送到网络上，由于应用程序调用send的速度跟网络介质发送数据的速度存在差异，所以，一部分应用数据被组织成tcp数据报之后，会缓存在tcp socket的发送缓存队列中，等待网络空闲时再发送出去。同时，tcp协议要求对端在收到tcp数据报后，要对其序号进行ACK，只有当收到一个`tcp` 数据报的`ACK`之后，才可以把这个`tcp`数据报(以一个struct sk_buff的形式存在)从`socket`的发送缓冲队列中**清除**。


- UDP因为是`不可靠`连接，不必保存应用进程的数据拷贝，应用进程中的数据在沿协议栈向下传递时，以某种形式拷贝到内核缓冲区，当数据链路层把数据传出后就把内核缓冲区中数据拷贝删除。因此它不需要一个发送缓冲区。写UDP套接口的write返回表示应用程序的数据或数据分片已经进入链路层的输出队列，如果输出队列没有足够的空间存放数据，将返回错误ENOBUFS.