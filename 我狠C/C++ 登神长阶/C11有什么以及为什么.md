# 语言与语法功能改进


## 空指针

### 为什么

 C 和 C++ 中在处理空指针的时候却并没有起到表率作用. 用户一般会用 `NULL` 来表示空指针, 但它并不是关键字, 而是一个宏. 在 C 中它通常被定义为 `(void*)0`, 而 C++ 中因为禁止 `void*` 指针类型向其他指针类型隐式转换, 因此在既有的编译器实现中它通常被定义为整数字面量 0, 或是其它不那么明确的指针常量.

这是个很容易让编译器产生误解的规则. 比如在 C++ 中以 `NULL` 作为实参时, 可能使得重载决议出错

```cpp
void f(int x) { std::cout << "overload int" << std::endl; }
void f(int* p) { std::cout << "overload int ptr" << std::endl; }

f(NULL); // NULL 被定义为 0 时输出 "overload int", 而另一些实现会报重载决议错误
         // 而不会直接决议为对 f(int*) 的调用
```

### 有什么
在 C++11 中引入新的空指针**关键字** `nullptr` 来解决这一问题. 不过, 考虑到向前兼容性, `NULL` 宏的定义并没有被直接改成这一关键字, 要使用它的话必须写上 `nullptr` 这一名字. 如, 修改上面的代码为

```cpp
f(nullptr); // 输出为 overload int ptr
```

`nullptr` 不仅仅可以表示空指针的值, 它还有一个独立的类型 `std::nullptr_t`. 当然这一类型的所有实例都相同, 即都是空指针.

空指针类型并不很常用. 它允许引入针对空指针类型的重载. 如

```cpp
void f(int* p) { std::cout << "overload int ptr" << std::endl; }
void f(std::nullptr_t) { std::cout << "overload nullptr" << std::endl; }

int main()
{
    f(nullptr);       // 输出 overload nullptr

    int* p = nullptr; // 虽然 p 是空指针, 但其类型是 int*
    f(p);             // 输出 overload int ptr

    // 可以使用 nullptr_t 定义对象实例, 这些实例都是空指针
    std::nullptr_t q;
    f(q); // 输出 overload nullptr
    return 0;
}
```


## 禁止赋值构造


### 为什么
C++ 受到诟病的一点是每个类型都会有一个复制构造函数, 即使用户不编写之, 编译器也会合成一个. 而某些类型, 比如文件流 `fstream` 又是不可复制的. 在既有标准中, 用户想到各种方法来应对这一编译器 "特性", 典型的做法是将复制构造函数声明为 `private` 访问限制的, 且只声明而不实现它. 如

```cpp
struct NonCopyable {
    NonCopyable() {}
private:
    NonCopyable(NonCopyable const&); // 声明为 private, 没有实现
};

int main()
{
    NonCopyable n;
    NonCopyable m(n);                // 编译错误
    return 0;
}

// 报错信息为: 此类型的复制构造函数为私有
// error: ‘NonCopyable::NonCopyable(const NonCopyable&)’ is private
```

这种封印的手法的问题一是报错词不达意, 二是偶尔在类的内部出现误用时 (类的内部可是能够使用 `private` 复制构造函数的), 它将导致链接错误而非编译错误, 而链接错误往往又是无法看到源代码行号的.


### 有什么
C++11 标准中打算收拾掉这一乱象, 给出一个简单的方案让用户可以明显地指出某个函数不需要了. 如

```cpp
struct NonCopyable {
    NonCopyable() {}
    NonCopyable(NonCopyable const&) = delete;
};

NonCopyable n;
NonCopyable m(n); // 编译失败, 报错为复制构造函数被删除了
                  // use of deleted function ‘NonCopyable::NonCopyable(const NonCopyable&)’
```

也就是在需要删除的函数后加上一个小尾巴 `= delete`, 这样此类型就无法复制构造了. 当然这只是在语法上限制了复制行为, 有关无法复制的类型更详细的特性, 本书将在 "移动语义" 一章将进行讨论.

这一机制除了可以用来禁止合成复制构造函数之外还可以用来取消掉由基类继承而来的函数, 或防止类型转化重载, 如

```cpp
struct Base {
    void print()
    {
        std::cout << "Base" << std::endl;
    }
};

struct Inherit: Base {
    // 在子类中声明父类中出现过的 print() 函数
    // 并标记为 delete, 那么无法从子类对象调用此函数
    void print() = delete;
};

void f(int x) {}
void f(char ch) = delete; // 标记 char 为参数的重载为 delete

int main()
{
    Base b;
    b.print();
    Inherit i;
    i.print();  // 编译错误: print 在子类中被标记为 delete 了

    f(10);      // 正确: 匹配参数为 int 的重载
    f('c');     // 编译错误: 匹配为参数为 char, 但被删除掉的重载
                // 如果没有 f(char) 的声明, 参数将被扩宽为 int 匹配 f(int) 的重载
    return 0;
}
```


## 即写即用都函数定义


C++11 新增的较为复杂的一个新语法就是 lambda 函数对象. 在本节中将简单介绍如何使用基本的 lambda 语法替代一般函数.

### 为什么
在标准库中提供了许多便利的算法函数, 这些算法函数允许用户传入指定的函数作为算法的策略. 比如最常用的算法函数之一的 `std::sort`, 它允许用户传入一个比较器, 表示如何比较两个对象以决定它们的顺序. 例如

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

struct Person {
    int age;
    std::string name;

    Person(int a, std::string const& n)
        : age(a)
        , name(n)
    {}
};

// 根据两个属性分别排序的函数
bool cmp_by_age(Person const& lhs, Person const& rhs)
{
    return lhs.age < rhs.age;
}

bool cmp_by_name(Person const& lhs, Person const& rhs)
{
    return lhs.name < rhs.name;
}

int main()
{
    std::vector<Person> p{
        {24, "lisi"},
        {23, "zhangsan"},
        {25, "wangwu"},
    };
    std::sort(p.begin(), p.end(), cmp_by_age);
    for (auto const& x: p) {
        std::cout << x.name << " : " << x.age << std::endl;
    }
    /* 输出
    zhangsan : 23
    lisi : 24
    wangwu : 25
    */

    std::sort(p.begin(), p.end(), cmp_by_name);
    for (auto const& x: p) {
        std::cout << x.name << " : " << x.age << std::endl;
    }
    /* 输出
    lisi : 24
    wangwu : 25
    zhangsan : 23
    */
    return 0;
}
```

虽然这样可以实现功能, 但显然, 将 `cmp_by_age` 对 `cmp_by_name` 分离为单独的函数*违背了函数的本意* --- 之所以分离出单独定义的函数是为了代码重用和逻辑封装. 而在本例中, 对象的比较方法作为排序逻辑的一环, 本应在 `sort` 的调用处, *单独定义成全局函数反而割裂了代码逻辑.*

再试想实现下面这一逻辑: 在容器中找到第一个 `age` 小于 20 的对象, 如果使用标准库中的 `find_if`, 应写为

```cpp
bool age_less_than_20(Person const& p)
{
    return p.age < 20;
}

// ...
std::vector<int> p;
// ...
auto i = std::find_if(p.begin(), p.end(), age_less_than_20);
if (i != p.end()) {
    std::cout << i->name << " : " << i->age << std::endl;
}
```

然而想必不会有人这么死脑筋, 相对于下面这样的 for 循环, 上面的写法实在是太繁琐了可以认为这是标准库的用户心中的算计和权衡: 像 `sort`, `set_intersection` 这样的算法函数, 即使需要在其他地方定义冗长的函数也无妨, 因为这些算法本身更复杂; 而像 `find_if`, `count_if` 甚至如 `for_each` 这样的函数则不然, 通常情况下, 一个 for 循环足以替代相应的功能

```
for (auto const& x: p) {
    if (x.age < 20) {
        std::cout << x.name << " : " << x.age << std::endl;
        break;
    }
}
```

### 有什么
而在 C++11 中, 用户可以用 lambda 匿名函数这一更简洁的方式来编写并使用这个函数指针, 下面就用这种方法改写上面的例子
```cpp
int main()
{
    std::vector<Person> p{
        {24, "lisi"},
        {23, "zhangsan",
        {25, "wangwu"},
    };

    // 使用匿名函数作为 sort 的比较器参数
    // 这是一个函数, 它以一对方括号开头, 之后是参数列表, 然后是花括号括起的函数体
    // 但它没有名字, 故被称作匿名函数
    std::sort(p.begin(), p.end(),
            /* 从这里开始 */
            [](Person const& lhs, Person const& rhs) // (a)
            {
                return lhs.age < rhs.age;
            }
            /* 到这里结束 */
    );
    for (auto const& x: p) {
        std::cout << x.name << " : " << x.age << std::endl;
    }
    /* 输出

    zhangsan : 23
    lisi : 24
    wangwu : 25

    */

    std::sort(p.begin(), p.end(),
            [](Person const& lhs, Person const& rhs) // (b)
            {
                return lhs.name < rhs.name;
            }
    );
    for (auto const& x: p) {
        std::cout << x.name << " : " << x.age << std::endl;
    }
    /* 输出

    lisi : 24
    wangwu : 25
    zhangsan : 23

    */

    // 类似地, 也可以使用匿名函数作为 find_if 的筛选条件参数
    auto i = std::find_if(p.begin(), p.end(),
            [](Person const& x)                      // (c)
            {
                return x.age < 20;
            }
    );
    if (i == p.end()) {
        std::cout << "no such person" << std::endl;
    }
    /* 输出

    no such person

    */

    p.push_back(Person(16, "xiaoliu"));

    auto j = std::find_if(p.begin(), p.end(),
            [](Person const& x)                      // (d)
            {
                return x.age < 20;
            }
    );
    if (j != p.end()) {
        std::cout << j->name << " : " << j->age << std::endl;
    }
    /* 输出

    xiaoliu : 16

    */

    return 0;
}
```

(a) (b) (c) (d) 各处就是这一新语法. 


## 禁止继承或覆盖

### 为什么
另一可能的需求是防止类型被继承, 在 C++03 中的技巧是将构造函数定义为 `private` 限定, 这样子类无法构造父类部分. 而后对外暴露工厂函数以产生对象. 如

```cpp
struct DontInherit {
    // 对外暴露工厂方法产生实例
    static DontInherit construct()
    {
        return DontInherit();
    }
private:
    // 将自身构造函数设为私有的
    DontInherit() {}
};

struct SubClass: DontInherit {
    // 在子类中, 这一无参默认构造函数将不会被隐式生成
    // 手动加上此构造函数也无法编译
    // SubClass() : DontInherit() {}
};

int main()
{
    // DontInherit 的实例化要借助于工厂方法
    DontInherit d = DontInherit::construct();

    // 但子类将无法实例化, 此处编译失败
    SubClass s;
    return 0;
}
```

### 有什么
在 C++11 中, 不允许类型被继承这一特性直接被编译器所支持, 新引入的关键字为 `final`, 与 Java, C# 等语言中的基本一致 (除了关键字摆放的位置). 它除了*可以禁止类型被继承, 也能禁止单一虚函数被覆盖*. 其语法如下

```cpp
struct Animal {
    virtual void say() = 0;
    virtual void breed() = 0;
    virtual ~Animal() {}
};

struct Bird : Animal {
    // 1.在虚函数后加上 final 关键字, 该虚函数无法被子类覆盖
    void breed() final { std::cout << "lay eggs" << std::endl; }
};

// 2.在类名后加上 final 关键字, 该类无法被继承
struct Duck final : Bird {
    void say() { std::cout << "ga" << std::endl; }

    // 编译错误: 基类的 breed 是 final 的
    void breed() {}
};

// 编译错误: Duck 是 final 的
struct DonaldDuck : Duck {};
```

这一特性*有助于编译器执行优化*. 若子类将其某个虚函数标记为 `final` 修饰, 或者该子类本身是 `final` 修饰的, 那么这些成员函数的调用将被编译器视为非虚函数调用, 这样就不必在运行时去查找虚表了.

除了 `final` 关键字之外, 另一与虚函数有关的关键字 `override` 可以用来确定当前定义的函数是否覆盖了父类的虚函数. 这一关键字不是必须的, *加上的话有助于检查虚函数签名的正确性*.

```cpp
struct Animal {
    virtual void say() = 0;
    virtual void breed() = 0;
    virtual ~Animal() {}

    void drink() {}
};

struct Bird : Animal {
    // 正确: 此函数覆盖了父类中声明的 void breed() 函数
    void breed() override { std::cout << "lay eggs" << std::endl; }

    // 编译错误: 此函数签名与父类中的 breed 函数不同, 多了 int 参数
    void breed(int x) override
    { std::cout << "lay " << x << " eggs" << std::endl; }

    // 编译错误: 此函数签名与父类中的 breed 函数不同, 多了 const 限定
    void breed() const override
    { std::cout << "lay eggs" << std::endl; }

    // 编译错误: 父类中的 drink() 函数并不是虚函数
    void drink() override {}
};
```

## 编译时断言

在 C++03 标准中, 另一由于没有编译器支持而实现得很繁琐的简单需求是编译时断言, 在 C++11 中则直接将关键字 `static_assert` (C 语言中为 `_Static_assert`) 加入语言本身, 由编译器来检查某个编译时条件是否满足. 其语法如下

```cpp
// 在编译时常量 BOOL_CONSTANT 为 false 时给出一个编译错误, 错误信息为 ERROR_MESSAGE
static_assert(BOOL_CONSTANT, ERROR_MESSAGE);

// 例
static_assert(true, "this is ok");
static_assert(false, "cause a compile error"); // 此行会产生编译错误
static_assert(sizeof(int) == 4, "int is not 4 bytes");
```


## 函数无异常声明
### 为什么
C++03 中, 在函数签名中可以增加一个 `throw(except_a, except_b, /* ... */)` 的抛出声明, 表示函数*只会*抛出这些异常类型, 而一个空的 `throw()` 表示函数*不会*抛出异常. 如

```cpp
void f() throw(std::runtime_error); // f 可能抛出 std::runtime_error, 不可能抛出其他类型异常
void g() throw();                   // g 不会抛出任何异常
```


### 有什么
而 C++11 中新增了关键字 `noexcept`, 其功能之一是*将上述抛出声明简化为二元形式, 即可能抛出, 或不可能抛出*. 其语法形式是在函数签名最后加上 `noexcept(bool 常量)`, 该参数 `bool` 常量表示此函数是否不会抛出异常, 这一常量默认为 `true` (但如果根本不写 `noexcept` 的话, 表示该函数可以抛出异常).

```cpp
void f() noexcept(true);     // f 不会抛出异常
void g(int) noexcept(false); // g 可能抛出异常
void h() noexcept            // h 不会抛出异常; 这时不需要圆括号
void k();                    // 什么也不写: k 可能抛出异常
```

*声明一个函数不会抛出异常有利于编译器生成更简单的可执行文件*. 但如果一个带有 `noexcept(true)` 声明的函数中直接或间接抛出了异常, `std::terminate` 会*被立即调用*, 默认情况下意味着进程将马上结束.

该关键字的另一作用是*在编译时评估一个函数调用是否会抛出异常*, 并返回一个 `bool` 值常量. 这个函数表达式只在编译时使用, 不会被运行求值, 类似 `sizeof` 一样.

```cpp
// 沿用上面的定义
std::cout << noexcept(f()) << std::endl;  // 1
std::cout << noexcept(g(0)) << std::endl; // 0
```

将这两者结合起来, 可以实现一个需求: 如果函数 X 中只调用了函数 Y, 那么函数 X 是否抛出异常取决于 Y 是否抛出异常. 写成代码是这样的

```cpp
void f() noexcept;

void g() noexcept(noexcept(f()))
//                ^^^^^^^^^^^^^  f 不会抛出异常, 故此表达式为 true
//       noexcept(    true     ) 因此这里等价于声明此函数不抛出异常
{
    f();
}

template <typename T>            // 泛型中的运用
void h() noexcept(noexcept(T())) // h 函数是否抛出异常取决于 T 类型构造时产生异常
{ /* ... */ }
```

这是一个美好的愿景, 但在实际运用时, 如果要将一个函数所有调用的其他函数都写进 `noexcept` 声明中的话, 推广这一声明是极其困难甚至不可能完成的. 最坏的情况下甚至可能在 `noexcept` 里的部分相当于把整个函数重新实现一遍.

因此, 实际上只有一些很简单的函数才会加上这一声明. 另外, *析构函数默认都带有* `noexcept(true)` 声明.

需要注意的是, 使用 `noexcept(true)` 以及 `throw()` 声明*都不会强制编译器检查函数是否真的不会抛出异常*, 比如以下代码

```cpp
void f(int x) noexcept
{
    if (x < 0) {
        throw std::out_of_range("");
    }
}
```

虽然在函数体中很明确地有一句 `throw`, 但是编译器并不会在处理这段代码时报错.

## 基于范围的循环

### 为什么

在 C 和 C++ 里有两类循环语句, 一是 `while` 或 `do`-`while`, 另一是 `for` 循环. 相对于 `while` 系的按单一条件循环的语法, `for` 的不同之处在于多出了*迭代初始化*和*迭代变更*两个成分. 如

```cpp
size_t const SZ = 10;
int arry[SZ];
for (size_t i = 0; i < SZ; ++i) {
    arry[i] = i * 2 + 1;
}

// 等价于以下 while 循环

size_t j = 0;
while (j < SZ) {
    arry[j] = j * 2 + 1;
    ++j;
}
```

由于开发者之间对循环的功能达成了共识, 上述 `for` 循环一眼就能看出来是在逐个访问数组的每个元素, 因此相对于使用 `while`, `for` 循环在语义上更为明确, 容易理解.

不过, 在 C++ 中由于标准容器的引入, 这种 `for` 循环会*由于一些容器类型无法按照索引下标随机访问而无法使用*.  因此标准库中设立了迭代器 (iterator) 的机制来帮助用户遍历任何容器中的元素. 如

```cpp
std::set<int> s;

for (size_t i = 0; i < s.size(); ++i) {
    // 编译错误: std::set 集合类型不具备按照下标随机访问的能力
    int val = s[i];
}

for (std::set<int>::iterator i = s.begin(); i != s.end(); ++i) {
    // 正确: 通过迭代器访问元素
    int val = *i;
    std::cout << val << std::endl;
}
```


### 有什么
相对而言这种写法还是容易接受的. 不过, C++11 中又设计了一个新语法, 让针对容器迭代语义进一步简化. 这种基于范围的循环 (range-based loop) 语法如下

```cpp
std::set<int> s;

// 在 for 关键字的括号中使用
// 类型名 标识符 冒号 (:) 要进行迭代的容器 (任何表达式)
// 这一写法与上面传统的 for 循环写法完全等价
for (int val: s) {
    std::cout << val << std::endl;
}
```

编译器处理这一语法的机制实际上就是调用给定的容器表达式的 `begin()` 和 `end()` 函数产生迭代器对象, 然后调用迭代器对象的寻址算符重载 (前置 `operator*()` 重载) 获得相应的元素, 赋值给 `for` 的括号里定义的标识符.

如果提供容器的表达式是个函数调用, 这个调用只会被执行一次. 换言之, 这个表达式只会在循环开始前被求值一次.

```cpp
std::vector<std::string> make_vector()
{
    std::cout << "call make_vector" << std::endl;
    std::vector<std::string> x;
    x.push_back("hello");
    x.push_back("world");
    return x;
}

for (std::string s: make_vector()) {
    std::cout << "s= " << s << std::endl;
}

// 等价于以下代码, make_vector() 函数调用只有一次
std::vector<std::string> __ranged_for_loop_expr(make_vector());
for (std::vector<std::string>::iterator i = __ranged_for_loop_expr.begin();
     i != __ranged_for_loop_expr.end();
     ++i)
{
    std::string s = *i;
    // ...
}

/* 输出

call make_vector
s= hello
s= world

*/
```

另外, 像上面这样写, 每次迭代返回的 `std::string` 对象都会被复制到循环中定义的 `s` 变量里去, 这当然有些性能损耗. 在不需要复制的情况下, 可以将这一变量定义为引用.

```cpp
// 以引用的方式使用迭代的元素
for (std::string const& s: make_vector()) {
    std::cout << "s= " << s << std::endl;
}

// 也可以去掉引用的 const 限制; 这样的话, 循环体中更改引用意味着直接修改了容器内元素的内容
std::vector<std::string> v(make_vector());
for (std::string& s: v) {
    s += " !";
}

for (std::string const& s: v) {
    std::cout << "s= " << s << std::endl;
}

/* 更改了元素之后, 以上一个 for 循环的输出为

s= hello !
s= world !

*/
```

然而, 这一方便的新特性并*没有顾及到逆向迭代*, 也就是说无法通过逆向迭代器 (reverse iterator) 对容器内容进行循环. 不过, 可以在需要的时候加上这样一套工具类型 (需要用户自己添加; STL 中直到 C++17 都没有提供)

``` cpp
template <typename C>
struct reverse_iteration {
    C& c;
    reverse_iteration(C& c_): c(c_) {}

    // 其 begin end 函数返回所引用的容器的 rbegin() rend() 以产生逆向迭代器
    typename C::reverse_iterator begin() { return c.rbegin(); }
    typename C::reverse_iterator end() { return c.rend(); }
};

template <typename C>
struct reverse_iteration<C const> { // 针对 const 限定的偏特化
    C const& c;
    reverse_iteration(C const& c_): c(c_) {}

    // 此偏特化使用 const_reverse_iterator
    typename C::const_reverse_iterator begin() { return c.rbegin(); }
    typename C::const_reverse_iterator end() { return c.rend(); }
};

template <typename C>
reverse_iteration<C> make_reverse(C& c)
{
    return reverse_iteration<C>(c);
}

std::vector<std::string> v(make_vector());
for (std::string const& s: make_reverse(v)) {
    std::cout << "s= " << s << std::endl;
}

/* 输出

call make_vector
s= world
s= hello

*/
```

从这个例子中也可以看出, 如果用户自己实现了一个容器类型, 或者哪怕是上述这样的包装类型, 只要有合适的 `begin()` 和 `end()` 成员函数实现, 就能用在基于范围的循环语法中.


## 嵌套模板结束符号


在 C++ 中, 若使用一个模板类型的特化作为另一个模板的类型参数, 连续两个模板的结束符号 `>` 会合在一起变为右移算符 `>>`, 如

```cpp
std::vector<std::pair<int, int>> x;
//                            ^^
std::vector<std::pair<int, std::set<std::string>>> y;
//                                             ^^^ 还可能出现无符号右移算符
```

在 C++03 中这种写法是不允许的, 模板结束处的连续尖括号之间必须加上空格. 而 C++11 标准则允许这样写, 即上述代码可以被支持 C++11 的编译器正确解析. 不过此改动也不是完美的, 这一规则加入后一些原来可以编译通过的代码反而会出错. 如

```cpp
template <int I>
struct A {};

// 使用右移运算表达式特化接受整型参数的模板
// C++03 中可以编译通过, C++11 中报错
A<3 >> 1> x;
// 两个标准中都认可的写法, 在表达式两边加上括号
A<(3 >> 1)> x;
```

当然也不能说这是设计上的不周, 现实中像上面这样偏偏用到一个右移运算来特化的例子屈指可数, 而嵌套模板的使用则比比皆是. 所以这只是牺牲不常见的用况来方便更常见的写法, 还是很有道理的.



## 新的类型别名机制

### 为什么
在编写代码时, 可以为一些类型设置别名, 使得代码更容易理解. 在既有标准中, 可以使用 `typedef` 关键字定义类型的别名. 如

```cpp
typedef unsigned char byte;
```

以上代码中将类型 `unsigned char` 定义为 `byte`. 就这样直白的别名设置而言, `typedef` 还算看得过去, 但下面这些情况就略显晦涩了

```cpp
typedef int int_arr[10];
typedef int (* fn_type)(int, int);
```

其中第一个别名设置是将 10 个 `int` 构成的数组定义成名为 `int_arr` 类型; 第二个则定义了名为 `fn_type` 类型, 它的类型是函数指针, 这类函数指针指向的函数接受两个 `int` 参数, 返回一个 `int`. 这两种类型别名的语法都将名字放在了语句中间某个位置, 读起来并不直观.

### 有什么
为了改善这一弊端, 在 C++11 中为 `using` 指派了一个新功能, 使得用户可以用更加清晰的方式为类型指定别名. 以上面三种类型别名为例, 它们可写作

```cpp
// 语法形式为
// using 别名 = 类型
using byte = unsigned char;         // 普通类型, 直接写在等号右侧
using int_arr = int[10];            // 数组类型, 用类型名加上方括号和数量
using fn_type = int (*)(int, int);  // 函数指针类型, 在返回值类型和参数列表之间加上 (*)
```

这一语法形式与 `typedef` 不同的是, 在类型别名和实际的类型之间, 显式地插入了一个等号, 等号左边的标识符就是别名. 如此一来, 用户在阅读代码时就能立即明白为怎样的类型设置了什么别名.

除了提供更为明了的类型别名语法, `using` 还可支持泛型类型定义, 如

```cpp
// 语法: 在 template < ... > 泛型声明后立即加上 using 语句
// 泛型参数 T 必须指定, 而 Alloc 有默认值 std::allocator<T>
template <typename T, typename Alloc = std::allocator<T>>
using vec_iter = typename std::vector<T, Alloc>::iterator;

std::vector<int> x;
// 使用 int 特化 vec_iter 别名, 另一泛型参数是默认的 std::allocator<int>
// 因此特化出的类型 vec_iter<int> 为
// std::vector<int, std::allocator<int>>::iterator
vec_iter<int> i = x.begin();
```


##  对象初始化的改进

> 统一的对象初始化语法

C++11 开始统一千奇百怪的对象初始化语法了, 同时各种 STL 容器增加预设元素的初始化方式.

### 为什么
这个故事还要从 C 的一个语法点说起. 在 C 语言中, 如下的代码

```cpp
struct Point {
    int x;
    int y;
};

Point p = {0, 1};
int a[] = {0, 1};
```

同样的 `{0, 1}` 在编译器看来语义是截然不同的, 对 `p` 而言是初始化其成员, 对 `a` 而言则既要推导 `a` 的大小又要设定其元素的值.

而在 C++03 中, 如果为 `Point` 定义一个构造函数, 以下写法就不正确了

```cpp
struct Point {
    int x;
    int y;

    Point(int x_, int y_): x(x_), y(y_) {}
};

Point p = {0, 1}; // 错误: 非 POD 的类型不能用初始化列表构造
```

不过, 只要用 C++11 的编译器, 上述代码中的编译错误就立即消失了. 实际上, C++11 中添加以上语法作为一则初始化语法, 或者说调用构造函数的语法. 如

```cpp
Point p = {0, 1};   // 与初始化 POD 的语法相同
Point q{0, 1};      // 亦可省去等号

// 这两种写法均等价于传统写法
Point r(0, 1);
```

也就是说, 针对构造函数, 可以使用花括号替代圆括号. 这一特性还有助于减少调用无参构造函数时的书写错误. 例如

```cpp
struct Point {
    // ...
    Point() : x(0), y(0) {}
};

Point p();
```

上例中定义 `p` 的实际上并不是调用无参构造函数初始化一个 `Point` 对象, 实际上它是一个函数前置声明, 该函数没有参数并返回 `Point`. 这一新人杀手级语言 "特性" 导致的错误通常在修改代码时, 去掉了构造参数都但没有去掉括号而产生. 而在新语法中, 它可以这样写

```cpp
Point p{};
```

另外, 用户可以利用这一语法特性简化一些 `return` 语句. 当函数需要返回以特定构造函数构造的对象时, 可以使用花括号语法, 而不必写出类名. 如

```cpp
std::string make_string()
{
    return {};
    // 而不需要写
    // return std::string();
}

Point make_point(int x, int y)
{
    return {x, y};
    // 而不需要写
    // return Point{x, y};
}
```

除了以上单个对象的构造语法有所更改, 批量构造对象的语法语义也变得不同. 类似 `int a[] = {0, 1};` 这一例子中, 数组初始化时给出的花括号括起的整数值序列, 它不仅仅可以用于构造数组, 现在也可以用于构造容器了. 比如

```cpp
std::vector<int> x = {0, 1};
// 当然, 也可以去掉等号
std::vector<int> y{2, 3, 5, 7};

for (int i: x) {
    std::cout << "x contains " << i << std::endl;
}
/* 输出
x contains 0
x contains 1
*/

for (int i: y) {
    std::cout << "y contains " << i << std::endl;
}
/* 输出
y contains 2
y contains 3
y contains 5
y contains 7
*/
```

如果编译时知道一个容器里该有些什么东西, 直接写到构造函数里, 比先定义出容器再一个个添加要简单多了.

这一语法看起来很奇特, 不过并不神秘, 也不仅仅被 STL 容器所用 (不仅 `vector`, 其他所有的 STL 容器都支持这样构造). 在 C++11 中, 编译器处理到花括号扩起的类型相同的表达式时, 就会试图将其转换为称作 `std::initializer_list` 的泛型类的实例, 而 STL 容器之所以可以这样构造, 无非是因为它们都有参数 `initializer_list<value_type>` 的构造函数. 当然, 不仅构造函数可将初始化列表当作参数, 一般函数也可以, 如

```cpp
#include <iostream>
#include <initializer_list>

// 以 initializer_list 为参数的函数, 这是一个泛型类型, 需要特化
void f(std::initializer_list<int> x)
{
    // initializer_list 实例的 size() begin() end() 函数使它可以表现得像一个标准容器
    std::cout << "initializer_list size=" << x.size() << std::endl;
    for (int i: x) {
        std::cout << "-- element " << i << std::endl;
    }
}

int main()
{
    f({1, 1, 2, 3});
    /* 输出

    initializer_list size=4
    -- element 1
    -- element 1
    -- element 2
    -- element 3

    */

    f({});
    /* 输出

    initializer_list size=0

    */
    return 0;
}
```

而像 `std::map` 这样, 元素类型不是一个单一的值而是键值对, 在初始化的时候就需要混合使用初始化列表和之前介绍的用花括号括起构造参数的做法

```cpp
std::pair<std::string, int> jan{"jan", 1};
std::map<std::string, int> x{ // map<std::string, int> 中的值类型是 pair<std::string const, int>

    jan,                      // 可以使用一个 pair 实例来复制构造

    {"feb", 2},               // 也可以使用花括号括起的两个值调用构造函数
    {"mar", 3},
};
std::cout << x["feb"] << std::endl; // 2
```

不过这样看起来, 花括号的作用又非常混乱了. 即, *如果花括号中各个元素的类型一致, 那么它被编译器视作一个初始化列表实例; 否则编译器将根据花括号中各表达式的类型, 尝试决议出一个构造函数重载进行调用.*

然而, 假如像上面 `Point` 类那样, 其构造函数的参数类型恰好都是相同的, 构造参数看起来像个初始化列表, 编译器不会很困惑吗?

确实初始化列表的语法仍有歧义. 在这种情况下, 用初始化列表语法去调用函数时, 将*优先匹配*以 `initializer_list` 为参数的重载, 若不存在此重载才会以其他重载作为备选. 比如下面的例子

```cpp
void f(std::initializer_list<int> x) // (a)
{
    std::cout << "initializer_list" << std::endl;
}

void f(Point p)                      // (b)
{
    std::cout << "point" << std::endl;
}

int main()
{
    f({0, 0});                       // 输出: initializer_list
    return 0;
}
```

例子中定义了两个重载, 重载决议会判定为调用 (a), 而将 (a) 删除掉的话, 则重载 (b) 会被执行.

### 委托构造函数

当为一个成员很多的类型编写一组构造函数重载时, 需要给每个构造函数都写上长长的初始化列表. 如

```cpp
struct Person {
    std::string first_name;
    std::string last_name;
    std::string address;
    int score;
    int age;

    // 显式初始化每个成员的完整初始化
    Person(std::string const& fname, std::string lname, std::string const& addr,
           int s, int a)
        : first_name(fname)
        , last_name(lname)
        , address(addr)
        , score(s)
        , age(a)
    {}

    // 只为部分成员执行默认初始化
    // 传统的做法仍然需要将一些原生成员放到初始化列表中
    Person(std::string const& fname, std::string lname, int a)
        : first_name(fname)
        , last_name(lname)
                            // address 作为 string 类型成员, 有构造函数保证其正确初始化, 不必写入初始化列表
        , score(0)          // 但整数或指针等原生类型需要显式初始化
        , age(a)
    {}
};
```

这种写法一方面初始化列表的代码显得臃肿不堪, 另一方面维护难度也很大, 如果新增原生类型成员, 每个构造函数的初始化列表里都需要加上对其的初始化.

在 C++11 中新增了一种初始化列表的书写方式, 即允许一个构造函数调用另一个构造函数作为初始化对象的手段, 如以上代码中的第二个构造函数重载可以调用第一个重载. 如

```cpp
struct Person {
    // ...

    Person(std::string const& fname, std::string lname, std::string const& addr,
           int s, int a)
        : first_name(fname)
        , last_name(lname)
        , address(addr)
        , score(s)
        , age(a)
    {}

    // 使用委托构造函数的做法是, 将另一构造函数的调用作为唯一成分写在初始化列表中
    // 这个例子中, 上一个构造函数重载中初始化了所有成员
    // 其他构造函数都可调用上一构造函数重载, 不用担心漏掉个别成员的初始化
    Person(std::string const& fname, std::string lname, int a)
        : Person(fname, lname, "", 0, a)
    {}
};
```

需要注意的是, C++ 构造函数对成员初始化的要求是不重不漏, 当委托另一构造函数进行构造后, 隐含着 "所有成员都已被正确初始化" 这一结果, 因此不能继续在初始化列表中加任何成分, 或者委托调用其他的构造函数. 例如下面是一些可能误用的情况

```cpp
struct Person {
    // ...
    Person(std::string const& fname, std::string lname, int a)
        : Person(fname, lname, "", 0, a)
        , age(0) // 错误: 不能再初始化其他成员了
    {}
};

struct Base { int x; Base(int x_): x(x_) {} };

struct Inherit : Base {
    int y;

    // 正确: 先调用父类构造函数初始化父类的部分, 再初始化本身的成员
    Inherit(int x_, int y_): Base(x_), y(y_) {}
    // 正确: 委托构造
    Inherit(int x_): Inherit(x_, 0) {}

    Inherit(int x_)
        : Base(x_)
        , Inherit(x_, 0) // 错误, 对父类初始化后, 不能再使用委托构造
    {}
};
```

### 成员缺省初始化

另一可以简化构造函数代码的特性则是为那些无论如何都需要初始化, 并且有固定初始化模式的成员设置缺省的初始化方式. 比如

```cpp
std::string current_date();

class Logger {
    // 为这个 ofstream 类型成员设定缺省的初始化方式
    std::ofstream output{"logs/log-" + current_date() + ".log"};

    int id;
    std::string format;
public:
    Logger(int id)                              // (a)
        : id(id)
    {}

    Logger(int id, std::string const& fmt);     // (b)
        : id(id)
        , format(fmt)
    {}

    Logger(std::string const& filename, int id) // (c)
        : output(filename, std::ios_base::app);
        , id(id)
    {}
};
```

在上例中有三个构造函数重载, 其中 (a) 和 (b) 都没有显式初始化 `output` 成员, 但是 `output` 成员其默认构造函数又不能产生一个可以正常工作的文件流对象, 于是就需要给出一个缺省的初始化方式, 这种初始化就是将构造参数直接写在成员声明处. 如果像 (c) 重载那样指定了 `output` 的初始化方法, 那么指定的缺省初始化就不会被执行.

从例子中还可以看出, 虽然成员初始化参数的模式只能设定一种, 但并不妨碍从这种模式中得出不同的实参, 如果 `current_date()` 这个函数能返回不一样的值, 那么构造不同 `Logger` 实例时其 `output` 指定的文件名仍可以是不同的.

以上写法中不能将初始化的花括号改成圆括号, 否则语法上会被编译器识别为成员函数定义.
``` struct A {
    int m(0); // 错误: 这会被编译器认为是定义函数
    int n{0}; // 正确: 使用花括号括起参数
    int p{};  // 正确: 使用花括号, 无初始化参数, int 被置为 0
};
```

可以复制构造的成员亦可用等号设定初始值^[[使用等号的语法会让编译器认为是复制构造, 但编译器通常会优化掉. 恰好例子中的流对象是不可复制构造的, 因此只有上面这种写法.]]. 如下面例子中的写法也都是正确的.

```
struct A {
    int m = 0;                           // 直接使用等号加上初始值
    std::string s = "1";                 // 相当于 = std::string("1")
    std::string t = std::string(3, '2'); // 显式写作复制构造形式
};
```

## 类型推导
>略


# 常量与字面量

在既有 C++ 标准中, 使用常量要么通过枚举 (enumeration), 要么通过 `const` 限定的名字定义. 而两者多多少少都有一些缺陷: 枚举由于其可以隐式与整数类型互相转换, 因而缺乏类型和取值范围的约束; 而 `const` 关键字有时仅仅表示用户无法修改而并非该值本身是常数, 产生一些二义性.

在新标准中引入了许多常量和字面量的改进, 让枚举类型的运用更加安全, 提供了语义更明确的常量, 并且还加入了用户自定义字面量的机制. 本章中便来一一介绍它们.


## 枚举类型改进


在 C++11 中, 用户可以给枚举类型指定更精确和严格的类型了, 这一点体现在两方面: *允许指定枚举类型的宽度和符号;* 允许在引用枚举常量时要求*用户显式指定枚举的域来减少名字冲突的可能性*.

第一项特性的具体做法是, 在声明枚举类型时如声明继承一样, 为这个枚举类型指定一个 "父类" 类型. 当然, 这与继承并无任何关系, 只是规定此枚举类型可能的取值范围, 这样做可以让编译器提供更好的取值检查. 如

``` cpp
enum flags : unsigned short {//规定枚举类型取值范围
    READONLY = 1,
    READWRITE = 2,
    ADMIN = 4,
};
```

以上声明中规定了 `flags` 枚举中的常量是无符号数且位宽与 `short` 类型一样. 一旦编译器检查到该类型的某个常量取值超过此返回就会报错, 如

```cpp
enum uint_enum : unsigned int {X = -1}; // 错误: -1 不是无符号整数
enum byte_enum : char {Y = 128};        // 错误: 128 超过了 char 的表示范围
```

当然, 为枚举指定类型限定*仍然只能使用整型*, 不能写如 `enum X : double` 的声明.

第二项特性的具体做法是, 在 `enum` 关键字后加上 `struct` 或 `class` 关键字 (凭个人喜好或编码规范, 对编译器而言完全无区别), 作用是所有该枚举类型定义的常量不能直接引用, *必须加上枚举类型名*, 这样做*可以避免枚举常量重名的问题.* 如

```cpp
enum class Province {HUBEI, HUNAN, GUANGDONG, HAINAN};
enum struct City {WUHAN, CHANGSHA, GUANGZHOU, HAIKOU};

Province p = Province::HUBEI; // 正确
City c = City::WUHAN;         // 正确: 以 enum 名作为名字空间访问
City d = WUHAN;               // 错误: WUHAN 在当前上下文中未定义
```

这两个特性也可以结合在一起使用, 如

```cpp
enum class Direction: unsigned char {RIGHT, DOWN, LEFT, TOP};
Direction d = Direction::RIGHT;
```


## constexpr

### 为什么 
除了使用枚举类型, 在 C++ 中也可以使用 `const` 来定义常量, 并且除了整数类型的常量, 它也可以作用于其它类型, 如 `double` 浮点数等.

不过, 使用 `const` 来限定一个名字, 其*初衷只是表示其无法修改, 而若其以常数初始化, 那么编译器认为被定义的名字表示一个常量* (当然常量必然无法修改). 这会产生一定的二义性, 并在给一些代码带来麻烦, 比如

``` cpp
template <int I>
class A {};

void f()
{
    int const N = 5;
    A<N> a; // 合法: 编译器认为 N 是编译时常量
}

void g()
{
    int n = 5;
    int const M = n;
    A<M> a; // 不合法: 编译器认为 M 只是一个无法修改的量
}
```

### 有什么
而在 C++11 中, 一个新的用来定义编译时常量的机制加入了标准. 标准引入了 `constexpr` 这一关键字以区分 `const` 关键字, *使用这一关键字定义的值必须是编译时常数*, 因而可以用于定义固定长度的数组, 或像上例中那样特化模板, `static_assert`, 以及任何需要一个常数的地方. 这一机制的另一个方面是允许通过函数计算返回一个编译时常数, 即使用 `constexpr` 关键字定义的函数在*参数都为常数的情况下*返回的值也可以被认为是一个常数.


而如果使用了 `constexpr` 无法定义出一个常数, 或者 `constexpr` 修饰的函数不满足某些条件, 那么编译器会立即报错. 这也避免了出现 `const` 那样不明确的语义.

### 基本语法和使用

使用 `constexpr` 修饰一个名字定义, 让它一定是编译时常数, 写法是将 `constexpr` 关键字放在定义语句的开头.

``` cpp
constexpr int N = 5;        // 定义 N 为常量 5

template <int I>
class A {};
A<N> a;                     // 可以用于特化模板

static_assert(N == 5, "");  // 可以用于 static_assert
```

与 `const` 不同的是, 它*必须由其他编译时常数在定义处立即初始化*, 不能用于声明形式参数. 另外, 如果*用作定义类的成员, 它必须是 `static` 修饰的*.

```cpp
int x = 0;
const int y = x;                // 这样写是允许的

int m = 0;
constexpr int n = m;            // 错误: 初始值 m 不是一个编译时常数

void f(constexpr int N) {}      // 错误: 不能作为参数

struct X {
    constexpr int M = 6;        // 错误
    constexpr static int M = 6; // 正确: 必须带上 static 修饰
};
```

其中的理由也不复杂: 使用 `constexpr` 就是在定义编译时常量, 因此编译器当然需要一个常量去初始化它; 并且类型的各个实例也没有必要共享一个编译时常量, 声明为静态是合适的做法. 而如果在函数体内定义一个 `constexpr` 修饰的量, *它自动获得 `static` 修饰, 无须显式写出*. 当然, *一般而言这些常量并不会真的被编译器放入程序的静态存储区, 它们往往在编译时就被替换为常数了*.

除了用来定义常量, `constexpr` 关键字也可以用来修饰函数. 修饰全局或静态函数时, *表示这个函数在参数都为常量时将返回一个常量*. 比如

```cpp
constexpr int square(int x)
{
    return x * x;
}

// 也可以修饰模板函数
template <typename T>
constexpr T cube(T x)
{
    return x * x * x;
}

constexpr int I = square(5);     // 25
constexpr int K = cube(-5);      // -125
constexpr double L = cube(1.6);  // 4.096
```

也就是说, 上面这些函数调用实际上由编译器自己执行并计算出了结果, 然后当作编译时常量使用.

这样定义的函数也能在参数不为常量时使用, 不过这样的话, 返回值也就不能作为常量看待了

```cpp
int x = 5;
int y = cube(x);        // 正确: 参数 x 不是编译时常量, 但是可用来调用 cube, 其结果被视为变量
constexpr z = cube(x);  // 错误: 参数 x 不是编译时常量, 调用 cube 返回的结果不被认可为常量
```

在以上例子中的 `constexpr` 函数都比较简单, 不过实际上, `constexpr` 修饰函数时, 有一些规则迫使它**必须**这么简单. 这些规则是

* *调用时必须已经给出完整定义而非前导声明*
* 非构造函数的 `constexpr` 函数只能包括一条 `return` 作为非编译时语句 ("编译时语句" 是笔者的造语, 指代如 `static_assert`, `typedef`, `using`, `enum` 等只在编译时产生效果的语句)
* 构造函数的初始化列表中的表达式, `return` 的表达式中, 只能引用 a) 参数 b) 编译时常量 c) 其他 `constexpr` 函数调用 d) 以上项目的运算或成员 (有运算符重载的情况视作 c 项)

第一条规则是理所当然的, 它保证编译器知道这一函数的定义并能够在编译时模拟执行它.

而接下来一条规则就非常严苛了, 甚至这样的代码也不会被认可[[在 C++14 中这一约束被放宽了, 允许函数在栈上定义 `const` 量或使用简单的分支语句]]

```cpp
constexpr int successor(int x)
{
    constexpr int C = 1; // 可以将这一句改为 enum {C = 1}; 通过编译
    return x + C;
}
```

最后一条规则中约束了这些函数能使用的值也应该都是常数, 毕竟要在编译时执行这些代码. 并且, 函数调用中如果有其他函数也不会产生其他效果, 因为被调用的那些也都是 `constexpr` 函数.

说到这里不得不提, 所有的数学库函数都**不**是 `constexpr` 修饰的. 比如求平方根, 虽然理论上来说完全可以在编译时求得任何常数的平方根, 但实际上 `sqrt` 函数的实现中有产生副作用的可能性, 因为在参数为负数时, `errno` 会被设置 `EDOM` 表示发生了一个定义域错误.

不过这些也只是一些说辞. 在不考虑定义域的情况下, 自行定义 `constexpr` 求平方根函数并不是不可能

```cpp
// 使用二分法求平方根
// PRECISION 值为精度要求
constexpr double PRECISION = 1e-3;

// 猜测值 guess 的平方和原参数 x 小于在容许范围内, 也就是小于精度要求时, 认为此猜测值足够好
constexpr bool good_enough(double x, double guess)
{
    // | x - guess * guess | < PRECISION
    return -PRECISION < x - guess * guess && x - guess * guess < PRECISION;
}

// 如果猜测值 guess 足够好就返回它, 否则, 递归求更精确的值
constexpr double sqrt_impl(double x, double guess)
{
    return good_enough(x, guess) ? guess : sqrt_impl(x, (guess + x / guess) / 2);
}

// 求平方根的功能入口, 以 1.0 作为初始猜测值
constexpr double sqrt_c(double x)
{
    return sqrt_impl(x, 1.0);
}

constexpr double X = sqrt_c(2); // 约为 1.41422
constexpr double Y = sqrt_c(3); // 约为 1.73214
```

从上面这一连串的 `constexpr` 函数也可以看出在严格的规则约束下能做到什么程度. 譬如使用 `?:` 三目算符替代分支语句, 包括使用递归都是允许的. 不过如果递归的次数过深, 编译器会选择报一个错误, 避免在可能实际上有缺陷的代码中越陷越深. 譬如, 利用上述代码求 `sqrt_c(-2)` 时, 在 `sqrt_impl` 中是会无限递归的, 这时会以编译错误收场.

### 自定义常量类型

引入 `constexpr` 的好处除了区分一般 `const` 而获得更明确语义, 和使用函数计算常量之外这两点之外, C++11 还允许自定义常量的类型. 举个例子, 下面这种代码也是可行的

```cpp
struct Vector2d {
    double x;
    double y;

    constexpr Vector2d(double xx, double yy) // (a) constexpr 修饰的构造函数
        : x(xx)
        , y(yy)
    {}

    constexpr double length() const          // (b) constexpr 修饰的成员函数
    {
        // 使用刚才例子中的 sqrt_c
        return sqrt_c(x * x + y * y);
    }
};

constexpr Vector2d v{3.0, 4.0};              // (c) 使用上面定义的 Vector2d 定义常量 v
constexpr double x = v.x;                    // (d) 使用常量 v 的属性定义常量 x
constexpr double len = v.length();           // (e) 使用常量 v 计算得出常量 len
```

这个例子中, `Vector2d` 这个类型定义的内部有两个带有 `constexpr` 修饰的函数, 一是其构造函数, 另一个是非静态成员函数. 然后定义了 `Vector2d` 的实例 `v`, 它以 `constexpr` 修饰, 其被认为是一个编译时常量; 然后, 使用其成员去初始化常量 `x`, 或调用其成员函数 `length()` 得到常量返回值去初始化 `len`.

例子中多次出现了 `constexpr`, 不过其中的内在联系很清晰, 它们是这样的

* 自定义一个可以被用作常量的类型, 那么它必须有*至少一个* `constexpr` 构造函数 (a)
* 应当使用有 `constexpr` 构造函数来构造被定义为常量的实例 (c), 当然, 这时*传给构造函数的实参必须全部是常量*
* 当一个自定义类型的实例被定义为常量后, 它的*成员将都被视作常量* (d) (除了 `mutable` 修饰的成员, 它们仍然被视作一般变量)
* 由于常量对象的各成员都被视作常量, 因此在这些成员上的运算, 或使用这些成员调用其他 `constexpr` 函数, 得到的也将是一个常量; 并且, 可以使用 `constexpr` 修饰成员函数, 让它在对象本身是常量时尽可能返回一个常量 (b)
* 对常量对象调用其 `constexpr` 修饰的成员函数能得到一个常量 (e)

反过来说, 如果上面 (a) 处构造函数的 `constexpr` 被去掉, 那么 (c) 处就无法编译通过, 连带 (d) (e) 也出错; 而如果去掉 (b) 处成员函数的 `constexpr`, 那么 (e) 处调用 `v.length()` 将不被认为得到的是一个编译时常量, 因而初始化 `len` 时产生一个错误.

使用 `constexpr` 修饰成员函数的基本规则跟修饰一般函数差不多, 也是只能有一条 `return` 语句, 其表达式用到的只能是参数或者其他常量等等, 不过还加上一条, 就是可以使用对象自身非 `mutable` 的成员. 另外, *`constexpr` 修饰的成员函数在 C++11 标准中自动带有 `const` 修饰, 但在 C++14 标准中去掉了这一规则, 所以在写代码时最好还是显式写上 `const`*.

而使用 `constexpr` 修饰构造函数的规则就不太一样了: 首先, 构造函数并不需要 `return` 一个值, 于是函数体内不允许有任何非编译期语句; 构造函数的重点在其初始化列表, 如果调用委托构造函数或父类的构造函数, 那么被委托的构造函数或其父类的对应构造函数必须也是 `constexpr` 修饰的; 调用其他构造函数的参数表达式, 或其他成员的初始化表达式中, 所有用到的部分也都必须是常量, 与约束一般 `constexpr` 函数 `return` 表达式的规则相同.

除了以上作用于各个函数上的规则, 用来定义常量的类型本身还有其他要求. 在 C++11 中, 描述能够用来定义常量的类型的术语是**字面类型** (literal type), 所有的基本数据类型都是字面类型, 而自定义字面类型, 则必须满足以下条件

* 该类有至少一个非复制构造函数是 `constexpr` 修饰的
* 该类型有一个平凡的析构函数, 它的每个基类和非静态成员也须递归地满足这个要求

第一条规则在前面中已经说过了, 如果没有 `constexpr` 修饰的构造函数, 那么无法合理地初始化这一常量对象. 而第二条规则是有关编译器如何对待常量的. *对于常量, 编译器可能只在编译时使用它们, 因此, 这个对象可能不会存在于运行时, 也就不会被析构, 这就需要一条约束, 使得这个对象即使不析构也不产生任何问题*.

如果不满足字面类型的定义, 那么用此类型就无法定义常量. 比如字符串类型 `std::string`, 它的析构函数会释放其所持有的堆上资源, 因此不是字面类型

```cpp
constexpr std::string S("hello, world");  // 错误: string 不是一个字面类型
constexpr size_t sz = S.size();           // 连带错误: string::size() 也不可能是常量
```

字面类型除了用来直接定义常量之外, 也可以作为 `constexpr` 函数的参数类型或返回值类型使用. 比如

```cpp
constexpr Vector2d multi(Vector2d const& a, double times)
{
    return Vector2d(a.x * times, a.y * times);
}

constexpr Vector2d m = multi(Vector2d{1, 2}, 2);
constexpr double xx = m.x; // 2.0
constexpr double yy = m.y; // 4.0
```

或者, 将这一功能定义为算符重载, 显得更简洁

```cpp
struct Vector2d {
    // ...

    // 算符重载成员函数也可以加上 constexpr 修饰, 与其他成员函数规则一样
    constexpr Vector2d operator*(double times) const
    {
        return Vector2d(x * times, y * times);
    }
};

constexpr Vector2d m = Vector2d{1, 2} * 2;
constexpr double xx = m.x; // 2.0
constexpr double yy = m.y; // 4.0

// constexpr 也可以用于定义全局的算符重载, 与其他全局 constexpr 函数规则一样
constexpr Vector2d operator*(double times, Vector2d const& a)
{
    return a * times;
}
```

需要指出的是, 若 `constexpr` 修饰一个泛型函数, *其泛型参数用非字面类型特化时, 不构成编译错误, 只不过, 这一特化退化为非 `constexpr` 修饰的*.

比如标准库中, `std::pair` 泛型类的构造函数是 `constexpr` 修饰的, 这意味着在使用两个字面类型特化 `std::pair` 模板类型的情况下, 其实例可以是常量

```
constexpr std::pair<int, Vector2d> velocity{70, Vector2d{1, 0}};
constexpr int speed = velocity.first;               // 70
constexpr bool toward_east = velocity.second.x > 0; // true
```

当然谁也不能料定模板参数类型不含 `string` 之类的非字面类型, 因此需要有这条规则保证在这种情况下不出现编译错误.

```cpp
// 正确
std::pair<int, std::string> x{0, ""};

// 错误: 特化出的 pair<int, string>(int, string) 构造函数退化为非 constexpr 函数
constexpr std::pair<int, std::string> y{0, ""};
```

### 优化意义上的 `constexpr` 函数

在上面的介绍中指出了 `constexpr` 与字面类型之间的联系. 一个 `constexpr` 函数的返回值类型和各形式参数类型, 如果不是模板类型参数, 那么必须都是字面类型. 理由也很明显, 因为这些函数可用以定义只存在于编译期的常量, 因此, 它们不应该有非平凡的析构函数.

不过相对于其他函数而言, 构造函数有点特殊, 它并没有返回值. 更准确地说, 构造函数在给定地址空间上进行的一系列初始化对象的行为, 虽然将对象构造的调用放在表达式里其值是这个对象, 但这个构造调用并没有 "返回" 一个对象. 这样一来, 如果一个非字面类型的构造函数的各个参数类型是字面类型, 并且满足其他 `constexpr` 修饰函数时的规则, 那么这个构造函数仍然可以是 `constexpr` 修饰的.

比如, 实现一个这样的指针包装类型

```cpp
class IntPtr {
    int* ptr;
public:
    // 此类型实例内部的 ptr 指向堆上空间
    explicit IntPtr(int x)
        : ptr(new int(x))
    {}

    // 析构时, 需要归还堆上空间
    // 因此, 这不是一个字面类型
    ~IntPtr()
    {
        delete ptr;
    }

    IntPtr(IntPtr const&) = delete; // 简单起见, 不允许复制

    // 但是, 其某些构造函数可以是 constexpr 修饰
    // 如下面这个, 满足 constexpr 构造函数的各个规则约束就行
    constexpr IntPtr()
        : ptr(nullptr)
    {}
};

constexpr IntPtr p; // (a) 编译错误: IntPtr 不是字面类型不能用来定义常量
IntPtr q;           // (b) 编译通过
```

上面例子中, `IntPtr` 类型虽然不是字面类型, 但可以拥有 `constexpr` 修饰的构造函数; 然而, 即使有 `constexpr` 修饰的构造函数, 却不能用这个构造函数定义常量, 因此 (a) 处无法编译.

这样绕来绕去的, 看起来这好像是绕过规则而产生的一个漏洞, 但它仍然是有意义的.

实际上, 当一个函数被 `constexpr` 修饰时, 其真正的作用是, 若该其参数为编译时常数, 那么编译器会将直接编译时初始化该函数返回的对象地址空间, 即有可能的话, 编译器会在编译时计算将该函数的返回值, 然后生成直接写入常数的代码, 减少运行时开销. 这使人感觉像一个更加高级的 `inline` 修饰, 反而跟编译时常量关系不大, 只不过恰好利用函数计算编译时常量可以藉由这样的函数来完成. 而用 `constexpr` 修饰非字面类型的构造函数 (或字面类型的构造函数) 就是仅运用了这一高级 `inline` 机制, 避免构造函数调用开销, 生成直接将实例的各成员的值设为常数的运行时代码. 因此如果程序执行到上述代码的 (b) 处, 它并不会调用构造函数, 而是根据构造函数的指示, 直接在对象的地址上写入一个空指针的值, 对于 x64 架构而言, 就是填上 8 字节的零.

所以, 即使不是用来定义常量, 也可以将一些简单的函数定义为 `constexpr` 函数, 让编译器尽情优化之.


## unicode 常量
在 C++11 标准中新引入了 UTF-8 预编码字符串的机制, 可以*让编译器在编译时对字符串字面常量进行转码*. 如以下代码

```cpp
#include <iostream>

char u[] = u8"汉";

int main()
{
    std::cout << u << std::endl;
    return 0;
}
```

这样在程序运行时将以 UTF-8 的编码输出 "汉" 字, 前提条件之一是编译器能正确处理输入文件的编码, 如 GCC 会从系统上下文获取默认的输入编码方式, 或以 `-finput-charset=` 来指定编码, 此编码应当与输入文件的编码方式一致, 换言之编译器在这时也扮演一个编码器的角色. 另一个前提条件是命令行软件本身能支持 UTF-8 内容的显示, 比如 Linux 的 xterm 能正确显示 UTF-8 编码的内容, 但 Windows 自带的 cmd 则不能正确显示.

由于编译时完成了编码, 得到的结果就是字节序列, 因此定义的 `u` 的类型为 `char[]`.

如果要以宽字符存储字符串字面量, 以前的 `L` 前缀仍然可以用, 但定义出的 `wchar_t` 的宽度仍然是一个编译器确定的值, 这实在是容易引起问题的地方. 所以 C++11 又加入了两个新的固定宽度的字符类型, 以及相应的前缀, 如

```cpp
char16_t c16 = u'汉';   // 小写 u 开头表示以 UTF-16 编码的字符或字符串
char32_t c32 = U'汉';   // 大写 U 开头表示以 UTF-32 编码的字符或字符串
char16_t s16[] = u"汉";
char32_t s32[] = U"汉";
```

请注意, 由于 UTF-8 编码得出的序列不是宽字符, 因此并不存在 `u8'汉'` 字符形式, 只有字符串形式.

然而标准中很尴尬的一点是, 并没有新增对应预定义输出流 (比如 `std::cout` 之于 `char[]` 或 `std::wcout` 之于 `wchar_t[]`), 因此如果在程序中用适于一般字符或宽字符的流来输出它们, 这些字符类型将转换成整数输出, 而字符串将转换为地址输出.

当然, 文本编码并不是简单的几个数据类型换来换去就能解决的, 要按照具体的情况选择合适的方法. 比如 HTTP 通信中向客户端发送内容, 宜用 UTF-8 编码的字节序列; 而本地程序的用户界面最好还是使用专门的国际化工具来转换程序中的字符串.

## 免转义字符串常量

C++11 中开始支持免转义以及多行字符串字面量来降低在源代码中编写复杂文本内容的难度. 其形式为

```cpp
R"自定义分隔符(任意字符内容)自定义分隔符"
```

其中 "自定义分隔符" 可以是任意内容, 圆括号前后的两部分自定义分隔符必须相同. 比如

```cpp
auto x = R"delim(Print "hello, world".)delim";
//               ^^^^^^^^^^^^^^^^^^^^^
// 字符串内容为圆括号中间的部分, 不含圆括号, 双引号不会引起字符串结束
// 必须由一个反圆括号, 分隔符, 引号结束
std::cout << x << std::endl;

/* 输出

Print "hello, world".

输出结束 */
```

如果要指定编码前缀, 这个前缀要出现在 `R` 之前, 如

```cpp
auto x = u8R"""(汉字)"""; // 正确, 等价于 u8"汉字"
auto y = Ru8"""(汉字)"""; // 错误, u8 前缀必须出现在 R 之前
```

此外, 这种方式还可以定义多行字符串, 比如

```cpp
auto x = R"""(
hello
world
)""";
// 等价于 "\nhello\nworld\n", 请注意开始的圆括号之后和结束的圆括号之前的换行符也计入

auto y = R"""(
 ________   _____     _____    ________  ________
/       |   |   |     |   |   /       | /       |
|       | --'   '-- --'   '-- |_      | |_      |
|     --  |       | |       |   |     |   |     |
|       | --.   .-- --.   .--   |     |   |     |
\_______|   |___|     |___|     |_____|   |_____|
)""";
// 请注意最后一行文本第一个字符反斜线 (\) 不再有转义功能, 而被作为普通字符进入字符串定义

std::cout << x << std::endl;
std::cout << "====" << std::endl;
std::cout << y << std::endl;

/* 输出

(空行)
hello
world
(空行)
====
(空行)
 ________   _____     _____    ________  ________
/       |   |   |     |   |   /       | /       |
|       | --'   '-- --'   '-- |_      | |_      |
|     --  |       | |       |   |     |   |     |
|       | --.   .-- --.   .--   |     |   |     |
\_______|   |___|     |___|     |_____|   |_____|
(空行)

输出结束 */
```



## 自定义字面量后缀

在 C 语言中, 程序员可以使用后缀来指定一个字面常量的类型, 比如以下的代码

```cpp
printf("%lld\n", -1);   // 错误: 常数 -1 压栈时只会占用一个 int 类型的空间, 少于一个 long long 类型的部分将是未初始化的栈空间
printf("%lld\n", -1LL); // 正确输出 -1
```

可以被指定后缀的类型仅限于对整型类型的修饰, 譬如上面的 `LL`, 或者加上 `U` 表示无符号. 在 C++11 中, 这个功能被开放了, 可以自定义一些后缀置于字面常量之后, 改变该字面常量的特性.

``` cpp
// 定义一个指定后缀的函数重载, operator "" 为语法固定部分, 后缀为 _s
std::string operator "" _s (char const* m, std::size_t)
{
    return std::string(m);
}

auto r = "hello, world"_s;
// 其中 "hello, world" 为原始字面量, _s 为后缀
// 表达式 "hello, world"_s 的类型为 string
// 因此定义的 r 为 string 类型而不是 char const*
```

自定义后缀实际上与算符重载并无任何关系, 只是它借用了算符重载的语法 (这一算符重载不可以被定义为类的成员函数, 只能定义在全局或任何名字空间下), 其中在返回值类型之后的 `operator ""` 是固定成分, 之后为自定义的后缀名, 接下来是参数列表和函数体.

使用自定义后缀等价于在该表达式位置调用该自定义后缀函数, 如上述定义等价于

```
auto r = operator "" _s("hello, world", 13); // 13 为字符串 "hello, world" 的字符个数, 含 nul
//       ^^^^^^^^^^^^^^ 这一段相当于其函数名
```

为了防止定义的后缀重复, 实际项目中建议在名字空间内定义后缀, 避免污染全局空间, 需要使用时在源码中 `using` 之, 如

```
namespace strliteral {

    std::string operator "" _s (char const* m, std::size_t)
    {
        return std::string(m);
    }

}

int main(int argc, char* argv[])
{
    // 可以 using 整个名字空间, 或者用以下语法仅导入个别后缀
    using strliteral::operator "" _s;
    if (argc != 1) {
        std::cout << "hello, "_s + argv[1] << std::endl;
        std::cout << ("hello, "_s == argv[1]) << std::endl;
    }
    return 0;
}
```

虽然声明自定义后缀函数的语法看起来有些怪, 但特定情况下用起来还是能省事不少, 比如上面将字符串字面常量转换为 `std::string` 类型对象以便与其他 `char*` 表示的字符串连接或比较等.

使用自定义后缀函数的语法必须是字面常量后直接连接后缀标识符, 中间不得有空格或任何其他内容, 如上面的例子中

```
auto r = "hello, world"_s;  // 这是正确的
auto s = "hello, world" _s; // 这是错误的
```

在这样的语法限制下, 定义后缀函数重载时可选的参数类型只有 4 大类, 分别对应于整数字面常量, 浮点数字面常量, 字符字面常量 (分为 `char` 类型和各种宽字符类型的版本) 以及字符串字面常量 (同样区分 `char` 类型和宽字符类型的版本). 除了这些类型, 其他类型都不可以出现在后缀函数重载的参数中. 例如下面这种写法是错误的.

```cpp
std::string operator "" _s (std::string s);
//                          ^^^^^^^^^^^ 以 std::string 类型作为参数是不可以的
```

更具体的, 自定义字面量的函数重载的参数列表只能是下面几种

|! 参数列表 | 匹配原生字面常量 | 调用举例
| `(CHAT_TYPE const*, std::size_t)` | 字符串常量; `CHAT_TYPE` 可能是 `char` `wchat_t` `char16_t` `char32_t` 之一; `size_t` 参数指出该字符串字面量的字符数量, 计入 nul | `"hello"_s`
| `(char const*)` | 形如 `10_suffix` 的表达式, 将前方的数字以字符串形式传入, 等价于 `operator "" _suffix("10")` | `10_km`
| `(CHAT_TYPE)` | 单个字符; `CHAT_TYPE` 与第一条中的字符类型一致 | `U'c'_encode`
| `(unsigned long long int)` | 也匹配形如 `10_suffix` 的表达式 (如果是带一个符号的整数字面量, 那么先将整数传给重载函数, 然后符号应用于返回的结果) | `10_km`
| `(long double)` | 浮点数 | `2.718_percent`

以 `char const*` 为参数的重载也能匹配以整数或浮点数为原始字面常量的变换, 同时定义时, 只有接受数值类型的重载会被调用, 当然一般也不会同时定义两个. 这一重载还有个变种形式

```
template <char... ch>
RETURN_TYPE operator "" _SUFFIX()
{
    /* ... */
}
```

函数本身无参数, 而可变模板参数 `char... ch` 则是数字字面常量部分的各个字符. 这一部分的内容将在后文 "可变参数模板" 一章中说明.

要注意的是, 以整数字面量或浮点数字面量为原始字面量时, 如果这个变量是带符号的, 那么字面量会先跟后缀结合调用自定义后缀函数, 然后跟符号结合调用单目算符重载函数. 这一点有时会引起误用, 比如为 "温度" 这个概念定义一个 "摄氏度" 的后缀

```
struct Temperature {
    long degree;

    explicit Temperature(long t)
        : degree(t)
    {}

    // ...
    // 没有其他算符重载
};

Temperature operator "" _c (unsigned long long t)
{
    return Temperature(t + 273);
}

int main()
{
    // 需求为定义一个表示零下 57 摄氏度的实例
    // 但下面的表达式等价于 -(57_c), 而表达式 57_c 的类型是 Temperature, 没有定义前置负号算符重载会导致编译错误
    Temperature co2_bolling_point = -57_c;
    return 0;
}
```

如果希望以上写法成立, 就必须再为 `Temperature` 重载前置负号操作符, 而不能用括号括起前面的 `-57` 写成 `(-57)_c`, 因为这并不是正确的自定义字面量语法.

然而, 如果这种情况下加上如下定义

```
struct Temperature {
    long degree;

    explicit Temperature(long t)
        : degree(t)
    {}

    Temperature operator-() const
    {
        return Temperature(-this->degree);
    }

    // ...
};
```

虽然写出 `-57_c` 这样的表达式并不会再有编译错误, 但其语义是错误的. 因为这样会先计算 `57_c` 得到一个 `degree` 为 330 的实例, 然后运用负号算符构造出 `degree` 为 -330 的实例, 与初衷相去甚远. 在这种情况下, 直接使用构造函数调用如 `Temperature(-57)` 才是可行的做法.

自定义字面量这一特性虽然名字上叫做 "字面量", 但切不可将其与字面**常量**混为一谈, 它的求值过程默认情况下是运行时的. 而若有需要编译器将其结果视作编译时常量, 则需要用到 `constexpr` 来修饰它. 而另一个前提是其返回值类型 `Temperature` 是字面类型. 根据这些条件, 可将代码修改成下面这样

```
struct Temperature {
    long degree;

    // 构造函数加上 constexpr 修饰
    constexpr explicit Temperature(long t)
        : degree(t)
    {}

    // ...

    // 不要有析构函数定义
};

// 也加上 constexpr 修饰
constexpr Temperature operator "" _c (unsigned long long t)
{
    return Temperature(t + 273);
}

int main()
{
    // 万事俱备, 可以用来定义编译时常量了
    constexpr Temperature water_bolling_point = 100_c;
    static_assert(water_bolling_point.degree == 373,
                  "I'm supposed to work under a standard atmosphere");
    return 0;
}
```

而若之后的代码中不再使用 `water_bolling_point` 这个常量, 那么是否可以这么简写呢?

```
static_assert(100_c.degree == 373,
              "I'm supposed to work under a standard atmosphere");
```

虽然看起来好像完全没问题, 但实际上不行, 而且编译器给出的错误信息会让人匪夷所思

```
error: unable to find numeric literal operator ‘operator"" _c.degree’
     static_assert(100_c.degree == 373,
                   ^
```

在给出的错误信息中, 编译器显然认为 `_c.degree` 是一个整体, 而尝试去找这样的后缀函数重载. 显然不可能存在这样的重载, 因为后缀算符重载不能作为某个类的成员函数定义, 而且即使作为名字空间内的函数定义, 也不存在如 `100_literal::_c` 的带名字空间的写法.

要解决这个 "错误" 当然不困难, 只要在字面量两边套上一层括号即可, 如 `(100_c).degree`, 这也是推荐的编码方式.

造成以上编译错误的原因也并不是编译器实现本身的问题. 实际上这个问题与编译器对数值字面常量处理有关.

这里举一些数值字面常量的简单例子, 它们都是正确的

```
1e-5
0x1ULL
1e+7L
```

再举一些**错误**的字面常量的例子

```
1..0
1e++5
1e+5.5
```

第一个错误的原因不难发现, 是小数点太多了, 第二个是指数中加号多出来一个, 第三个是指数带了小数点. 总之错误都一目了然.

那么, 各位读者, 若你们认同此处用**一目了然**这个词, 不妨考虑一下, 对于编译器来说是否也应当是一 "目" 了然? 如果编译器要做到一目了然地报错, 应当采取哪些措施呢?

在实现时, 编译器词法分析处理到 `1..0` 有两种选择:

* 采用 "正确" 方式, 将它分解为 `1.` 和 `.0` 两个词法元素 (token), 两者都是正确的字面常量, 之后语法分析时报错
* 用**最长适配** (maximal munch) 策略先把这一整个输入都解析为一个词元, 再分析这个词元, 并报词法错误

在这个简单例子里, 采用两者报错似乎都差不多, 至少数量上都是 1 个错误, 而且错误也应该都比较好懂.

但是后面的例子呢? 比如 `1e++5` 这个, 如果词法分析时一定要正确分词, 那么分得的词元将依次是 `1`, `e`, `++`, `5`, 语法分析器一看这一排什么鬼, 至少会报 2 个语法错误

* 字面常量 `1` 后面不应该跟一个标识符 `e`
* `++` 运算符不是双目运算符之后不能再放一个 `5`

这样就非常地不 "一目了然" 了. 所以在实现时, 编译器往往在词法分析时就尽量采用最长适配策略将一段输入尽可能揉成一个词元, 然后再抽取其中的子项. 对于数值字面量来说, 其规则大致是

* 所有以数字, 或点号加数字开头
* 后面接任意多个数字, 字母, 下划线, 点号, 加号或减号

先姑且全部拿下作为一个数, 然后再慢慢抽取其中的底数指数后缀. 不过这个策略有时就会造成误判, 如 `100_c.degree` 就满足上面这两个条件, 所以前面的底数部分 `100` 解析完之后, `_c.degree` 整个被拿出来当作了一个后缀.

除了以上情形之外, 这种写法也会踩到坑

```
int foo = 0;
int bar = 0xe+foo; // 错误
```

其中 `0xe+foo` 会被认为是一整个字面量, 而非 `0xe` 加上 `foo`. 当然, 在双目运算符前后加上空格是良好编码风格的表现之一, 遵循此风格就不会出现这种错误了.


# 引用类型改动

引用类型是 C++ 类型系统中的一个重要而独特的组成部分. 通过引用, 开发者可以为对象创建别名, 以便高效地使用之.

既有的类型体系中, 引用被二元地分为非 `const` 引用和 `const` 引用, 在一些情况下这种简单的区分会导致误解和误用. 为了使代码在语义上更加明确, C++11 中加入了右值引用和广义引用类型以对应各种不同的语义需求, 并为移动语义和完美转发等特性打下了基础.


## 临时对象调用的重载决议


C++ 中的引用一直以来有个令人困惑的特性, 就是*带有 `const` 限定的引用可以绑定临时对象甚至字面常量*, 如

```cpp
#include <iostream>

void test_ref(int& m)
{
    std::cout << "non-const " << m << std::endl;
}

void test_ref(int const& m)
{
    std::cout << "const " << m << std::endl;
}

int zero() { return 0; }

int main()
{
    int a = 0;
    int const b = 1;
    test_ref(a);      // 输出 non-const 0
    test_ref(b);      // 输出 const 1 : 这两句没有争议

    test_ref(zero()); // 输出 const 0 : 临时对象匹配 const 引用重载
    test_ref(1);      // 输出 const 1 : 字面常量也匹配 const 引用重载

    // 一个特别的规则, const 引用可以显式直接绑定临时对象或字面量
    int const& m = zero();
    int const& n = 1;
    return 0;
}
```

这一规则里, `const` 限定引用实际扮演着两种不同的身份: 对不可修改的值的引用, 还有对临时对象或字面常量的引用. 这就会产生混淆, 进而导致误用. 然而这是为什么呢? 有一个非常朴素的原因, 就是防止临时对象被作为左值赋值. 即防止类似下面的代码编译成功

```cpp
zero() = 1;
```

但这样的防御措施并不完美, 有时反而还会造成更大的混乱, 比如下面这段代码

```cpp
#include <iostream>

struct MyClass {
    // 定义重载分别对应 const 限定和非 const 限定的情况
    void print()       { std::cout << "non const" << std::endl; }
    void print() const { std::cout << "const" << std::endl; }
};

// 同样定义两个全局函数重载, 分别对应 const 限定和非 const 限定的情况
template <typename T>
void p(T& t) { t.print(); }

template <typename T>
void p(T const& t) { t.print(); }

int main()
{
    MyClass().print(); // (a) 直接在临时对象上调用 print() 成员函数
    ::p(MyClass());    // (b) 将临时对象传给全局 p 函数, 由 p 来决议 print() 成员函数调用
    return 0;
}
```

那么这段代码输出是什么呢? 结果可能有些令人惊讶, 是

:::
non const
const
:::

也就是说, (a) 处直接*用临时对象调用其成员函数 `print`, 重载决议使其调用的是无 `const` 版本*; 而在 (b) 处稍作更改, 将临时对象传给全局 `p` 函数, 决议的结果的是参数为 `const` 限定引用的 `p` 函数重载, 进而在 `p` 内用 `const` 限定引用决议出带有 `const` 版本的 `print` 成员函数重载.

这一规则直接导致了一些更离谱的代码, 比如 `operator=` 重载一般都不会有 `const` 限定, 那么下面这种代码完全合法

```cpp
struct IntWrap {
    int x;
    explicit IntWrap(int xx) : x(xx) {}

    IntWrap& operator=(int xx)
    {
        this->x = xx;
        return *this;
    }
};

int main()
{
    IntWrap(10) = 20; // 使用临时对象的 = 算符重载, 可将临时对象放在等号左侧
    return 0;
}

// 更极端的例子
IntWrap& f()
{
    // return IntWrap(0); 不合法, 不能直接返回临时对象
    return IntWrap(0) = 0; // 合法, 因为一次 operator= 调用将返回值 "洗" 成了左值引用
}
```

此大乱之道也, 焉能不正之. 而混乱的根源就是对待临时对象时, *调用成员函数决议重载的规则与调用其他函数决议的规则大相径庭.*

因此, 新标准中增加了针对临时对象和字面量的新的引用类型, 并更改了相应的重载决议规则, 以改正上述这些令人困惑的行为.


## 右值引用与重载决议修正
首先, C++11 中加入了针对临时对象和字面量**右值引用** (rvalue reference) 类型, 这种类型是专门针对临时对象和字面常量的. 如果为一族函数加上*以右值引用为参数的版本*, 那么*使用临时对象作为实参时, 优先决议出的就是这一重载*. 如

```cpp
void test_ref(int& m) { std::cout << "non-const " << m << std::endl; }
void test_ref(int const& m) { std::cout << "const " << m << std::endl; }

// 增加参数为右值引用的重载
// int 的右值引用类型的写法为 int&&
void test_ref(int&& m)
{
    std::cout << "rvalue " << m << std::endl;
}

int zero() { return 0; }

int main()
{
    int a = 0;
    int const b = 1;
    test_ref(a);      // non-const 0
    test_ref(b);      // const 1  : 这两句输出仍然不变

    test_ref(zero()); // rvalue 0 : 临时对象匹配右值引用重载
    test_ref(1);      // rvalue 1 : 字面常量也匹配右值引用重载
    return 0;
}
```

这一类型语法上写为类型名之后加上 `&&` 符号, 如 `int&&` 就是 `int` 类型的右值引用, `std::string&&` 是 `std::string` 的右值引用类型, 等等. 不得不说, 这个符号跟逻辑与运算的操作符完全一样, 不免有时会引起歧义, 就像引用符号 `&` 也是按位与运算符一样. 在编码时, 如果用到双目运算符而非声明引用, 也应当在其前后加上空格 (就像在自定义字面量中所提到的应注意的情况一样). 而在后文叙述中, 本书将尽量以 "右值引用符号" 指代表示右值引用的 `&&` 符号.

另外, 右值引用这一命名的由来是相对于左值引用, 听起来略带一些调侃. 之前已经提到, C++ 的一些特性使得 "左值" "右值" 这些概念实际上没有与等号有左右方向上的对应关系, 仅仅是一个名字而已. 如果可以的话, 读者更应该将其理解成对临时对象的引用.

右值引用除了可以区别于 `const` 限定引用, 在非成员函数的调用时影响重载决议之外, 还有一个好处是, *允许修改其绑定的临时对象*. 这一点其实与从临时对象上调用成员函数, 决议出其非 `const` 限定的重载一样. 或者反过来说, 本来临时对象就应当是可修改的, 在决议非成员函数调用时强制其匹配 `const` 引用并不那么合适. 而且允许修改临时对象, 有时还能提高程序性能, 如

```cpp
#include <vector>
#include <algorithm>
#include <iostream>

std::vector<int> make_vector()
{
    std::vector<int> x{2, 1, 5};
    return x;
}

void output_sorted(std::vector<int> const& v)
{
    std::cout << "use const ref" << std::endl;

    // std::sort(v.begin(), v.end()); // 编译错误: v 是 const 限定的

    // 如果临时对象匹配 const 引用, 那么不能在容器上排序, 必须复制一份
    std::vector<int> u(v);
    std::sort(u.begin(), u.end());
    for (auto x: u) {
        std::cout << x << std::endl;
    }
}

void output_sorted(std::vector<int>&& v)
{
    std::cout << "use rvalue" << std::endl;

    // 而右值引用允许修改引用对象, 故可以直接排序
    std::sort(v.begin(), v.end());
    for (auto x: v) {
        std::cout << x << std::endl;
    }
}

int main()
{
    output_sorted(make_vector());
    return 0;
}

/* 输出

use rvalue
1
2
5

*/
```

而将字面常量绑定到右值引用, 也可以修改, 似乎有些无法说通. 这时可以*将字面常量考虑为由一个函数返回的临时值*, 就不那么难以理解了. 即

```cpp
int&& i = 0;      // 直接把字面常量绑定到右值引用上?
int&& j = int(0); // 实际上等价于这种写法, 看起来构造函数产生的临时对象
```

以上临时对象和字面常量是两种典型的右值, 其它可能是右值的情况也都在下面这个例子中

```cpp
void test_ref(int& m) { std::cout << "non-const " << m << std::endl; }
void test_ref(int const& m) { std::cout << "const " << m << std::endl; }
void test_ref(int&& m)  { std::cout << "rvalue " << m << std::endl; }

struct Point {
    int x;
    int y;

    Point(int x_, int y_): x(x_), y(y_) {}
};

int four()
{
    return 4;
}

int main()
{
    int x = 1, y = 2;

    test_ref(2);                         // rvalue 2 : 字面常数
    test_ref(x + y);                     // rvalue 3 : 原生类型运算
    test_ref(four());                    // rvalue 4 : 函数调用返回的值
    test_ref(Point(5, 6).x);             // rvalue 5 : 临时对象的某个属性

    int six = 6; int const seven = 7;
    // 显式转换非 const 左值引用为右值引用
    test_ref(static_cast<int&&>(six)); // rvalue 6
    // 但无法应用于 const 引用, 即 static_cast<int&&>(seven) 无法编译

    // 虽然 constexpr 常量在编译之后会被编译器优化为字面常量!
    // 并且它本身还可以作为数组长度定义或作为模板实参
    // 但它是 const 限定左值引用
    constexpr int M = 7;
    test_ref(M);                         // const 7

    // 而枚举常量则算是字面常量右值 !
    enum {N = 8};
    test_ref(N);                         // rvalue 8
    return 0;
}
```

区分成员函数是否允许从临时对象上调用, 也是右值引用加入之后一项重要的修订工作. 修订工作的首要一项是, 增加一个语法规则*使得临时对象无法调用某些成员函数*. 它的做法是在对应的成员函数后*加上一个左值引用符号*, 如

```cpp
struct IntWrap {
    int x;
    explicit IntWrap(int xx) : x(xx) {}

    IntWrap& operator=(int xx) & // 限制无法从右值, 也就是临时对象上调用
    {
        this->x = xx;
        return *this;
    }
};

int main()
{
    IntWrap(10) = 20;            // 编译错误, 此 operator= 必须从左值上调用
    return 0;
}
```

不过, 如果不加上这个引用符号, 本着最大限度兼容既有代码的规则, 这样的成员函数仍然可以从临时对象上调用.

当然话说回来, 这种代码毕竟也是极少数, 甚至上面那些极端的示例应该不会出现在生产项目中, 因此也不必太过担心这一规则兼容. 如果一定要针对各种不同的引用类型的成员函数重载, 那么应当用如下的方式编写代码

```cpp
struct MyClass {
    MyClass() {}

    // 在成员函数之后加上右值引用符号
    void print() &&     { std::cout << "rvalue" << std::endl; }

    // 为避免歧义, 成员函数如果有针对右值引用的重载, 在定义针对左值的重载时必须加上 & 符号
    // 对 const 限定的成员函数也一样
    void print() &      { std::cout << "non const lvalue" << std::endl; }
    void print() const& { std::cout << "const lvalue" << std::endl; }
};

int main()
{
    MyClass().print(); // 输出 : rvalue

    MyClass a;
    a.print();         // 输出 : non const lvalue

    MyClass const b;
    b.print();         // 输出 : const lvalue
    return 0;
}
```

以上就是右值引用和相应的重载决议机制加入后, 对现有体系的修正.

最后有一个小问题需要解释: 临时对象是否应该有 `const` 修饰, 换言之, 针对某个类型 `T` 是否应该有接受 `T const&&` 的重载, 以及是否应该有以 `const&&` 限制的成员函数呢? 答案为否. 通常情况下, 不应该为函数返回的对象还加上 `const` 限定, 因此也就不会实际产生 `T const&&` 类型; 而即使有这样的类型, 由于它带有了不可被修改的限制, 因此使用既有的引用类型 `T const&` 处理之, 效果也会一样.



## 左值引用与右值引用的相互转换

由于 C++ 中等号算符是可以重载的, 因此以等号赋值语法来讨论左右值不会有太大意义. 实际上 C++ 的左值概念更多的是基于是否可以取得对象地址, 并在这一地址空间上执行相应的行为来界定的. 并且, 它衍生出了被称之为 **同一性 (identity)** 的概念, 也就是*两个对象引用可以根据其地址是否相同而确定是否引用了同一个对象*.

而 C 和 C++ 均*禁止对临时对象使用取得地址算符* (前置单目 `&` 算符), 无法直接获取地址的表达式当然谈不上同一性, 在 C++11 中这些表达式被称作**纯右值 (pure rvalue)**. 字面常量, 对返回值类型定义为值类型的函数的调用, 各种运算 (包括所有原生对象的算术, 逻辑, 比较运算等), 以及对右值对象的成员, 还包括 lambda 表达式, 都属于纯右值.

同一性的特性还产生了一个 C++ 与 C 行为不一致的地方, 就是 C++ 中对空类型 (没有数据成员或虚函数, 若有父类, 其父类也必须全是空类型) 求 `sizeof` 得到的结果至少为 1, 而 C 中对空结构体求 `sizeof` 得到的是 0. 因此 C++ 可以确保两个对象的地址一定不同. (此外 C++ 中 `struct Empty {} x, y; ptrdiff_t m = &x - &y;` 这样的代码没问题, 但在 C 中会因除零错误而崩溃)

临时对象或字面量都是典型的右值. 而另一种右值则通过非 `const` 限定的左值对象转换而来, 它们被称作**临终值** (eXpiring value 或简写作 **xvalue**). 例如在上一节中提到的方法

```
int six = 6;
test_ref(static_cast<int&&>(six)); // 使用 static_cast 转换得到右值引用
```

当然用户不必每次需要将左值类型转换为临终值都写这么别扭的 `static_cast`, 在标准库中提供了一个函数包装, 它是 `std::move`. 上面的例子中的 `static_cast` 用 `std::move` 替换的等价实现会是这样的

```
int six = 6;
test_ref(std::move(six));
```

调用 `std::move`, 除了让编译器选择右值而不是左值引用的重载, 并没有其它的作用. 不过, 换一个重载在有些情况下大有其作用. 这些用况, 以及为何将左值表达式转换为右值引用的函数称作 `move`, 将在下一章移动语义中重点介绍.

反过来, 右值引用是否可以转化为左值引用呢? 当然可以, 而且不同的是, 甚至都不需要进行一次 `static_cast`. 在 C++11 中规定, 任何带有名字的引用, 这个名字构成的表达式都是一个左值引用, 因为它已经满足同一性的要求, 可以通过名字取得对象地址了 (虽然 C++ 标准没有规定临时对象具体存储在何处).

典型的情况是以函数参数的形式出现. 定义在栈上的局部变量如果是右值引用, 也会受这一规则制约. 例如

```cpp
void test_ref(int& m) { std::cout << "non-const " << m << std::endl; }
void test_ref(int const& m) { std::cout << "const " << m << std::endl; }
void test_ref(int&& m)  { std::cout << "rvalue " << m << std::endl; }

void proxy(int&& g)
{
    test_ref(g);
}

int main()
{
    int&& f = four();
    // 将右值引用传给 test_ref, 匹配的是左值引用重载
    test_ref(f);    // 输出 non-const 4

    // 将右值引用先传给 proxy, proxy 将右值引用形参传给 test_ref
    // 匹配的是左值引用
    proxy(four());  // 输出 non-const 4
    return 0;
}
```

也就是说无论是定义一个具名右值引用还是右值引用作为参数, 用它去调用函数实际匹配的重载都将是左值引用重载, 这是右值应用一个容易误用的特性.

如果需要将右值引用参数还原为一个右值, 则还需要再添加 `std::move` 调用. 如

```cpp
// ...

void proxy(int&& g)
{
    // 将参数 g 传给 std::move, 重新变为临终值
    test_ref(std::move(g));
}

int main()
{
    proxy(four());  // 输出 rvalue 4
    return 0;
}
```

因此在实际项目中*处理临时对象时, 应该立即使用之*, 而不建议在函数的栈中定义右值引用绑定临时对象, 更不应该将右值引用定义为对象成员.


## 广义引用与参数转发

在 C++11 中引入了右值引用来针对临时对象, 但是作为向前兼容, `const` 限定的左值引用仍然可以通配所有引用类型. 不过在新标准中还引入了一个特殊规则, 使得一些泛型引用类型的参数也可以适配任何参数. 这种参数类型被称为**广义引用 (universal reference)** 类型.

使用 `const` 限定的引用类型的缺点是, 无论实参是否为变量, 都因为加上了 `const` 限定而无法被修改了. 而引入广义引用要解决的问题, 就是保持各参数原有的状态.

### 广义引用

广义引用的基本规则是, 如果模板函数的某个参数为引用类型 `T&&`, 并且满足以下几个条件

* 类型 `T` 是这个函数的模板类型参数
* 类型参数没有被用户指定而是由编译器推导

那么此参数类型 `T&&` 是广义引用, 而不是一个右值引用类型.

广义引用类型的形参虽然语法上看起来像右值引用, 但它可以匹配任意类型的实参. 例如

```cpp
template <typename T>
void f(T&& t)   // 参数 T&& 中的 T 是模板函数 f 的模板类型参数
{
    std::cout << t << std::endl;
}

int main()
{
    f(0);       // 输出 0 : 可以匹配右值, 实际 T&& = int&&
    int x = 1;
    f(x);       // 输出 1 : 可以匹配左值, 实际 T&& = int&
    int const y = 2;
    f(y);       // 输出 2 : 可以匹配 const 左值, 实际 T&& = int const&
    return 0;
}
```

不得不说, 由于广义引用与右值引用的语法形式一样, 很容易就出现误解和误用. 比如以下两个很典型的例子, 其中出现的模板参数都**不是**广义引用, 因为它们违反了上述广义引用规则的第一条.

```cpp
template <typename T>
void g(std::vector<T>&& v);
//     ^^^^^^^^^^^^^^^^ 非广义引用而是右值引用; 因为参数类型是 std::vector<T>, 它不是模板类型参数 T

template <typename T>
struct X {
    template <typename U>
    void f(T&& t, U&& u);
    //     ^^^^^ T&& t 不是广义引用而是右值引用类型参数; 因为它不是函数的模板参数而是外层模板类的类型参数
    //           U&& u 是广义引用
};
```

而下面这个例子则演示了编译器是如何应用上述的第二条规则的

```cpp
template <typename T>
void f(T&& t) {} // 类型参数 T&& 定义上满足广义引用的条件

int main()
{
    int i = 0;

    f(i);        // 编译通过: 编译器认为 f 的参数是广义引用, 因此能够接受左值参数

    f<int>(i);   // 编译失败: 由于用户指定了 T = int, 因此编译器认为 f 的形参类型是 int&& 右值, 无法接受左值实参
                 // 即使函数在定义上满足广义引用的条件, 调用函数时也可能违反广义引用的条件
    return 0;
}
```

广义引用的一个直接应用就是在对参数没有具体类型要求的工具函数的场景. 比如用于将左值转换为临终值的 `std::move` 函数的参数就是一个广义引用. 其实现为

```cpp
// bits/move.h:99
template<typename _Tp>
typename std::remove_reference<_Tp>::type&& move(_Tp&& __t) // 此类型是泛型参数, 因此是一个广义引用
        noexcept // 这个简单的工具函数, 它不会抛出异常, 因此加上 noexcept 声明是有必要的
{
    // 使用 static_cast 将引用类型进行转换
    return static_cast<typename std::remove_reference<_Tp>::type&&>(__t);
}

// type_traits:1373
// remove_reference 可用于将任何引用类型还原成其值类型
// 因此 move 的返回值类型就会是 _Tp 类型参数去掉引用符号之后再加上右值引用
template<typename _Tp>
struct remove_reference
{
    typedef _Tp type;
};

template<typename _Tp>
struct remove_reference<_Tp&>
{
    typedef _Tp type;
};

template<typename _Tp>
struct remove_reference<_Tp&&>
{
    typedef _Tp type;
};
```

因此, 即使对一个右值使用了 `std::move` 也无妨, 其结果仍会被正确地当作一个右值对待.

### 引用折叠

在介绍广义引用基本语法时用了如下的例子

```cpp
template <typename T>
void f(T&& t) { std::cout << t << std::endl; }

int main()
{
                     f(0); // T&& = int&&      : 匹配右值引用
    int x = 1;       f(x); // T&& = int&       : 匹配左值引用
    int const y = 2; f(y); // T&& = int const& : 匹配 const 限定左值引用
    return 0;
}
```

这样写注解有一个细节问题, 就是当 `T&& = int&&` 成立时, 是否意味着 `T = int` 的特化; 以及 `T&& = int&` 时, 特化类型又是什么. 在这里解释一下广义引用匹配参数时, 具体的引用推导规则.

广义引用只可能匹配上述三个引用类型而不可能是值类型, 当广义引用匹配一个左值引用时, 推导出的类型实参为相应的左值引用类型; 而当广义引用类型匹配右值引用时, 推导出的类型实参则为相应的值类型, 即

```cpp
f(0);            // T&& = int&&      <=> T = int
int x = 1;
f(x);            // T&& = int&       <=> T = int&
int const y = 2;
f(y);            // T&& = int const& <=> T = int const&
```

反过来看上面结论的话, 就会发现, 当 `T = int` 时意味着, `T&& = int&&`, 这一点没问题, 但 `T = int&` 时, `T&& = int&`, 右值引用符号去哪里了呢?

这就是**引用折叠** (reference collapsing) 的效果. 在 C++ 中, 各种引用类型的叠加并不是做简单的数学运算, 用类型加上引用符号就得到相应的引用类型. 而引用类型相对于指针类型很大的一处不同也在于此: 存在指向指针的指针类型, 但不存在引用另一个引用的引用类型. 如

```cpp
typedef int* int_ptr;
int_ptr* x;           // x 的类型是 int**

typedef int& int_ref;
int_ref& y;           // y 的类型仍然是 int&
```

在这种情况下两个引用符号折叠在一起, 形成 `y` 的最终类型定义. 在 C++11 中加入了右值引用后, 引用折叠扩充成了以下三条规则

* 定义左值引用类型的右值引用, 结果是左值引用; 即 `T&  && => T&`
* 定义右值引用类型的左值引用, 结果是左值引用; 即 `T&& &  => T&`
* 定义右值引用类型的右值引用, 结果是右值引用; 即 `T&& && => T&&`

简而言之只有两个右值引用折叠在一起才会得出右值引用, 其他情况都会是左值引用. 写成代码示例就是

```cpp
#include <iostream>
#include <type_traits> // include is_lvalue_reference : 指出一个类型是否是左值引用
                       //         is_rvalue_reference : 指出一个类型是否是右值引用

int main()
{
    using int_lref = int&;
    using int_rref = int&&; // 使用 using 定义两种引用类型的别名, 然后对别名加上引用符号
                            // 可不能直接写 int& && 这样的类型

    // 输出 1 0 : 折叠为左值引用
    std::cout << std::is_lvalue_reference<int_lref&>::value << ' '
              << std::is_rvalue_reference<int_lref&>::value << std::endl;

    // 输出 1 0 : 折叠为左值引用, 附加上的右值引用符号失效
    std::cout << std::is_lvalue_reference<int_lref&&>::value << ' '
              << std::is_rvalue_reference<int_lref&&>::value << std::endl;

    // 输出 1 0 : 折叠为左值引用, 原有的右值引用符号失效
    std::cout << std::is_lvalue_reference<int_rref&>::value << ' '
              << std::is_rvalue_reference<int_rref&>::value << std::endl;

    // 输出 0 1 : 折叠为右值引用
    std::cout << std::is_lvalue_reference<int_rref&&>::value << ' '
              << std::is_rvalue_reference<int_rref&&>::value << std::endl;
    return 0;
}
```

### 完美转发

在 C++ 中一直有一个需要解决的问题就是让函数具备**完美转发** (perfect forwarding) 一些参数给其他函数的能力. 在设计上, 此功能可用于实现业务代码和非业务代码的分离. 比如

```cpp
// implements 是具体业务逻辑的实现函数
R implements(T const& t);

// 另实现一个包装函数, 包装函数中包含日志与统计
template <typename FuncType, typename ArgType>
auto wrapper(FuncType f, ArgType const& a) -> decltype(f(a))
{
    auto start = time();
    logging("Call implements start at %d", start);

    auto&& r = f(a); // 转发参数给业务逻辑函数

    auto end = time();
    logging("Call implements finished at %d", end);
    function_statistic("implements", end - start);
    return std::move(r);
}

int main()
{
    // 调用处可以这样使用 wrapper 与 implements
    R r = wrapper(implements, T());
    // ...
}
```

在上面的代码片段中, 负责业务逻辑的 `implements` 函数外围的日志和统计代码由 `wrapper` 函数管理. `wrapper` 虽然不会直接用到要向 `implements` 传递的参数, 但由于它要将参数传给 `implements`, 它仍需要一定程度上了解 `implements` 函数的签名.

比如在上面的例子里, 如果以后 `implements` 函数的参数变为非 `const` 的引用, 即声明改成了 `implements(T&)`, 那么 `wrapper` 函数的编译就会因为 `const` 修饰而问题. 或者反过来说, `wrapper` 函数只适合包装那些参数是 `const` 限定引用的函数.

那么, 是否存在更通用的引用参数 (暂且不考虑参数个数的问题) 声明, 使得无论被包装的函数的参数类型如何, 外层的包装函数都可以应对. 这就是参数完美转发要达到的目标.

在 C++11 之前这是无法做到的, 因为通配各种引用的是 `const` 限定引用, 这使得非 `const` 左值也被无故加上了无法修改的限制. 而在 C++11 中, 则可以通过广义应用来定义这样的包装函数.

```cpp
R implements(T const& t);

// 将参数 ArgType&& 的定义转换为广义引用
// 注意, FuncType 也被转换为了广义引用, 这样无论可调用对象实参是一般函数指针, 带有或不带有 const 的函数对象的引用都可适配之
template <typename FuncType, typename ArgType>
auto wrapper(FuncType&& f, ArgType&& a) -> decltype(f(a))
{
    // 调用开始前的工作

    auto&& r = implements(t);

    // 调用结束后的工作

    return std::move(r);
}
```

这样看起来很好. 然而事情不是这么简单, 因为前文中介绍过的具名右值引用的一个特性 --- 形参中的右值引用实际上表现为左值引用 --- 在广义引用的情况下也不例外. 所以看起来在 `wrapper` 传给 `implements` 的是广义引用, 而这些引用本应该保留它们原有的形式, 但实际上它们都会变成左值引用.

不妨来做个简单的实验.

```
#include <iostream>
#include <type_traits>

template <typename T, typename U>
int implements(T&& t, U&& u)
{
    std::cout << "at implements, t is l/r reference: "
              << std::is_lvalue_reference<decltype(t)>::value << ' '
              << std::is_rvalue_reference<decltype(t)>::value << std::endl;
    std::cout << "at implements, u is l/r reference: "
              << std::is_lvalue_reference<decltype(u)>::value << ' '
              << std::is_rvalue_reference<decltype(u)>::value << std::endl;
    return 0;
}

template <typename T, typename U>
int wrapper(T&& t, U&& u)
{
    std::cout << "at wrapper, t is l/r reference: "
              << std::is_lvalue_reference<decltype(t)>::value << ' '
              << std::is_rvalue_reference<decltype(t)>::value << std::endl;
    std::cout << "at wrapper, u is l/r reference: "
              << std::is_lvalue_reference<decltype(u)>::value << ' '
              << std::is_rvalue_reference<decltype(u)>::value << std::endl;
    return implements(t, u);
}

int main()
{
    std::unique_ptr<int> t;
    // 推导出 T 为左值, U 为右值的重载
    wrapper(t, std::unique_ptr<int>());

    /* 输出

    at wrapper, t is l/r reference: 1 0
    at wrapper, u is l/r reference: 0 1
    at implements, t is l/r reference: 1 0
    at implements, u is l/r reference: 1 0

    输出结束 */

    return 0;
}
```

从输出可以看到, 在 `wrapper` 函数里得到的参数类型还是预期的一个左值一个右值, 但是转发到 `implements` 函数里, 就全部成了左值. 这并不是用户希望的行为.

解决这个问题可以借鉴 `move` 的做法, 可以进行 `static_cast` 进行转换. 不过, 由于在 `wrapper` 函数中并不关心传入并转发给 `implements` 函数的 `T` `U` 等引用类型具体是什么, 故针对不同引用类型的 `static_cast` 的结构应该尽可能相似. 其实现方式可能类似这样

```
template <typename T, typename U>
int wrapper(T&& t, U&& u)
{
    std::cout << "at wrapper, t is l/r reference: "
              << std::is_lvalue_reference<decltype(t)>::value << ' '
              << std::is_rvalue_reference<decltype(t)>::value << std::endl;
    std::cout << "at wrapper, u is l/r reference: "
              << std::is_lvalue_reference<decltype(u)>::value << ' '
              << std::is_rvalue_reference<decltype(u)>::value << std::endl;
    return implements(static_cast<T&&>(t), static_cast<U&&>(u));
    //                ^^^^^^^^^^^^^^^^     ^^^^^^^^^^^^^^^^
}
```

为什么是这样的 `static_cast` 呢? 对于 `T = unique_ptr<int>&` 来说, 在它上面附加右值引用符号, 仍然会折叠到 `T&& = unique_ptr<int>&` 左值引用类型, 所以参数 `t` 上附加的 `static_cast` 其实什么都没做; 而对于 `U = unique_ptr<int>` 值类型来说, `U&&` 就是右值引用类型, 那么这次 `static_cast` 等价于对参数 `u` 进行了一次 `move`, 让它还原成了右值引用类型.

当然, 标准库中也提供了转发工具函数, 使得用户不必在代码中写上一堆 `static_cast`. 这个工具函数 `forward` 的声明如下

```
// bits/move.h:74
// 接受左值引用的重载
// 如果按照以上的做法, 只转发广义引用参数, 这一个重载就够了, 因为所有的具名引用都被认为是左值
template<class _Tp>
_Tp&& forward(typename std::remove_reference<_Tp>::type& __t) noexcept; // 与 move 一样不会抛出异常

// :85
// 针对纯右值的重载, 实际几乎用不到, 因为纯右值直接写在实参列表中即可
template<class _Tp>
_Tp&& forward(typename std::remove_reference<_Tp>::type&& __t) noexcept;
```

由于 `forward` 参数列表中使用 `remove_reference` 对模板参数类型 `T` 进行了一些转换, 因此不能直接写 `forward(u)` 来让编译器推导模板参数类型, 需要用户手动加上, 如

```
template <typename T, typename U>
int wrapper(T&& t, U&& u)
{
    // ...

    return implements(std::forward<T>(t), std::forward<U>(u));
    //                ^^^^^^^^^^^^^^^     ^^^^^^^^^^^^^^^
}
```

两次 `forward` 调用的类型特化, 详细解释如下

| `_Tp` | 返回值类型 `_Tp&&` | 参数类型 `std::remove_reference<_Tp>::type&`
| `T = unique_ptr<int>&` | `unique_ptr<int>&` 左值 | `unique_ptr<int>&`
| `U = unique_ptr<int>` | `unique_ptr<int>&&` 右值 | `unique_ptr<int>&`

可以看出, `forward` 是转发不同引用类型的有力工具. 在 "可变参数模板" 一章中将提到, `forward` 结合可变参数模板函数, 还能实现转发任意多个参数的功能.


# 移动语义
本章内容将包含 C++ 中一些非常重要的更新, 它们是移动语义及与之有关的一系列语言语义改造.

C++ 语言中长期以来有个令人困惑的特性: 对象复制构造. 在第一章中简单提到过, 无论什么类型的实例, 默认都是可复制的. 而如果不希望其具有复制的能力, 却反而需要额外编写一些代码.

在这一章中将详细说明这一特性的历史原因, 造成的问题以及在 C++11 中的改进方案. 这些改动造就了更完备的 C++ 语言.



## 对象声明周期语义

### 由历史原因造成的 C++ 基本特性

C++ 最早被作为一门 C with classes 语言被发明出来. 不得不说这一第一印象也成为了对 C++ 最为广泛接受的刻板的印象. 然而在超过 30 年的发展之后, C++ 这门语言有着繁多的语言特性, 是 C 语言无法企及的, 而兼容 C 语言, 也只是 C++ 众多语言特性中的一个部分.

在兼容 C 语言这个部分, C++ 可以利用几乎所有 C 语言的 API, 包括一些操作系统 API. 在其他高级语言中, 调用 C API 可能需要编译封装, 或打包成库, 或以虚拟机接口的形式才能供用户所使用, 而 C++ 代码中却可以几乎没有任何代价地直接调用, 对于开发者而言显然是重大利好. 然而这样做有一些也有一些不妥之处, 最终导致了 C++ 复制构造的产生.

为了实现与 C API 的兼容, *C++ 必须使用与 C 语言一致的栈式空间布局模型*, 即*栈式对象模型*. 这一点与其他许多高级语言不一样. 将对象分配在栈空间内的好处是对其成员的使用皆可以编译为从栈基指针偏移寻址, 执行效率会非常高. 比如以下定义

```cpp
struct Person {
    char name[16];
    int age;
};

int main()
{
    Person p; // 如果认为函数栈空间内定义的第一个对象的地址就是栈基址
    p.name;   // 那么引用 name 属性地址就相当于引用栈基指针
    p.age;    // 引用 age 属性相当于从栈基指针偏移 16 字节
              // 这些偏移量都可以静态给出, 因此执行效率会很高.

    // ...
}
```

当然, 优点往往会伴有缺点, 对于栈式对象模型也不例外: *其不足之处就是光凭栈内静态空间难以处理动态长度的数据*, 譬如, 若须将 `Person` 的 `name` 属性设定为可动态扩展长度的字符串, 则这一段数据所需的地址空间就需要从堆上分配, 而在 C 语言中很麻烦的是, 用户还需要在使用完毕后手动归还这些堆空间.

但若是编写 C++ 程序, 则有更好的方案. 作为个例, 这里使用标准模板库中的 `std::string` 定义 `Person` 的 `name` 属性就能很容易地处理变长字符串. 之所以 `string` 具有这样的能力, 正是其内部管理了一份在堆空间中的动态资源所致. 当空间不够时, `string` 对象可以扩展其持有的空间. 然而, 与 C 中需要用户手动管理资源不同, `string` 将资源归还的行为进行了封装, 对用户而言是透明的, 比如, 在栈区定义一个 `Person` 对象, 会让函数返回后自动执行一些额外的操作

```cpp
struct Person {
    std::string name;
    int age;
};

int main()
{
    Person p;
    std::cin >> p.name;
    // ...
    return 0;
    // 函数结束, 清理在栈上的对象 p:
    //     p.name 持有的资源被自动释放
    //     p.age 是个整数, 不用清理
}
```

这个规则当然不仅仅只被 `string` 所用, 更一般地, 在 C++ 中用于自动处理资源释放语言特性被称之为 "资源获取时初始化" (Resource Acquisition Is Initialization, 缩写为 RAII). 光看这个名字, 并不能很好地在字面上解释其背后的语言特性, 若要完整地说, 之后还应包含半句 "*对象析构时将资源释放*". 换言之, 在 C++ 中, 对于那些持有资源 (堆空间, 文件句柄等) 的对象, 编译器生成的代码将保证这些**对象所持有的资源的有效期与该对象的生命期严格一致**, 并且在对象生命周期结束时使用指定的方法自动归还这些资源.

具体的做法是用户按照以下规则编写代码

* 在对象的构造函数或生命周期过程中获取资源
* 在对象的析构函数中释放资源

然后编译器保证生成的应用程序有以下运行时行为

* 对象生命周期结束后其析构函数一定被调用

在这样的保障下, 对象所控制的资源的自动释放机制得以实现. 这是 C++ 之于 C 语言的本质不同, 甚至是 C++ 相对于其他编程语言的一个独有的性质^[[只有 C++, D, Rust 等屈指可数的几个流行语言支持 RAII]], 使得这门没有动态内存回收机制在某些情况下在资源自动回收方面比其它语言表现得更好.

= 对象及资源复制机制

在 C 中, 当一个函数的返回值定义为结构体时, 调用这个函数获得该结构体实例, 其行为是将这个实例的所有数据复制一份: 从被调用函数的栈区复制到调用者栈区. 譬如以下代码示例

```
struct Person {
    char name[16];               // 栈区
    int age;                     // .-------------------.
};                               // |      main()       |
                                 // |                   |
Person read_person()             // | person q -------. |
{                                // | . name:char[16] |<---.
    Person p;                    // | | age:int       | |  |  函数返回时
    fgets(p.name, 16, stdin);    // | |_______________| |  |  整个 Person 对象会被复制
    scanf("%d", &p.age);         // |                   |  |  包括 16 字节的 char 数组
    return p;                    // |-------------------|  |  和一个 int
}                                // |   read_person()   |  |
                                 // |                   |  |
int main()                       // | person q -------. |  |
{                                // | . name:char[16] |----'
    Person q(read_person());     // | | age:int       | |
    // ...                       // | |_______________| |
    return 0;                    // |                   |
}
```

在 `main` 函数中调用了 `read_person` 后, 很有可能这个对象是从 `read_person` 函数中定义的 `p` 中复制数据而产生 `q`.^[[聪明的编译器会优化规避类似这样的复制, 这种优化称之为 "返回值优化" 或简称为 RVO (**R**eturn **V**alue **O**ptimization), 但在一些复杂的情况下编译器可能不会贸然进行此类优化]] 对于以上定义的纯粹静态对象而言, 问题不大, 除了程序可能会因为大量的复制行为而变慢.

但如果 `Person` 的定义中包含携带资源的对象呢?

```
struct Person {
    std::string name;
    int age;
};

Person read_person()
{
    Person p;
    std::cin >> p.name;
    std::cin >> p.age;
    return p;
}

int main()
{
    // C++ 亦会将被调用函数栈区内的 p 的数据复制到调用者栈区内的 q 中去
    Person q(read_person());
    // ...
    return 0;
}
```

由于 `Person` 对象会包含一个 `std::string` 对象, 如前所述, 作为控制资源 (堆空间中分配的字符串内容) 的对象, 其生命周期结束之后其持有的资源就失效了, 那么在 `read_person` 函数结束的时候, `p.name` 所包含的资源就被归还了, 那么其包含的 `name` 属性内容如何传递给调用者栈区的 `q.name` 中去呢?

首先, 显然不可能等到 `p.name` 析构结束后再从 `p.name` 中复制出 `q.name`, 因为 `p.name` 析构后其持有的资源已经失效, 不可作为复制的来源. 因此这时必然是先复制构造出 `q.name`, 然后再析构掉 `p.name`. 换言之, `p.name` 与 `q.name` 的生命周期会有一点重叠.

然后, 也是更重要的一点, `name` 这个属性是如何复制的? 在解答这个问题时 C++ 引入了有争议性的一个特性: 对象复制构造. 即由用户指定一个资源持有对象的复制行为, 称之为**复制构造函数**, 像 `std::string` 这样的类型, 它的复制构造函数行为被指定为

* 复制目标先分配与复制来源至少一样大的堆空间
* 将构造来源的堆空间上的内容复制到构造目标相应的堆空间上

换言之, 在 `p` 和 `q` 生命周期重叠的这么看似不起眼的一段时间内, 会发生很多事情, 包括新资源分配, 数据复制.

然而这种行为显然是不合理的, 有点像朋友找我借一本书, 我就把这本书带到复印店复印一整本给他, 然后烧了自己手头上这本. 对于字符串这样可以复制的资源来说虽有些蠢但至少还能复制得出副本; 但对于文件句柄, 线程锁, 或者遵守质能守恒的宇宙而言复制是不应发生的. 但是回头看一下这个特性的由来, 又会发现它本是为了兼容 C 在这一情况下的行为, 并且衍生出适用于 C++ 的至少更加安全的资源复制行为.

而不得不说这一兼容的代价是惨重的. 然而实际上, 这些复制行为是 C++ 的日常. 直到 C++11 标准出台.

在上一个标准 C++03 制定之后的 8 年时间里, 修正以上这种无意义的复制行为的补救措施逐步形成文案并被加入了新标准中, 最终形成了 C++11 标准中一个重要的更新: **移动语义** (move semantic). 简而言之, 移动语义允许一份资源从一个对象中**移动**到另一个对象中去, 使得资源可以在不同对象中以较低的运行开销交接, 扩展该资源的有效期.