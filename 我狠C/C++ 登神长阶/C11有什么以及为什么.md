# 语言与语法功能改进


## 空指针

### 为什么

 C 和 C++ 中在处理空指针的时候却并没有起到表率作用. 用户一般会用 `NULL` 来表示空指针, 但它并不是关键字, 而是一个宏. 在 C 中它通常被定义为 `(void*)0`, 而 C++ 中因为禁止 `void*` 指针类型向其他指针类型隐式转换, 因此在既有的编译器实现中它通常被定义为整数字面量 0, 或是其它不那么明确的指针常量.

这是个很容易让编译器产生误解的规则. 比如在 C++ 中以 `NULL` 作为实参时, 可能使得重载决议出错

```cpp
void f(int x) { std::cout << "overload int" << std::endl; }
void f(int* p) { std::cout << "overload int ptr" << std::endl; }

f(NULL); // NULL 被定义为 0 时输出 "overload int", 而另一些实现会报重载决议错误
         // 而不会直接决议为对 f(int*) 的调用
```

### 有什么
在 C++11 中引入新的空指针**关键字** `nullptr` 来解决这一问题. 不过, 考虑到向前兼容性, `NULL` 宏的定义并没有被直接改成这一关键字, 要使用它的话必须写上 `nullptr` 这一名字. 如, 修改上面的代码为

```cpp
f(nullptr); // 输出为 overload int ptr
```

`nullptr` 不仅仅可以表示空指针的值, 它还有一个独立的类型 `std::nullptr_t`. 当然这一类型的所有实例都相同, 即都是空指针.

空指针类型并不很常用. 它允许引入针对空指针类型的重载. 如

```cpp
void f(int* p) { std::cout << "overload int ptr" << std::endl; }
void f(std::nullptr_t) { std::cout << "overload nullptr" << std::endl; }

int main()
{
    f(nullptr);       // 输出 overload nullptr

    int* p = nullptr; // 虽然 p 是空指针, 但其类型是 int*
    f(p);             // 输出 overload int ptr

    // 可以使用 nullptr_t 定义对象实例, 这些实例都是空指针
    std::nullptr_t q;
    f(q); // 输出 overload nullptr
    return 0;
}
```


## 禁止赋值构造


### 为什么
C++ 受到诟病的一点是每个类型都会有一个复制构造函数, 即使用户不编写之, 编译器也会合成一个. 而某些类型, 比如文件流 `fstream` 又是不可复制的. 在既有标准中, 用户想到各种方法来应对这一编译器 "特性", 典型的做法是将复制构造函数声明为 `private` 访问限制的, 且只声明而不实现它. 如

```cpp
struct NonCopyable {
    NonCopyable() {}
private:
    NonCopyable(NonCopyable const&); // 声明为 private, 没有实现
};

int main()
{
    NonCopyable n;
    NonCopyable m(n);                // 编译错误
    return 0;
}

// 报错信息为: 此类型的复制构造函数为私有
// error: ‘NonCopyable::NonCopyable(const NonCopyable&)’ is private
```

这种封印的手法的问题一是报错词不达意, 二是偶尔在类的内部出现误用时 (类的内部可是能够使用 `private` 复制构造函数的), 它将导致链接错误而非编译错误, 而链接错误往往又是无法看到源代码行号的.


### 有什么
C++11 标准中打算收拾掉这一乱象, 给出一个简单的方案让用户可以明显地指出某个函数不需要了. 如

```cpp
struct NonCopyable {
    NonCopyable() {}
    NonCopyable(NonCopyable const&) = delete;
};

NonCopyable n;
NonCopyable m(n); // 编译失败, 报错为复制构造函数被删除了
                  // use of deleted function ‘NonCopyable::NonCopyable(const NonCopyable&)’
```

也就是在需要删除的函数后加上一个小尾巴 `= delete`, 这样此类型就无法复制构造了. 当然这只是在语法上限制了复制行为, 有关无法复制的类型更详细的特性, 本书将在 "移动语义" 一章将进行讨论.

这一机制除了可以用来禁止合成复制构造函数之外还可以用来取消掉由基类继承而来的函数, 或防止类型转化重载, 如

```cpp
struct Base {
    void print()
    {
        std::cout << "Base" << std::endl;
    }
};

struct Inherit: Base {
    // 在子类中声明父类中出现过的 print() 函数
    // 并标记为 delete, 那么无法从子类对象调用此函数
    void print() = delete;
};

void f(int x) {}
void f(char ch) = delete; // 标记 char 为参数的重载为 delete

int main()
{
    Base b;
    b.print();
    Inherit i;
    i.print();  // 编译错误: print 在子类中被标记为 delete 了

    f(10);      // 正确: 匹配参数为 int 的重载
    f('c');     // 编译错误: 匹配为参数为 char, 但被删除掉的重载
                // 如果没有 f(char) 的声明, 参数将被扩宽为 int 匹配 f(int) 的重载
    return 0;
}
```


## 即写即用都函数定义


C++11 新增的较为复杂的一个新语法就是 lambda 函数对象. 在本节中将简单介绍如何使用基本的 lambda 语法替代一般函数.

### 为什么
在标准库中提供了许多便利的算法函数, 这些算法函数允许用户传入指定的函数作为算法的策略. 比如最常用的算法函数之一的 `std::sort`, 它允许用户传入一个比较器, 表示如何比较两个对象以决定它们的顺序. 例如

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

struct Person {
    int age;
    std::string name;

    Person(int a, std::string const& n)
        : age(a)
        , name(n)
    {}
};

// 根据两个属性分别排序的函数
bool cmp_by_age(Person const& lhs, Person const& rhs)
{
    return lhs.age < rhs.age;
}

bool cmp_by_name(Person const& lhs, Person const& rhs)
{
    return lhs.name < rhs.name;
}

int main()
{
    std::vector<Person> p{
        {24, "lisi"},
        {23, "zhangsan"},
        {25, "wangwu"},
    };
    std::sort(p.begin(), p.end(), cmp_by_age);
    for (auto const& x: p) {
        std::cout << x.name << " : " << x.age << std::endl;
    }
    /* 输出
    zhangsan : 23
    lisi : 24
    wangwu : 25
    */

    std::sort(p.begin(), p.end(), cmp_by_name);
    for (auto const& x: p) {
        std::cout << x.name << " : " << x.age << std::endl;
    }
    /* 输出
    lisi : 24
    wangwu : 25
    zhangsan : 23
    */
    return 0;
}
```

虽然这样可以实现功能, 但显然, 将 `cmp_by_age` 对 `cmp_by_name` 分离为单独的函数*违背了函数的本意* --- 之所以分离出单独定义的函数是为了代码重用和逻辑封装. 而在本例中, 对象的比较方法作为排序逻辑的一环, 本应在 `sort` 的调用处, *单独定义成全局函数反而割裂了代码逻辑.*

再试想实现下面这一逻辑: 在容器中找到第一个 `age` 小于 20 的对象, 如果使用标准库中的 `find_if`, 应写为

```cpp
bool age_less_than_20(Person const& p)
{
    return p.age < 20;
}

// ...
std::vector<int> p;
// ...
auto i = std::find_if(p.begin(), p.end(), age_less_than_20);
if (i != p.end()) {
    std::cout << i->name << " : " << i->age << std::endl;
}
```

然而想必不会有人这么死脑筋, 相对于下面这样的 for 循环, 上面的写法实在是太繁琐了可以认为这是标准库的用户心中的算计和权衡: 像 `sort`, `set_intersection` 这样的算法函数, 即使需要在其他地方定义冗长的函数也无妨, 因为这些算法本身更复杂; 而像 `find_if`, `count_if` 甚至如 `for_each` 这样的函数则不然, 通常情况下, 一个 for 循环足以替代相应的功能

```
for (auto const& x: p) {
    if (x.age < 20) {
        std::cout << x.name << " : " << x.age << std::endl;
        break;
    }
}
```

### 有什么
而在 C++11 中, 用户可以用 lambda 匿名函数这一更简洁的方式来编写并使用这个函数指针, 下面就用这种方法改写上面的例子
```cpp
int main()
{
    std::vector<Person> p{
        {24, "lisi"},
        {23, "zhangsan",
        {25, "wangwu"},
    };

    // 使用匿名函数作为 sort 的比较器参数
    // 这是一个函数, 它以一对方括号开头, 之后是参数列表, 然后是花括号括起的函数体
    // 但它没有名字, 故被称作匿名函数
    std::sort(p.begin(), p.end(),
            /* 从这里开始 */
            [](Person const& lhs, Person const& rhs) // (a)
            {
                return lhs.age < rhs.age;
            }
            /* 到这里结束 */
    );
    for (auto const& x: p) {
        std::cout << x.name << " : " << x.age << std::endl;
    }
    /* 输出

    zhangsan : 23
    lisi : 24
    wangwu : 25

    */

    std::sort(p.begin(), p.end(),
            [](Person const& lhs, Person const& rhs) // (b)
            {
                return lhs.name < rhs.name;
            }
    );
    for (auto const& x: p) {
        std::cout << x.name << " : " << x.age << std::endl;
    }
    /* 输出

    lisi : 24
    wangwu : 25
    zhangsan : 23

    */

    // 类似地, 也可以使用匿名函数作为 find_if 的筛选条件参数
    auto i = std::find_if(p.begin(), p.end(),
            [](Person const& x)                      // (c)
            {
                return x.age < 20;
            }
    );
    if (i == p.end()) {
        std::cout << "no such person" << std::endl;
    }
    /* 输出

    no such person

    */

    p.push_back(Person(16, "xiaoliu"));

    auto j = std::find_if(p.begin(), p.end(),
            [](Person const& x)                      // (d)
            {
                return x.age < 20;
            }
    );
    if (j != p.end()) {
        std::cout << j->name << " : " << j->age << std::endl;
    }
    /* 输出

    xiaoliu : 16

    */

    return 0;
}
```

(a) (b) (c) (d) 各处就是这一新语法. 


## 禁止继承或覆盖

### 为什么
另一可能的需求是防止类型被继承, 在 C++03 中的技巧是将构造函数定义为 `private` 限定, 这样子类无法构造父类部分. 而后对外暴露工厂函数以产生对象. 如

```cpp
struct DontInherit {
    // 对外暴露工厂方法产生实例
    static DontInherit construct()
    {
        return DontInherit();
    }
private:
    // 将自身构造函数设为私有的
    DontInherit() {}
};

struct SubClass: DontInherit {
    // 在子类中, 这一无参默认构造函数将不会被隐式生成
    // 手动加上此构造函数也无法编译
    // SubClass() : DontInherit() {}
};

int main()
{
    // DontInherit 的实例化要借助于工厂方法
    DontInherit d = DontInherit::construct();

    // 但子类将无法实例化, 此处编译失败
    SubClass s;
    return 0;
}
```

### 有什么
在 C++11 中, 不允许类型被继承这一特性直接被编译器所支持, 新引入的关键字为 `final`, 与 Java, C# 等语言中的基本一致 (除了关键字摆放的位置). 它除了*可以禁止类型被继承, 也能禁止单一虚函数被覆盖*. 其语法如下

```cpp
struct Animal {
    virtual void say() = 0;
    virtual void breed() = 0;
    virtual ~Animal() {}
};

struct Bird : Animal {
    // 1.在虚函数后加上 final 关键字, 该虚函数无法被子类覆盖
    void breed() final { std::cout << "lay eggs" << std::endl; }
};

// 2.在类名后加上 final 关键字, 该类无法被继承
struct Duck final : Bird {
    void say() { std::cout << "ga" << std::endl; }

    // 编译错误: 基类的 breed 是 final 的
    void breed() {}
};

// 编译错误: Duck 是 final 的
struct DonaldDuck : Duck {};
```

这一特性*有助于编译器执行优化*. 若子类将其某个虚函数标记为 `final` 修饰, 或者该子类本身是 `final` 修饰的, 那么这些成员函数的调用将被编译器视为非虚函数调用, 这样就不必在运行时去查找虚表了.

除了 `final` 关键字之外, 另一与虚函数有关的关键字 `override` 可以用来确定当前定义的函数是否覆盖了父类的虚函数. 这一关键字不是必须的, *加上的话有助于检查虚函数签名的正确性*.

```cpp
struct Animal {
    virtual void say() = 0;
    virtual void breed() = 0;
    virtual ~Animal() {}

    void drink() {}
};

struct Bird : Animal {
    // 正确: 此函数覆盖了父类中声明的 void breed() 函数
    void breed() override { std::cout << "lay eggs" << std::endl; }

    // 编译错误: 此函数签名与父类中的 breed 函数不同, 多了 int 参数
    void breed(int x) override
    { std::cout << "lay " << x << " eggs" << std::endl; }

    // 编译错误: 此函数签名与父类中的 breed 函数不同, 多了 const 限定
    void breed() const override
    { std::cout << "lay eggs" << std::endl; }

    // 编译错误: 父类中的 drink() 函数并不是虚函数
    void drink() override {}
};
```

## 编译时断言

在 C++03 标准中, 另一由于没有编译器支持而实现得很繁琐的简单需求是编译时断言, 在 C++11 中则直接将关键字 `static_assert` (C 语言中为 `_Static_assert`) 加入语言本身, 由编译器来检查某个编译时条件是否满足. 其语法如下

```cpp
// 在编译时常量 BOOL_CONSTANT 为 false 时给出一个编译错误, 错误信息为 ERROR_MESSAGE
static_assert(BOOL_CONSTANT, ERROR_MESSAGE);

// 例
static_assert(true, "this is ok");
static_assert(false, "cause a compile error"); // 此行会产生编译错误
static_assert(sizeof(int) == 4, "int is not 4 bytes");
```


## 函数无异常声明
### 为什么
C++03 中, 在函数签名中可以增加一个 `throw(except_a, except_b, /* ... */)` 的抛出声明, 表示函数*只会*抛出这些异常类型, 而一个空的 `throw()` 表示函数*不会*抛出异常. 如

```cpp
void f() throw(std::runtime_error); // f 可能抛出 std::runtime_error, 不可能抛出其他类型异常
void g() throw();                   // g 不会抛出任何异常
```


### 有什么
而 C++11 中新增了关键字 `noexcept`, 其功能之一是*将上述抛出声明简化为二元形式, 即可能抛出, 或不可能抛出*. 其语法形式是在函数签名最后加上 `noexcept(bool 常量)`, 该参数 `bool` 常量表示此函数是否不会抛出异常, 这一常量默认为 `true` (但如果根本不写 `noexcept` 的话, 表示该函数可以抛出异常).

```cpp
void f() noexcept(true);     // f 不会抛出异常
void g(int) noexcept(false); // g 可能抛出异常
void h() noexcept            // h 不会抛出异常; 这时不需要圆括号
void k();                    // 什么也不写: k 可能抛出异常
```

*声明一个函数不会抛出异常有利于编译器生成更简单的可执行文件*. 但如果一个带有 `noexcept(true)` 声明的函数中直接或间接抛出了异常, `std::terminate` 会*被立即调用*, 默认情况下意味着进程将马上结束.

该关键字的另一作用是*在编译时评估一个函数调用是否会抛出异常*, 并返回一个 `bool` 值常量. 这个函数表达式只在编译时使用, 不会被运行求值, 类似 `sizeof` 一样.

```cpp
// 沿用上面的定义
std::cout << noexcept(f()) << std::endl;  // 1
std::cout << noexcept(g(0)) << std::endl; // 0
```

将这两者结合起来, 可以实现一个需求: 如果函数 X 中只调用了函数 Y, 那么函数 X 是否抛出异常取决于 Y 是否抛出异常. 写成代码是这样的

```cpp
void f() noexcept;

void g() noexcept(noexcept(f()))
//                ^^^^^^^^^^^^^  f 不会抛出异常, 故此表达式为 true
//       noexcept(    true     ) 因此这里等价于声明此函数不抛出异常
{
    f();
}

template <typename T>            // 泛型中的运用
void h() noexcept(noexcept(T())) // h 函数是否抛出异常取决于 T 类型构造时产生异常
{ /* ... */ }
```

这是一个美好的愿景, 但在实际运用时, 如果要将一个函数所有调用的其他函数都写进 `noexcept` 声明中的话, 推广这一声明是极其困难甚至不可能完成的. 最坏的情况下甚至可能在 `noexcept` 里的部分相当于把整个函数重新实现一遍.

因此, 实际上只有一些很简单的函数才会加上这一声明. 另外, *析构函数默认都带有* `noexcept(true)` 声明.

需要注意的是, 使用 `noexcept(true)` 以及 `throw()` 声明*都不会强制编译器检查函数是否真的不会抛出异常*, 比如以下代码

```cpp
void f(int x) noexcept
{
    if (x < 0) {
        throw std::out_of_range("");
    }
}
```

虽然在函数体中很明确地有一句 `throw`, 但是编译器并不会在处理这段代码时报错.

## 基于范围的循环

### 为什么

在 C 和 C++ 里有两类循环语句, 一是 `while` 或 `do`-`while`, 另一是 `for` 循环. 相对于 `while` 系的按单一条件循环的语法, `for` 的不同之处在于多出了*迭代初始化*和*迭代变更*两个成分. 如

```cpp
size_t const SZ = 10;
int arry[SZ];
for (size_t i = 0; i < SZ; ++i) {
    arry[i] = i * 2 + 1;
}

// 等价于以下 while 循环

size_t j = 0;
while (j < SZ) {
    arry[j] = j * 2 + 1;
    ++j;
}
```

由于开发者之间对循环的功能达成了共识, 上述 `for` 循环一眼就能看出来是在逐个访问数组的每个元素, 因此相对于使用 `while`, `for` 循环在语义上更为明确, 容易理解.

不过, 在 C++ 中由于标准容器的引入, 这种 `for` 循环会*由于一些容器类型无法按照索引下标随机访问而无法使用*.  因此标准库中设立了迭代器 (iterator) 的机制来帮助用户遍历任何容器中的元素. 如

```cpp
std::set<int> s;

for (size_t i = 0; i < s.size(); ++i) {
    // 编译错误: std::set 集合类型不具备按照下标随机访问的能力
    int val = s[i];
}

for (std::set<int>::iterator i = s.begin(); i != s.end(); ++i) {
    // 正确: 通过迭代器访问元素
    int val = *i;
    std::cout << val << std::endl;
}
```


### 有什么
相对而言这种写法还是容易接受的. 不过, C++11 中又设计了一个新语法, 让针对容器迭代语义进一步简化. 这种基于范围的循环 (range-based loop) 语法如下

```cpp
std::set<int> s;

// 在 for 关键字的括号中使用
// 类型名 标识符 冒号 (:) 要进行迭代的容器 (任何表达式)
// 这一写法与上面传统的 for 循环写法完全等价
for (int val: s) {
    std::cout << val << std::endl;
}
```

编译器处理这一语法的机制实际上就是调用给定的容器表达式的 `begin()` 和 `end()` 函数产生迭代器对象, 然后调用迭代器对象的寻址算符重载 (前置 `operator*()` 重载) 获得相应的元素, 赋值给 `for` 的括号里定义的标识符.

如果提供容器的表达式是个函数调用, 这个调用只会被执行一次. 换言之, 这个表达式只会在循环开始前被求值一次.

```cpp
std::vector<std::string> make_vector()
{
    std::cout << "call make_vector" << std::endl;
    std::vector<std::string> x;
    x.push_back("hello");
    x.push_back("world");
    return x;
}

for (std::string s: make_vector()) {
    std::cout << "s= " << s << std::endl;
}

// 等价于以下代码, make_vector() 函数调用只有一次
std::vector<std::string> __ranged_for_loop_expr(make_vector());
for (std::vector<std::string>::iterator i = __ranged_for_loop_expr.begin();
     i != __ranged_for_loop_expr.end();
     ++i)
{
    std::string s = *i;
    // ...
}

/* 输出

call make_vector
s= hello
s= world

*/
```

另外, 像上面这样写, 每次迭代返回的 `std::string` 对象都会被复制到循环中定义的 `s` 变量里去, 这当然有些性能损耗. 在不需要复制的情况下, 可以将这一变量定义为引用.

```cpp
// 以引用的方式使用迭代的元素
for (std::string const& s: make_vector()) {
    std::cout << "s= " << s << std::endl;
}

// 也可以去掉引用的 const 限制; 这样的话, 循环体中更改引用意味着直接修改了容器内元素的内容
std::vector<std::string> v(make_vector());
for (std::string& s: v) {
    s += " !";
}

for (std::string const& s: v) {
    std::cout << "s= " << s << std::endl;
}

/* 更改了元素之后, 以上一个 for 循环的输出为

s= hello !
s= world !

*/
```

然而, 这一方便的新特性并*没有顾及到逆向迭代*, 也就是说无法通过逆向迭代器 (reverse iterator) 对容器内容进行循环. 不过, 可以在需要的时候加上这样一套工具类型 (需要用户自己添加; STL 中直到 C++17 都没有提供)

``` cpp
template <typename C>
struct reverse_iteration {
    C& c;
    reverse_iteration(C& c_): c(c_) {}

    // 其 begin end 函数返回所引用的容器的 rbegin() rend() 以产生逆向迭代器
    typename C::reverse_iterator begin() { return c.rbegin(); }
    typename C::reverse_iterator end() { return c.rend(); }
};

template <typename C>
struct reverse_iteration<C const> { // 针对 const 限定的偏特化
    C const& c;
    reverse_iteration(C const& c_): c(c_) {}

    // 此偏特化使用 const_reverse_iterator
    typename C::const_reverse_iterator begin() { return c.rbegin(); }
    typename C::const_reverse_iterator end() { return c.rend(); }
};

template <typename C>
reverse_iteration<C> make_reverse(C& c)
{
    return reverse_iteration<C>(c);
}

std::vector<std::string> v(make_vector());
for (std::string const& s: make_reverse(v)) {
    std::cout << "s= " << s << std::endl;
}

/* 输出

call make_vector
s= world
s= hello

*/
```

从这个例子中也可以看出, 如果用户自己实现了一个容器类型, 或者哪怕是上述这样的包装类型, 只要有合适的 `begin()` 和 `end()` 成员函数实现, 就能用在基于范围的循环语法中.


## 嵌套模板结束符号


在 C++ 中, 若使用一个模板类型的特化作为另一个模板的类型参数, 连续两个模板的结束符号 `>` 会合在一起变为右移算符 `>>`, 如

```cpp
std::vector<std::pair<int, int>> x;
//                            ^^
std::vector<std::pair<int, std::set<std::string>>> y;
//                                             ^^^ 还可能出现无符号右移算符
```

在 C++03 中这种写法是不允许的, 模板结束处的连续尖括号之间必须加上空格. 而 C++11 标准则允许这样写, 即上述代码可以被支持 C++11 的编译器正确解析. 不过此改动也不是完美的, 这一规则加入后一些原来可以编译通过的代码反而会出错. 如

```cpp
template <int I>
struct A {};

// 使用右移运算表达式特化接受整型参数的模板
// C++03 中可以编译通过, C++11 中报错
A<3 >> 1> x;
// 两个标准中都认可的写法, 在表达式两边加上括号
A<(3 >> 1)> x;
```

当然也不能说这是设计上的不周, 现实中像上面这样偏偏用到一个右移运算来特化的例子屈指可数, 而嵌套模板的使用则比比皆是. 所以这只是牺牲不常见的用况来方便更常见的写法, 还是很有道理的.



## 新的类型别名机制

### 为什么
在编写代码时, 可以为一些类型设置别名, 使得代码更容易理解. 在既有标准中, 可以使用 `typedef` 关键字定义类型的别名. 如

```cpp
typedef unsigned char byte;
```

以上代码中将类型 `unsigned char` 定义为 `byte`. 就这样直白的别名设置而言, `typedef` 还算看得过去, 但下面这些情况就略显晦涩了

```cpp
typedef int int_arr[10];
typedef int (* fn_type)(int, int);
```

其中第一个别名设置是将 10 个 `int` 构成的数组定义成名为 `int_arr` 类型; 第二个则定义了名为 `fn_type` 类型, 它的类型是函数指针, 这类函数指针指向的函数接受两个 `int` 参数, 返回一个 `int`. 这两种类型别名的语法都将名字放在了语句中间某个位置, 读起来并不直观.

### 有什么
为了改善这一弊端, 在 C++11 中为 `using` 指派了一个新功能, 使得用户可以用更加清晰的方式为类型指定别名. 以上面三种类型别名为例, 它们可写作

```cpp
// 语法形式为
// using 别名 = 类型
using byte = unsigned char;         // 普通类型, 直接写在等号右侧
using int_arr = int[10];            // 数组类型, 用类型名加上方括号和数量
using fn_type = int (*)(int, int);  // 函数指针类型, 在返回值类型和参数列表之间加上 (*)
```

这一语法形式与 `typedef` 不同的是, 在类型别名和实际的类型之间, 显式地插入了一个等号, 等号左边的标识符就是别名. 如此一来, 用户在阅读代码时就能立即明白为怎样的类型设置了什么别名.

除了提供更为明了的类型别名语法, `using` 还可支持泛型类型定义, 如

```cpp
// 语法: 在 template < ... > 泛型声明后立即加上 using 语句
// 泛型参数 T 必须指定, 而 Alloc 有默认值 std::allocator<T>
template <typename T, typename Alloc = std::allocator<T>>
using vec_iter = typename std::vector<T, Alloc>::iterator;

std::vector<int> x;
// 使用 int 特化 vec_iter 别名, 另一泛型参数是默认的 std::allocator<int>
// 因此特化出的类型 vec_iter<int> 为
// std::vector<int, std::allocator<int>>::iterator
vec_iter<int> i = x.begin();
```


##  对象初始化的改进

> 统一的对象初始化语法

C++11 开始统一千奇百怪的对象初始化语法了, 同时各种 STL 容器增加预设元素的初始化方式.

### 为什么
这个故事还要从 C 的一个语法点说起. 在 C 语言中, 如下的代码

```cpp
struct Point {
    int x;
    int y;
};

Point p = {0, 1};
int a[] = {0, 1};
```

同样的 `{0, 1}` 在编译器看来语义是截然不同的, 对 `p` 而言是初始化其成员, 对 `a` 而言则既要推导 `a` 的大小又要设定其元素的值.

而在 C++03 中, 如果为 `Point` 定义一个构造函数, 以下写法就不正确了

```cpp
struct Point {
    int x;
    int y;

    Point(int x_, int y_): x(x_), y(y_) {}
};

Point p = {0, 1}; // 错误: 非 POD 的类型不能用初始化列表构造
```

不过, 只要用 C++11 的编译器, 上述代码中的编译错误就立即消失了. 实际上, C++11 中添加以上语法作为一则初始化语法, 或者说调用构造函数的语法. 如

```cpp
Point p = {0, 1};   // 与初始化 POD 的语法相同
Point q{0, 1};      // 亦可省去等号

// 这两种写法均等价于传统写法
Point r(0, 1);
```

也就是说, 针对构造函数, 可以使用花括号替代圆括号. 这一特性还有助于减少调用无参构造函数时的书写错误. 例如

```cpp
struct Point {
    // ...
    Point() : x(0), y(0) {}
};

Point p();
```

上例中定义 `p` 的实际上并不是调用无参构造函数初始化一个 `Point` 对象, 实际上它是一个函数前置声明, 该函数没有参数并返回 `Point`. 这一新人杀手级语言 "特性" 导致的错误通常在修改代码时, 去掉了构造参数都但没有去掉括号而产生. 而在新语法中, 它可以这样写

```cpp
Point p{};
```

另外, 用户可以利用这一语法特性简化一些 `return` 语句. 当函数需要返回以特定构造函数构造的对象时, 可以使用花括号语法, 而不必写出类名. 如

```cpp
std::string make_string()
{
    return {};
    // 而不需要写
    // return std::string();
}

Point make_point(int x, int y)
{
    return {x, y};
    // 而不需要写
    // return Point{x, y};
}
```

除了以上单个对象的构造语法有所更改, 批量构造对象的语法语义也变得不同. 类似 `int a[] = {0, 1};` 这一例子中, 数组初始化时给出的花括号括起的整数值序列, 它不仅仅可以用于构造数组, 现在也可以用于构造容器了. 比如

```cpp
std::vector<int> x = {0, 1};
// 当然, 也可以去掉等号
std::vector<int> y{2, 3, 5, 7};

for (int i: x) {
    std::cout << "x contains " << i << std::endl;
}
/* 输出
x contains 0
x contains 1
*/

for (int i: y) {
    std::cout << "y contains " << i << std::endl;
}
/* 输出
y contains 2
y contains 3
y contains 5
y contains 7
*/
```

如果编译时知道一个容器里该有些什么东西, 直接写到构造函数里, 比先定义出容器再一个个添加要简单多了.

这一语法看起来很奇特, 不过并不神秘, 也不仅仅被 STL 容器所用 (不仅 `vector`, 其他所有的 STL 容器都支持这样构造). 在 C++11 中, 编译器处理到花括号扩起的类型相同的表达式时, 就会试图将其转换为称作 `std::initializer_list` 的泛型类的实例, 而 STL 容器之所以可以这样构造, 无非是因为它们都有参数 `initializer_list<value_type>` 的构造函数. 当然, 不仅构造函数可将初始化列表当作参数, 一般函数也可以, 如

```cpp
#include <iostream>
#include <initializer_list>

// 以 initializer_list 为参数的函数, 这是一个泛型类型, 需要特化
void f(std::initializer_list<int> x)
{
    // initializer_list 实例的 size() begin() end() 函数使它可以表现得像一个标准容器
    std::cout << "initializer_list size=" << x.size() << std::endl;
    for (int i: x) {
        std::cout << "-- element " << i << std::endl;
    }
}

int main()
{
    f({1, 1, 2, 3});
    /* 输出

    initializer_list size=4
    -- element 1
    -- element 1
    -- element 2
    -- element 3

    */

    f({});
    /* 输出

    initializer_list size=0

    */
    return 0;
}
```

而像 `std::map` 这样, 元素类型不是一个单一的值而是键值对, 在初始化的时候就需要混合使用初始化列表和之前介绍的用花括号括起构造参数的做法

```cpp
std::pair<std::string, int> jan{"jan", 1};
std::map<std::string, int> x{ // map<std::string, int> 中的值类型是 pair<std::string const, int>

    jan,                      // 可以使用一个 pair 实例来复制构造

    {"feb", 2},               // 也可以使用花括号括起的两个值调用构造函数
    {"mar", 3},
};
std::cout << x["feb"] << std::endl; // 2
```

不过这样看起来, 花括号的作用又非常混乱了. 即, *如果花括号中各个元素的类型一致, 那么它被编译器视作一个初始化列表实例; 否则编译器将根据花括号中各表达式的类型, 尝试决议出一个构造函数重载进行调用.*

然而, 假如像上面 `Point` 类那样, 其构造函数的参数类型恰好都是相同的, 构造参数看起来像个初始化列表, 编译器不会很困惑吗?

确实初始化列表的语法仍有歧义. 在这种情况下, 用初始化列表语法去调用函数时, 将*优先匹配*以 `initializer_list` 为参数的重载, 若不存在此重载才会以其他重载作为备选. 比如下面的例子

```cpp
void f(std::initializer_list<int> x) // (a)
{
    std::cout << "initializer_list" << std::endl;
}

void f(Point p)                      // (b)
{
    std::cout << "point" << std::endl;
}

int main()
{
    f({0, 0});                       // 输出: initializer_list
    return 0;
}
```

例子中定义了两个重载, 重载决议会判定为调用 (a), 而将 (a) 删除掉的话, 则重载 (b) 会被执行.

### 委托构造函数

当为一个成员很多的类型编写一组构造函数重载时, 需要给每个构造函数都写上长长的初始化列表. 如

```cpp
struct Person {
    std::string first_name;
    std::string last_name;
    std::string address;
    int score;
    int age;

    // 显式初始化每个成员的完整初始化
    Person(std::string const& fname, std::string lname, std::string const& addr,
           int s, int a)
        : first_name(fname)
        , last_name(lname)
        , address(addr)
        , score(s)
        , age(a)
    {}

    // 只为部分成员执行默认初始化
    // 传统的做法仍然需要将一些原生成员放到初始化列表中
    Person(std::string const& fname, std::string lname, int a)
        : first_name(fname)
        , last_name(lname)
                            // address 作为 string 类型成员, 有构造函数保证其正确初始化, 不必写入初始化列表
        , score(0)          // 但整数或指针等原生类型需要显式初始化
        , age(a)
    {}
};
```

这种写法一方面初始化列表的代码显得臃肿不堪, 另一方面维护难度也很大, 如果新增原生类型成员, 每个构造函数的初始化列表里都需要加上对其的初始化.

在 C++11 中新增了一种初始化列表的书写方式, 即允许一个构造函数调用另一个构造函数作为初始化对象的手段, 如以上代码中的第二个构造函数重载可以调用第一个重载. 如

```cpp
struct Person {
    // ...

    Person(std::string const& fname, std::string lname, std::string const& addr,
           int s, int a)
        : first_name(fname)
        , last_name(lname)
        , address(addr)
        , score(s)
        , age(a)
    {}

    // 使用委托构造函数的做法是, 将另一构造函数的调用作为唯一成分写在初始化列表中
    // 这个例子中, 上一个构造函数重载中初始化了所有成员
    // 其他构造函数都可调用上一构造函数重载, 不用担心漏掉个别成员的初始化
    Person(std::string const& fname, std::string lname, int a)
        : Person(fname, lname, "", 0, a)
    {}
};
```

需要注意的是, C++ 构造函数对成员初始化的要求是不重不漏, 当委托另一构造函数进行构造后, 隐含着 "所有成员都已被正确初始化" 这一结果, 因此不能继续在初始化列表中加任何成分, 或者委托调用其他的构造函数. 例如下面是一些可能误用的情况

```cpp
struct Person {
    // ...
    Person(std::string const& fname, std::string lname, int a)
        : Person(fname, lname, "", 0, a)
        , age(0) // 错误: 不能再初始化其他成员了
    {}
};

struct Base { int x; Base(int x_): x(x_) {} };

struct Inherit : Base {
    int y;

    // 正确: 先调用父类构造函数初始化父类的部分, 再初始化本身的成员
    Inherit(int x_, int y_): Base(x_), y(y_) {}
    // 正确: 委托构造
    Inherit(int x_): Inherit(x_, 0) {}

    Inherit(int x_)
        : Base(x_)
        , Inherit(x_, 0) // 错误, 对父类初始化后, 不能再使用委托构造
    {}
};
```

### 成员缺省初始化

另一可以简化构造函数代码的特性则是为那些无论如何都需要初始化, 并且有固定初始化模式的成员设置缺省的初始化方式. 比如

```cpp
std::string current_date();

class Logger {
    // 为这个 ofstream 类型成员设定缺省的初始化方式
    std::ofstream output{"logs/log-" + current_date() + ".log"};

    int id;
    std::string format;
public:
    Logger(int id)                              // (a)
        : id(id)
    {}

    Logger(int id, std::string const& fmt);     // (b)
        : id(id)
        , format(fmt)
    {}

    Logger(std::string const& filename, int id) // (c)
        : output(filename, std::ios_base::app);
        , id(id)
    {}
};
```

在上例中有三个构造函数重载, 其中 (a) 和 (b) 都没有显式初始化 `output` 成员, 但是 `output` 成员其默认构造函数又不能产生一个可以正常工作的文件流对象, 于是就需要给出一个缺省的初始化方式, 这种初始化就是将构造参数直接写在成员声明处. 如果像 (c) 重载那样指定了 `output` 的初始化方法, 那么指定的缺省初始化就不会被执行.

从例子中还可以看出, 虽然成员初始化参数的模式只能设定一种, 但并不妨碍从这种模式中得出不同的实参, 如果 `current_date()` 这个函数能返回不一样的值, 那么构造不同 `Logger` 实例时其 `output` 指定的文件名仍可以是不同的.

以上写法中不能将初始化的花括号改成圆括号, 否则语法上会被编译器识别为成员函数定义.
``` struct A {
    int m(0); // 错误: 这会被编译器认为是定义函数
    int n{0}; // 正确: 使用花括号括起参数
    int p{};  // 正确: 使用花括号, 无初始化参数, int 被置为 0
};
```

可以复制构造的成员亦可用等号设定初始值^[[使用等号的语法会让编译器认为是复制构造, 但编译器通常会优化掉. 恰好例子中的流对象是不可复制构造的, 因此只有上面这种写法.]]. 如下面例子中的写法也都是正确的.

```
struct A {
    int m = 0;                           // 直接使用等号加上初始值
    std::string s = "1";                 // 相当于 = std::string("1")
    std::string t = std::string(3, '2'); // 显式写作复制构造形式
};
```

## 类型推导
>略


# 常量与字面量

在既有 C++ 标准中, 使用常量要么通过枚举 (enumeration), 要么通过 `const` 限定的名字定义. 而两者多多少少都有一些缺陷: 枚举由于其可以隐式与整数类型互相转换, 因而缺乏类型和取值范围的约束; 而 `const` 关键字有时仅仅表示用户无法修改而并非该值本身是常数, 产生一些二义性.

在新标准中引入了许多常量和字面量的改进, 让枚举类型的运用更加安全, 提供了语义更明确的常量, 并且还加入了用户自定义字面量的机制. 本章中便来一一介绍它们.


## 枚举类型改进


在 C++11 中, 用户可以给枚举类型指定更精确和严格的类型了, 这一点体现在两方面: *允许指定枚举类型的宽度和符号;* 允许在引用枚举常量时要求*用户显式指定枚举的域来减少名字冲突的可能性*.

第一项特性的具体做法是, 在声明枚举类型时如声明继承一样, 为这个枚举类型指定一个 "父类" 类型. 当然, 这与继承并无任何关系, 只是规定此枚举类型可能的取值范围, 这样做可以让编译器提供更好的取值检查. 如

``` cpp
enum flags : unsigned short {//规定枚举类型取值范围
    READONLY = 1,
    READWRITE = 2,
    ADMIN = 4,
};
```

以上声明中规定了 `flags` 枚举中的常量是无符号数且位宽与 `short` 类型一样. 一旦编译器检查到该类型的某个常量取值超过此返回就会报错, 如

```cpp
enum uint_enum : unsigned int {X = -1}; // 错误: -1 不是无符号整数
enum byte_enum : char {Y = 128};        // 错误: 128 超过了 char 的表示范围
```

当然, 为枚举指定类型限定*仍然只能使用整型*, 不能写如 `enum X : double` 的声明.

第二项特性的具体做法是, 在 `enum` 关键字后加上 `struct` 或 `class` 关键字 (凭个人喜好或编码规范, 对编译器而言完全无区别), 作用是所有该枚举类型定义的常量不能直接引用, *必须加上枚举类型名*, 这样做*可以避免枚举常量重名的问题.* 如

```cpp
enum class Province {HUBEI, HUNAN, GUANGDONG, HAINAN};
enum struct City {WUHAN, CHANGSHA, GUANGZHOU, HAIKOU};

Province p = Province::HUBEI; // 正确
City c = City::WUHAN;         // 正确: 以 enum 名作为名字空间访问
City d = WUHAN;               // 错误: WUHAN 在当前上下文中未定义
```

这两个特性也可以结合在一起使用, 如

```cpp
enum class Direction: unsigned char {RIGHT, DOWN, LEFT, TOP};
Direction d = Direction::RIGHT;
```


## constexpr

### 为什么 
除了使用枚举类型, 在 C++ 中也可以使用 `const` 来定义常量, 并且除了整数类型的常量, 它也可以作用于其它类型, 如 `double` 浮点数等.

不过, 使用 `const` 来限定一个名字, 其*初衷只是表示其无法修改, 而若其以常数初始化, 那么编译器认为被定义的名字表示一个常量* (当然常量必然无法修改). 这会产生一定的二义性, 并在给一些代码带来麻烦, 比如

``` cpp
template <int I>
class A {};

void f()
{
    int const N = 5;
    A<N> a; // 合法: 编译器认为 N 是编译时常量
}

void g()
{
    int n = 5;
    int const M = n;
    A<M> a; // 不合法: 编译器认为 M 只是一个无法修改的量
}
```

### 有什么
而在 C++11 中, 一个新的用来定义编译时常量的机制加入了标准. 标准引入了 `constexpr` 这一关键字以区分 `const` 关键字, *使用这一关键字定义的值必须是编译时常数*, 因而可以用于定义固定长度的数组, 或像上例中那样特化模板, `static_assert`, 以及任何需要一个常数的地方. 这一机制的另一个方面是允许通过函数计算返回一个编译时常数, 即使用 `constexpr` 关键字定义的函数在*参数都为常数的情况下*返回的值也可以被认为是一个常数.


而如果使用了 `constexpr` 无法定义出一个常数, 或者 `constexpr` 修饰的函数不满足某些条件, 那么编译器会立即报错. 这也避免了出现 `const` 那样不明确的语义.

### 基本语法和使用

使用 `constexpr` 修饰一个名字定义, 让它一定是编译时常数, 写法是将 `constexpr` 关键字放在定义语句的开头.

``` cpp
constexpr int N = 5;        // 定义 N 为常量 5

template <int I>
class A {};
A<N> a;                     // 可以用于特化模板

static_assert(N == 5, "");  // 可以用于 static_assert
```

与 `const` 不同的是, 它*必须由其他编译时常数在定义处立即初始化*, 不能用于声明形式参数. 另外, 如果*用作定义类的成员, 它必须是 `static` 修饰的*.

```cpp
int x = 0;
const int y = x;                // 这样写是允许的

int m = 0;
constexpr int n = m;            // 错误: 初始值 m 不是一个编译时常数

void f(constexpr int N) {}      // 错误: 不能作为参数

struct X {
    constexpr int M = 6;        // 错误
    constexpr static int M = 6; // 正确: 必须带上 static 修饰
};
```

其中的理由也不复杂: 使用 `constexpr` 就是在定义编译时常量, 因此编译器当然需要一个常量去初始化它; 并且类型的各个实例也没有必要共享一个编译时常量, 声明为静态是合适的做法. 而如果在函数体内定义一个 `constexpr` 修饰的量, *它自动获得 `static` 修饰, 无须显式写出*. 当然, *一般而言这些常量并不会真的被编译器放入程序的静态存储区, 它们往往在编译时就被替换为常数了*.

除了用来定义常量, `constexpr` 关键字也可以用来修饰函数. 修饰全局或静态函数时, *表示这个函数在参数都为常量时将返回一个常量*. 比如

```cpp
constexpr int square(int x)
{
    return x * x;
}

// 也可以修饰模板函数
template <typename T>
constexpr T cube(T x)
{
    return x * x * x;
}

constexpr int I = square(5);     // 25
constexpr int K = cube(-5);      // -125
constexpr double L = cube(1.6);  // 4.096
```

也就是说, 上面这些函数调用实际上由编译器自己执行并计算出了结果, 然后当作编译时常量使用.

这样定义的函数也能在参数不为常量时使用, 不过这样的话, 返回值也就不能作为常量看待了

```cpp
int x = 5;
int y = cube(x);        // 正确: 参数 x 不是编译时常量, 但是可用来调用 cube, 其结果被视为变量
constexpr z = cube(x);  // 错误: 参数 x 不是编译时常量, 调用 cube 返回的结果不被认可为常量
```

在以上例子中的 `constexpr` 函数都比较简单, 不过实际上, `constexpr` 修饰函数时, 有一些规则迫使它**必须**这么简单. 这些规则是

* *调用时必须已经给出完整定义而非前导声明*
* 非构造函数的 `constexpr` 函数只能包括一条 `return` 作为非编译时语句 ("编译时语句" 是笔者的造语, 指代如 `static_assert`, `typedef`, `using`, `enum` 等只在编译时产生效果的语句)
* 构造函数的初始化列表中的表达式, `return` 的表达式中, 只能引用 a) 参数 b) 编译时常量 c) 其他 `constexpr` 函数调用 d) 以上项目的运算或成员 (有运算符重载的情况视作 c 项)

第一条规则是理所当然的, 它保证编译器知道这一函数的定义并能够在编译时模拟执行它.

而接下来一条规则就非常严苛了, 甚至这样的代码也不会被认可[[在 C++14 中这一约束被放宽了, 允许函数在栈上定义 `const` 量或使用简单的分支语句]]

```cpp
constexpr int successor(int x)
{
    constexpr int C = 1; // 可以将这一句改为 enum {C = 1}; 通过编译
    return x + C;
}
```

最后一条规则中约束了这些函数能使用的值也应该都是常数, 毕竟要在编译时执行这些代码. 并且, 函数调用中如果有其他函数也不会产生其他效果, 因为被调用的那些也都是 `constexpr` 函数.

说到这里不得不提, 所有的数学库函数都**不**是 `constexpr` 修饰的. 比如求平方根, 虽然理论上来说完全可以在编译时求得任何常数的平方根, 但实际上 `sqrt` 函数的实现中有产生副作用的可能性, 因为在参数为负数时, `errno` 会被设置 `EDOM` 表示发生了一个定义域错误.

不过这些也只是一些说辞. 在不考虑定义域的情况下, 自行定义 `constexpr` 求平方根函数并不是不可能

```cpp
// 使用二分法求平方根
// PRECISION 值为精度要求
constexpr double PRECISION = 1e-3;

// 猜测值 guess 的平方和原参数 x 小于在容许范围内, 也就是小于精度要求时, 认为此猜测值足够好
constexpr bool good_enough(double x, double guess)
{
    // | x - guess * guess | < PRECISION
    return -PRECISION < x - guess * guess && x - guess * guess < PRECISION;
}

// 如果猜测值 guess 足够好就返回它, 否则, 递归求更精确的值
constexpr double sqrt_impl(double x, double guess)
{
    return good_enough(x, guess) ? guess : sqrt_impl(x, (guess + x / guess) / 2);
}

// 求平方根的功能入口, 以 1.0 作为初始猜测值
constexpr double sqrt_c(double x)
{
    return sqrt_impl(x, 1.0);
}

constexpr double X = sqrt_c(2); // 约为 1.41422
constexpr double Y = sqrt_c(3); // 约为 1.73214
```

从上面这一连串的 `constexpr` 函数也可以看出在严格的规则约束下能做到什么程度. 譬如使用 `?:` 三目算符替代分支语句, 包括使用递归都是允许的. 不过如果递归的次数过深, 编译器会选择报一个错误, 避免在可能实际上有缺陷的代码中越陷越深. 譬如, 利用上述代码求 `sqrt_c(-2)` 时, 在 `sqrt_impl` 中是会无限递归的, 这时会以编译错误收场.

### 自定义常量类型

引入 `constexpr` 的好处除了区分一般 `const` 而获得更明确语义, 和使用函数计算常量之外这两点之外, C++11 还允许自定义常量的类型. 举个例子, 下面这种代码也是可行的

```cpp
struct Vector2d {
    double x;
    double y;

    constexpr Vector2d(double xx, double yy) // (a) constexpr 修饰的构造函数
        : x(xx)
        , y(yy)
    {}

    constexpr double length() const          // (b) constexpr 修饰的成员函数
    {
        // 使用刚才例子中的 sqrt_c
        return sqrt_c(x * x + y * y);
    }
};

constexpr Vector2d v{3.0, 4.0};              // (c) 使用上面定义的 Vector2d 定义常量 v
constexpr double x = v.x;                    // (d) 使用常量 v 的属性定义常量 x
constexpr double len = v.length();           // (e) 使用常量 v 计算得出常量 len
```

这个例子中, `Vector2d` 这个类型定义的内部有两个带有 `constexpr` 修饰的函数, 一是其构造函数, 另一个是非静态成员函数. 然后定义了 `Vector2d` 的实例 `v`, 它以 `constexpr` 修饰, 其被认为是一个编译时常量; 然后, 使用其成员去初始化常量 `x`, 或调用其成员函数 `length()` 得到常量返回值去初始化 `len`.

例子中多次出现了 `constexpr`, 不过其中的内在联系很清晰, 它们是这样的

* 自定义一个可以被用作常量的类型, 那么它必须有*至少一个* `constexpr` 构造函数 (a)
* 应当使用有 `constexpr` 构造函数来构造被定义为常量的实例 (c), 当然, 这时*传给构造函数的实参必须全部是常量*
* 当一个自定义类型的实例被定义为常量后, 它的*成员将都被视作常量* (d) (除了 `mutable` 修饰的成员, 它们仍然被视作一般变量)
* 由于常量对象的各成员都被视作常量, 因此在这些成员上的运算, 或使用这些成员调用其他 `constexpr` 函数, 得到的也将是一个常量; 并且, 可以使用 `constexpr` 修饰成员函数, 让它在对象本身是常量时尽可能返回一个常量 (b)
* 对常量对象调用其 `constexpr` 修饰的成员函数能得到一个常量 (e)

反过来说, 如果上面 (a) 处构造函数的 `constexpr` 被去掉, 那么 (c) 处就无法编译通过, 连带 (d) (e) 也出错; 而如果去掉 (b) 处成员函数的 `constexpr`, 那么 (e) 处调用 `v.length()` 将不被认为得到的是一个编译时常量, 因而初始化 `len` 时产生一个错误.

使用 `constexpr` 修饰成员函数的基本规则跟修饰一般函数差不多, 也是只能有一条 `return` 语句, 其表达式用到的只能是参数或者其他常量等等, 不过还加上一条, 就是可以使用对象自身非 `mutable` 的成员. 另外, *`constexpr` 修饰的成员函数在 C++11 标准中自动带有 `const` 修饰, 但在 C++14 标准中去掉了这一规则, 所以在写代码时最好还是显式写上 `const`*.

而使用 `constexpr` 修饰构造函数的规则就不太一样了: 首先, 构造函数并不需要 `return` 一个值, 于是函数体内不允许有任何非编译期语句; 构造函数的重点在其初始化列表, 如果调用委托构造函数或父类的构造函数, 那么被委托的构造函数或其父类的对应构造函数必须也是 `constexpr` 修饰的; 调用其他构造函数的参数表达式, 或其他成员的初始化表达式中, 所有用到的部分也都必须是常量, 与约束一般 `constexpr` 函数 `return` 表达式的规则相同.

除了以上作用于各个函数上的规则, 用来定义常量的类型本身还有其他要求. 在 C++11 中, 描述能够用来定义常量的类型的术语是**字面类型** (literal type), 所有的基本数据类型都是字面类型, 而自定义字面类型, 则必须满足以下条件

* 该类有至少一个非复制构造函数是 `constexpr` 修饰的
* 该类型有一个平凡的析构函数, 它的每个基类和非静态成员也须递归地满足这个要求

第一条规则在前面中已经说过了, 如果没有 `constexpr` 修饰的构造函数, 那么无法合理地初始化这一常量对象. 而第二条规则是有关编译器如何对待常量的. *对于常量, 编译器可能只在编译时使用它们, 因此, 这个对象可能不会存在于运行时, 也就不会被析构, 这就需要一条约束, 使得这个对象即使不析构也不产生任何问题*.

如果不满足字面类型的定义, 那么用此类型就无法定义常量. 比如字符串类型 `std::string`, 它的析构函数会释放其所持有的堆上资源, 因此不是字面类型

```cpp
constexpr std::string S("hello, world");  // 错误: string 不是一个字面类型
constexpr size_t sz = S.size();           // 连带错误: string::size() 也不可能是常量
```

字面类型除了用来直接定义常量之外, 也可以作为 `constexpr` 函数的参数类型或返回值类型使用. 比如

```cpp
constexpr Vector2d multi(Vector2d const& a, double times)
{
    return Vector2d(a.x * times, a.y * times);
}

constexpr Vector2d m = multi(Vector2d{1, 2}, 2);
constexpr double xx = m.x; // 2.0
constexpr double yy = m.y; // 4.0
```

或者, 将这一功能定义为算符重载, 显得更简洁

```cpp
struct Vector2d {
    // ...

    // 算符重载成员函数也可以加上 constexpr 修饰, 与其他成员函数规则一样
    constexpr Vector2d operator*(double times) const
    {
        return Vector2d(x * times, y * times);
    }
};

constexpr Vector2d m = Vector2d{1, 2} * 2;
constexpr double xx = m.x; // 2.0
constexpr double yy = m.y; // 4.0

// constexpr 也可以用于定义全局的算符重载, 与其他全局 constexpr 函数规则一样
constexpr Vector2d operator*(double times, Vector2d const& a)
{
    return a * times;
}
```

需要指出的是, 若 `constexpr` 修饰一个泛型函数, *其泛型参数用非字面类型特化时, 不构成编译错误, 只不过, 这一特化退化为非 `constexpr` 修饰的*.

比如标准库中, `std::pair` 泛型类的构造函数是 `constexpr` 修饰的, 这意味着在使用两个字面类型特化 `std::pair` 模板类型的情况下, 其实例可以是常量

```
constexpr std::pair<int, Vector2d> velocity{70, Vector2d{1, 0}};
constexpr int speed = velocity.first;               // 70
constexpr bool toward_east = velocity.second.x > 0; // true
```

当然谁也不能料定模板参数类型不含 `string` 之类的非字面类型, 因此需要有这条规则保证在这种情况下不出现编译错误.

```cpp
// 正确
std::pair<int, std::string> x{0, ""};

// 错误: 特化出的 pair<int, string>(int, string) 构造函数退化为非 constexpr 函数
constexpr std::pair<int, std::string> y{0, ""};
```

### 优化意义上的 `constexpr` 函数

在上面的介绍中指出了 `constexpr` 与字面类型之间的联系. 一个 `constexpr` 函数的返回值类型和各形式参数类型, 如果不是模板类型参数, 那么必须都是字面类型. 理由也很明显, 因为这些函数可用以定义只存在于编译期的常量, 因此, 它们不应该有非平凡的析构函数.

不过相对于其他函数而言, 构造函数有点特殊, 它并没有返回值. 更准确地说, 构造函数在给定地址空间上进行的一系列初始化对象的行为, 虽然将对象构造的调用放在表达式里其值是这个对象, 但这个构造调用并没有 "返回" 一个对象. 这样一来, 如果一个非字面类型的构造函数的各个参数类型是字面类型, 并且满足其他 `constexpr` 修饰函数时的规则, 那么这个构造函数仍然可以是 `constexpr` 修饰的.

比如, 实现一个这样的指针包装类型

```cpp
class IntPtr {
    int* ptr;
public:
    // 此类型实例内部的 ptr 指向堆上空间
    explicit IntPtr(int x)
        : ptr(new int(x))
    {}

    // 析构时, 需要归还堆上空间
    // 因此, 这不是一个字面类型
    ~IntPtr()
    {
        delete ptr;
    }

    IntPtr(IntPtr const&) = delete; // 简单起见, 不允许复制

    // 但是, 其某些构造函数可以是 constexpr 修饰
    // 如下面这个, 满足 constexpr 构造函数的各个规则约束就行
    constexpr IntPtr()
        : ptr(nullptr)
    {}
};

constexpr IntPtr p; // (a) 编译错误: IntPtr 不是字面类型不能用来定义常量
IntPtr q;           // (b) 编译通过
```

上面例子中, `IntPtr` 类型虽然不是字面类型, 但可以拥有 `constexpr` 修饰的构造函数; 然而, 即使有 `constexpr` 修饰的构造函数, 却不能用这个构造函数定义常量, 因此 (a) 处无法编译.

这样绕来绕去的, 看起来这好像是绕过规则而产生的一个漏洞, 但它仍然是有意义的.

实际上, 当一个函数被 `constexpr` 修饰时, 其真正的作用是, 若该其参数为编译时常数, 那么编译器会将直接编译时初始化该函数返回的对象地址空间, 即有可能的话, 编译器会在编译时计算将该函数的返回值, 然后生成直接写入常数的代码, 减少运行时开销. 这使人感觉像一个更加高级的 `inline` 修饰, 反而跟编译时常量关系不大, 只不过恰好利用函数计算编译时常量可以藉由这样的函数来完成. 而用 `constexpr` 修饰非字面类型的构造函数 (或字面类型的构造函数) 就是仅运用了这一高级 `inline` 机制, 避免构造函数调用开销, 生成直接将实例的各成员的值设为常数的运行时代码. 因此如果程序执行到上述代码的 (b) 处, 它并不会调用构造函数, 而是根据构造函数的指示, 直接在对象的地址上写入一个空指针的值, 对于 x64 架构而言, 就是填上 8 字节的零.

所以, 即使不是用来定义常量, 也可以将一些简单的函数定义为 `constexpr` 函数, 让编译器尽情优化之.


## unicode 常量
在 C++11 标准中新引入了 UTF-8 预编码字符串的机制, 可以*让编译器在编译时对字符串字面常量进行转码*. 如以下代码

```cpp
#include <iostream>

char u[] = u8"汉";

int main()
{
    std::cout << u << std::endl;
    return 0;
}
```

这样在程序运行时将以 UTF-8 的编码输出 "汉" 字, 前提条件之一是编译器能正确处理输入文件的编码, 如 GCC 会从系统上下文获取默认的输入编码方式, 或以 `-finput-charset=` 来指定编码, 此编码应当与输入文件的编码方式一致, 换言之编译器在这时也扮演一个编码器的角色. 另一个前提条件是命令行软件本身能支持 UTF-8 内容的显示, 比如 Linux 的 xterm 能正确显示 UTF-8 编码的内容, 但 Windows 自带的 cmd 则不能正确显示.

由于编译时完成了编码, 得到的结果就是字节序列, 因此定义的 `u` 的类型为 `char[]`.

如果要以宽字符存储字符串字面量, 以前的 `L` 前缀仍然可以用, 但定义出的 `wchar_t` 的宽度仍然是一个编译器确定的值, 这实在是容易引起问题的地方. 所以 C++11 又加入了两个新的固定宽度的字符类型, 以及相应的前缀, 如

```cpp
char16_t c16 = u'汉';   // 小写 u 开头表示以 UTF-16 编码的字符或字符串
char32_t c32 = U'汉';   // 大写 U 开头表示以 UTF-32 编码的字符或字符串
char16_t s16[] = u"汉";
char32_t s32[] = U"汉";
```

请注意, 由于 UTF-8 编码得出的序列不是宽字符, 因此并不存在 `u8'汉'` 字符形式, 只有字符串形式.

然而标准中很尴尬的一点是, 并没有新增对应预定义输出流 (比如 `std::cout` 之于 `char[]` 或 `std::wcout` 之于 `wchar_t[]`), 因此如果在程序中用适于一般字符或宽字符的流来输出它们, 这些字符类型将转换成整数输出, 而字符串将转换为地址输出.

当然, 文本编码并不是简单的几个数据类型换来换去就能解决的, 要按照具体的情况选择合适的方法. 比如 HTTP 通信中向客户端发送内容, 宜用 UTF-8 编码的字节序列; 而本地程序的用户界面最好还是使用专门的国际化工具来转换程序中的字符串.

## 免转义字符串常量

C++11 中开始支持免转义以及多行字符串字面量来降低在源代码中编写复杂文本内容的难度. 其形式为

```cpp
R"自定义分隔符(任意字符内容)自定义分隔符"
```

其中 "自定义分隔符" 可以是任意内容, 圆括号前后的两部分自定义分隔符必须相同. 比如

```cpp
auto x = R"delim(Print "hello, world".)delim";
//               ^^^^^^^^^^^^^^^^^^^^^
// 字符串内容为圆括号中间的部分, 不含圆括号, 双引号不会引起字符串结束
// 必须由一个反圆括号, 分隔符, 引号结束
std::cout << x << std::endl;

/* 输出

Print "hello, world".

输出结束 */
```

如果要指定编码前缀, 这个前缀要出现在 `R` 之前, 如

```cpp
auto x = u8R"""(汉字)"""; // 正确, 等价于 u8"汉字"
auto y = Ru8"""(汉字)"""; // 错误, u8 前缀必须出现在 R 之前
```

此外, 这种方式还可以定义多行字符串, 比如

```cpp
auto x = R"""(
hello
world
)""";
// 等价于 "\nhello\nworld\n", 请注意开始的圆括号之后和结束的圆括号之前的换行符也计入

auto y = R"""(
 ________   _____     _____    ________  ________
/       |   |   |     |   |   /       | /       |
|       | --'   '-- --'   '-- |_      | |_      |
|     --  |       | |       |   |     |   |     |
|       | --.   .-- --.   .--   |     |   |     |
\_______|   |___|     |___|     |_____|   |_____|
)""";
// 请注意最后一行文本第一个字符反斜线 (\) 不再有转义功能, 而被作为普通字符进入字符串定义

std::cout << x << std::endl;
std::cout << "====" << std::endl;
std::cout << y << std::endl;

/* 输出

(空行)
hello
world
(空行)
====
(空行)
 ________   _____     _____    ________  ________
/       |   |   |     |   |   /       | /       |
|       | --'   '-- --'   '-- |_      | |_      |
|     --  |       | |       |   |     |   |     |
|       | --.   .-- --.   .--   |     |   |     |
\_______|   |___|     |___|     |_____|   |_____|
(空行)

输出结束 */
```



## 自定义字面量后缀

在 C 语言中, 程序员可以使用后缀来指定一个字面常量的类型, 比如以下的代码

```cpp
printf("%lld\n", -1);   // 错误: 常数 -1 压栈时只会占用一个 int 类型的空间, 少于一个 long long 类型的部分将是未初始化的栈空间
printf("%lld\n", -1LL); // 正确输出 -1
```

可以被指定后缀的类型仅限于对整型类型的修饰, 譬如上面的 `LL`, 或者加上 `U` 表示无符号. 在 C++11 中, 这个功能被开放了, 可以自定义一些后缀置于字面常量之后, 改变该字面常量的特性.

``` cpp
// 定义一个指定后缀的函数重载, operator "" 为语法固定部分, 后缀为 _s
std::string operator "" _s (char const* m, std::size_t)
{
    return std::string(m);
}

auto r = "hello, world"_s;
// 其中 "hello, world" 为原始字面量, _s 为后缀
// 表达式 "hello, world"_s 的类型为 string
// 因此定义的 r 为 string 类型而不是 char const*
```

自定义后缀实际上与算符重载并无任何关系, 只是它借用了算符重载的语法 (这一算符重载不可以被定义为类的成员函数, 只能定义在全局或任何名字空间下), 其中在返回值类型之后的 `operator ""` 是固定成分, 之后为自定义的后缀名, 接下来是参数列表和函数体.

使用自定义后缀等价于在该表达式位置调用该自定义后缀函数, 如上述定义等价于

```
auto r = operator "" _s("hello, world", 13); // 13 为字符串 "hello, world" 的字符个数, 含 nul
//       ^^^^^^^^^^^^^^ 这一段相当于其函数名
```

为了防止定义的后缀重复, 实际项目中建议在名字空间内定义后缀, 避免污染全局空间, 需要使用时在源码中 `using` 之, 如

```
namespace strliteral {

    std::string operator "" _s (char const* m, std::size_t)
    {
        return std::string(m);
    }

}

int main(int argc, char* argv[])
{
    // 可以 using 整个名字空间, 或者用以下语法仅导入个别后缀
    using strliteral::operator "" _s;
    if (argc != 1) {
        std::cout << "hello, "_s + argv[1] << std::endl;
        std::cout << ("hello, "_s == argv[1]) << std::endl;
    }
    return 0;
}
```

虽然声明自定义后缀函数的语法看起来有些怪, 但特定情况下用起来还是能省事不少, 比如上面将字符串字面常量转换为 `std::string` 类型对象以便与其他 `char*` 表示的字符串连接或比较等.

使用自定义后缀函数的语法必须是字面常量后直接连接后缀标识符, 中间不得有空格或任何其他内容, 如上面的例子中

```
auto r = "hello, world"_s;  // 这是正确的
auto s = "hello, world" _s; // 这是错误的
```

在这样的语法限制下, 定义后缀函数重载时可选的参数类型只有 4 大类, 分别对应于整数字面常量, 浮点数字面常量, 字符字面常量 (分为 `char` 类型和各种宽字符类型的版本) 以及字符串字面常量 (同样区分 `char` 类型和宽字符类型的版本). 除了这些类型, 其他类型都不可以出现在后缀函数重载的参数中. 例如下面这种写法是错误的.

```cpp
std::string operator "" _s (std::string s);
//                          ^^^^^^^^^^^ 以 std::string 类型作为参数是不可以的
```

更具体的, 自定义字面量的函数重载的参数列表只能是下面几种

|! 参数列表 | 匹配原生字面常量 | 调用举例
| `(CHAT_TYPE const*, std::size_t)` | 字符串常量; `CHAT_TYPE` 可能是 `char` `wchat_t` `char16_t` `char32_t` 之一; `size_t` 参数指出该字符串字面量的字符数量, 计入 nul | `"hello"_s`
| `(char const*)` | 形如 `10_suffix` 的表达式, 将前方的数字以字符串形式传入, 等价于 `operator "" _suffix("10")` | `10_km`
| `(CHAT_TYPE)` | 单个字符; `CHAT_TYPE` 与第一条中的字符类型一致 | `U'c'_encode`
| `(unsigned long long int)` | 也匹配形如 `10_suffix` 的表达式 (如果是带一个符号的整数字面量, 那么先将整数传给重载函数, 然后符号应用于返回的结果) | `10_km`
| `(long double)` | 浮点数 | `2.718_percent`

以 `char const*` 为参数的重载也能匹配以整数或浮点数为原始字面常量的变换, 同时定义时, 只有接受数值类型的重载会被调用, 当然一般也不会同时定义两个. 这一重载还有个变种形式

```
template <char... ch>
RETURN_TYPE operator "" _SUFFIX()
{
    /* ... */
}
```

函数本身无参数, 而可变模板参数 `char... ch` 则是数字字面常量部分的各个字符. 这一部分的内容将在后文 "可变参数模板" 一章中说明.

要注意的是, 以整数字面量或浮点数字面量为原始字面量时, 如果这个变量是带符号的, 那么字面量会先跟后缀结合调用自定义后缀函数, 然后跟符号结合调用单目算符重载函数. 这一点有时会引起误用, 比如为 "温度" 这个概念定义一个 "摄氏度" 的后缀

```
struct Temperature {
    long degree;

    explicit Temperature(long t)
        : degree(t)
    {}

    // ...
    // 没有其他算符重载
};

Temperature operator "" _c (unsigned long long t)
{
    return Temperature(t + 273);
}

int main()
{
    // 需求为定义一个表示零下 57 摄氏度的实例
    // 但下面的表达式等价于 -(57_c), 而表达式 57_c 的类型是 Temperature, 没有定义前置负号算符重载会导致编译错误
    Temperature co2_bolling_point = -57_c;
    return 0;
}
```

如果希望以上写法成立, 就必须再为 `Temperature` 重载前置负号操作符, 而不能用括号括起前面的 `-57` 写成 `(-57)_c`, 因为这并不是正确的自定义字面量语法.

然而, 如果这种情况下加上如下定义

```
struct Temperature {
    long degree;

    explicit Temperature(long t)
        : degree(t)
    {}

    Temperature operator-() const
    {
        return Temperature(-this->degree);
    }

    // ...
};
```

虽然写出 `-57_c` 这样的表达式并不会再有编译错误, 但其语义是错误的. 因为这样会先计算 `57_c` 得到一个 `degree` 为 330 的实例, 然后运用负号算符构造出 `degree` 为 -330 的实例, 与初衷相去甚远. 在这种情况下, 直接使用构造函数调用如 `Temperature(-57)` 才是可行的做法.

自定义字面量这一特性虽然名字上叫做 "字面量", 但切不可将其与字面**常量**混为一谈, 它的求值过程默认情况下是运行时的. 而若有需要编译器将其结果视作编译时常量, 则需要用到 `constexpr` 来修饰它. 而另一个前提是其返回值类型 `Temperature` 是字面类型. 根据这些条件, 可将代码修改成下面这样

```
struct Temperature {
    long degree;

    // 构造函数加上 constexpr 修饰
    constexpr explicit Temperature(long t)
        : degree(t)
    {}

    // ...

    // 不要有析构函数定义
};

// 也加上 constexpr 修饰
constexpr Temperature operator "" _c (unsigned long long t)
{
    return Temperature(t + 273);
}

int main()
{
    // 万事俱备, 可以用来定义编译时常量了
    constexpr Temperature water_bolling_point = 100_c;
    static_assert(water_bolling_point.degree == 373,
                  "I'm supposed to work under a standard atmosphere");
    return 0;
}
```

而若之后的代码中不再使用 `water_bolling_point` 这个常量, 那么是否可以这么简写呢?

```
static_assert(100_c.degree == 373,
              "I'm supposed to work under a standard atmosphere");
```

虽然看起来好像完全没问题, 但实际上不行, 而且编译器给出的错误信息会让人匪夷所思

```
error: unable to find numeric literal operator ‘operator"" _c.degree’
     static_assert(100_c.degree == 373,
                   ^
```

在给出的错误信息中, 编译器显然认为 `_c.degree` 是一个整体, 而尝试去找这样的后缀函数重载. 显然不可能存在这样的重载, 因为后缀算符重载不能作为某个类的成员函数定义, 而且即使作为名字空间内的函数定义, 也不存在如 `100_literal::_c` 的带名字空间的写法.

要解决这个 "错误" 当然不困难, 只要在字面量两边套上一层括号即可, 如 `(100_c).degree`, 这也是推荐的编码方式.

造成以上编译错误的原因也并不是编译器实现本身的问题. 实际上这个问题与编译器对数值字面常量处理有关.

这里举一些数值字面常量的简单例子, 它们都是正确的

```
1e-5
0x1ULL
1e+7L
```

再举一些**错误**的字面常量的例子

```
1..0
1e++5
1e+5.5
```

第一个错误的原因不难发现, 是小数点太多了, 第二个是指数中加号多出来一个, 第三个是指数带了小数点. 总之错误都一目了然.

那么, 各位读者, 若你们认同此处用**一目了然**这个词, 不妨考虑一下, 对于编译器来说是否也应当是一 "目" 了然? 如果编译器要做到一目了然地报错, 应当采取哪些措施呢?

在实现时, 编译器词法分析处理到 `1..0` 有两种选择:

* 采用 "正确" 方式, 将它分解为 `1.` 和 `.0` 两个词法元素 (token), 两者都是正确的字面常量, 之后语法分析时报错
* 用**最长适配** (maximal munch) 策略先把这一整个输入都解析为一个词元, 再分析这个词元, 并报词法错误

在这个简单例子里, 采用两者报错似乎都差不多, 至少数量上都是 1 个错误, 而且错误也应该都比较好懂.

但是后面的例子呢? 比如 `1e++5` 这个, 如果词法分析时一定要正确分词, 那么分得的词元将依次是 `1`, `e`, `++`, `5`, 语法分析器一看这一排什么鬼, 至少会报 2 个语法错误

* 字面常量 `1` 后面不应该跟一个标识符 `e`
* `++` 运算符不是双目运算符之后不能再放一个 `5`

这样就非常地不 "一目了然" 了. 所以在实现时, 编译器往往在词法分析时就尽量采用最长适配策略将一段输入尽可能揉成一个词元, 然后再抽取其中的子项. 对于数值字面量来说, 其规则大致是

* 所有以数字, 或点号加数字开头
* 后面接任意多个数字, 字母, 下划线, 点号, 加号或减号

先姑且全部拿下作为一个数, 然后再慢慢抽取其中的底数指数后缀. 不过这个策略有时就会造成误判, 如 `100_c.degree` 就满足上面这两个条件, 所以前面的底数部分 `100` 解析完之后, `_c.degree` 整个被拿出来当作了一个后缀.

除了以上情形之外, 这种写法也会踩到坑

```
int foo = 0;
int bar = 0xe+foo; // 错误
```

其中 `0xe+foo` 会被认为是一整个字面量, 而非 `0xe` 加上 `foo`. 当然, 在双目运算符前后加上空格是良好编码风格的表现之一, 遵循此风格就不会出现这种错误了.


# 引用类型改动

引用类型是 C++ 类型系统中的一个重要而独特的组成部分. 通过引用, 开发者可以为对象创建别名, 以便高效地使用之.

既有的类型体系中, 引用被二元地分为非 `const` 引用和 `const` 引用, 在一些情况下这种简单的区分会导致误解和误用. 为了使代码在语义上更加明确, C++11 中加入了右值引用和广义引用类型以对应各种不同的语义需求, 并为移动语义和完美转发等特性打下了基础.


## 临时对象调用的重载决议


C++ 中的引用一直以来有个令人困惑的特性, 就是*带有 `const` 限定的引用可以绑定临时对象甚至字面常量*, 如

```cpp
#include <iostream>

void test_ref(int& m)
{
    std::cout << "non-const " << m << std::endl;
}

void test_ref(int const& m)
{
    std::cout << "const " << m << std::endl;
}

int zero() { return 0; }

int main()
{
    int a = 0;
    int const b = 1;
    test_ref(a);      // 输出 non-const 0
    test_ref(b);      // 输出 const 1 : 这两句没有争议

    test_ref(zero()); // 输出 const 0 : 临时对象匹配 const 引用重载
    test_ref(1);      // 输出 const 1 : 字面常量也匹配 const 引用重载

    // 一个特别的规则, const 引用可以显式直接绑定临时对象或字面量
    int const& m = zero();
    int const& n = 1;
    return 0;
}
```

这一规则里, `const` 限定引用实际扮演着两种不同的身份: 对不可修改的值的引用, 还有对临时对象或字面常量的引用. 这就会产生混淆, 进而导致误用. 然而这是为什么呢? 有一个非常朴素的原因, 就是防止临时对象被作为左值赋值. 即防止类似下面的代码编译成功

```cpp
zero() = 1;
```

但这样的防御措施并不完美, 有时反而还会造成更大的混乱, 比如下面这段代码

```cpp
#include <iostream>

struct MyClass {
    // 定义重载分别对应 const 限定和非 const 限定的情况
    void print()       { std::cout << "non const" << std::endl; }
    void print() const { std::cout << "const" << std::endl; }
};

// 同样定义两个全局函数重载, 分别对应 const 限定和非 const 限定的情况
template <typename T>
void p(T& t) { t.print(); }

template <typename T>
void p(T const& t) { t.print(); }

int main()
{
    MyClass().print(); // (a) 直接在临时对象上调用 print() 成员函数
    ::p(MyClass());    // (b) 将临时对象传给全局 p 函数, 由 p 来决议 print() 成员函数调用
    return 0;
}
```

那么这段代码输出是什么呢? 结果可能有些令人惊讶, 是

:::
non const
const
:::

也就是说, (a) 处直接*用临时对象调用其成员函数 `print`, 重载决议使其调用的是无 `const` 版本*; 而在 (b) 处稍作更改, 将临时对象传给全局 `p` 函数, 决议的结果的是参数为 `const` 限定引用的 `p` 函数重载, 进而在 `p` 内用 `const` 限定引用决议出带有 `const` 版本的 `print` 成员函数重载.

这一规则直接导致了一些更离谱的代码, 比如 `operator=` 重载一般都不会有 `const` 限定, 那么下面这种代码完全合法

```cpp
struct IntWrap {
    int x;
    explicit IntWrap(int xx) : x(xx) {}

    IntWrap& operator=(int xx)
    {
        this->x = xx;
        return *this;
    }
};

int main()
{
    IntWrap(10) = 20; // 使用临时对象的 = 算符重载, 可将临时对象放在等号左侧
    return 0;
}

// 更极端的例子
IntWrap& f()
{
    // return IntWrap(0); 不合法, 不能直接返回临时对象
    return IntWrap(0) = 0; // 合法, 因为一次 operator= 调用将返回值 "洗" 成了左值引用
}
```

此大乱之道也, 焉能不正之. 而混乱的根源就是对待临时对象时, *调用成员函数决议重载的规则与调用其他函数决议的规则大相径庭.*

因此, 新标准中增加了针对临时对象和字面量的新的引用类型, 并更改了相应的重载决议规则, 以改正上述这些令人困惑的行为.


## 右值引用与重载决议修正
首先, C++11 中加入了针对临时对象和字面量**右值引用** (rvalue reference) 类型, 这种类型是专门针对临时对象和字面常量的. 如果为一族函数加上*以右值引用为参数的版本*, 那么*使用临时对象作为实参时, 优先决议出的就是这一重载*. 如

```cpp
void test_ref(int& m) { std::cout << "non-const " << m << std::endl; }
void test_ref(int const& m) { std::cout << "const " << m << std::endl; }

// 增加参数为右值引用的重载
// int 的右值引用类型的写法为 int&&
void test_ref(int&& m)
{
    std::cout << "rvalue " << m << std::endl;
}

int zero() { return 0; }

int main()
{
    int a = 0;
    int const b = 1;
    test_ref(a);      // non-const 0
    test_ref(b);      // const 1  : 这两句输出仍然不变

    test_ref(zero()); // rvalue 0 : 临时对象匹配右值引用重载
    test_ref(1);      // rvalue 1 : 字面常量也匹配右值引用重载
    return 0;
}
```

这一类型语法上写为类型名之后加上 `&&` 符号, 如 `int&&` 就是 `int` 类型的右值引用, `std::string&&` 是 `std::string` 的右值引用类型, 等等. 不得不说, 这个符号跟逻辑与运算的操作符完全一样, 不免有时会引起歧义, 就像引用符号 `&` 也是按位与运算符一样. 在编码时, 如果用到双目运算符而非声明引用, 也应当在其前后加上空格 (就像在自定义字面量中所提到的应注意的情况一样). 而在后文叙述中, 本书将尽量以 "右值引用符号" 指代表示右值引用的 `&&` 符号.

另外, 右值引用这一命名的由来是相对于左值引用, 听起来略带一些调侃. 之前已经提到, C++ 的一些特性使得 "左值" "右值" 这些概念实际上没有与等号有左右方向上的对应关系, 仅仅是一个名字而已. 如果可以的话, 读者更应该将其理解成对临时对象的引用.

右值引用除了可以区别于 `const` 限定引用, 在非成员函数的调用时影响重载决议之外, 还有一个好处是, *允许修改其绑定的临时对象*. 这一点其实与从临时对象上调用成员函数, 决议出其非 `const` 限定的重载一样. 或者反过来说, 本来临时对象就应当是可修改的, 在决议非成员函数调用时强制其匹配 `const` 引用并不那么合适. 而且允许修改临时对象, 有时还能提高程序性能, 如

```cpp
#include <vector>
#include <algorithm>
#include <iostream>

std::vector<int> make_vector()
{
    std::vector<int> x{2, 1, 5};
    return x;
}

void output_sorted(std::vector<int> const& v)
{
    std::cout << "use const ref" << std::endl;

    // std::sort(v.begin(), v.end()); // 编译错误: v 是 const 限定的

    // 如果临时对象匹配 const 引用, 那么不能在容器上排序, 必须复制一份
    std::vector<int> u(v);
    std::sort(u.begin(), u.end());
    for (auto x: u) {
        std::cout << x << std::endl;
    }
}

void output_sorted(std::vector<int>&& v)
{
    std::cout << "use rvalue" << std::endl;

    // 而右值引用允许修改引用对象, 故可以直接排序
    std::sort(v.begin(), v.end());
    for (auto x: v) {
        std::cout << x << std::endl;
    }
}

int main()
{
    output_sorted(make_vector());
    return 0;
}

/* 输出

use rvalue
1
2
5

*/
```

而将字面常量绑定到右值引用, 也可以修改, 似乎有些无法说通. 这时可以*将字面常量考虑为由一个函数返回的临时值*, 就不那么难以理解了. 即

```cpp
int&& i = 0;      // 直接把字面常量绑定到右值引用上?
int&& j = int(0); // 实际上等价于这种写法, 看起来构造函数产生的临时对象
```

以上临时对象和字面常量是两种典型的右值, 其它可能是右值的情况也都在下面这个例子中

```cpp
void test_ref(int& m) { std::cout << "non-const " << m << std::endl; }
void test_ref(int const& m) { std::cout << "const " << m << std::endl; }
void test_ref(int&& m)  { std::cout << "rvalue " << m << std::endl; }

struct Point {
    int x;
    int y;

    Point(int x_, int y_): x(x_), y(y_) {}
};

int four()
{
    return 4;
}

int main()
{
    int x = 1, y = 2;

    test_ref(2);                         // rvalue 2 : 字面常数
    test_ref(x + y);                     // rvalue 3 : 原生类型运算
    test_ref(four());                    // rvalue 4 : 函数调用返回的值
    test_ref(Point(5, 6).x);             // rvalue 5 : 临时对象的某个属性

    int six = 6; int const seven = 7;
    // 显式转换非 const 左值引用为右值引用
    test_ref(static_cast<int&&>(six)); // rvalue 6
    // 但无法应用于 const 引用, 即 static_cast<int&&>(seven) 无法编译

    // 虽然 constexpr 常量在编译之后会被编译器优化为字面常量!
    // 并且它本身还可以作为数组长度定义或作为模板实参
    // 但它是 const 限定左值引用
    constexpr int M = 7;
    test_ref(M);                         // const 7

    // 而枚举常量则算是字面常量右值 !
    enum {N = 8};
    test_ref(N);                         // rvalue 8
    return 0;
}
```

区分成员函数是否允许从临时对象上调用, 也是右值引用加入之后一项重要的修订工作. 修订工作的首要一项是, 增加一个语法规则*使得临时对象无法调用某些成员函数*. 它的做法是在对应的成员函数后*加上一个左值引用符号*, 如

```cpp
struct IntWrap {
    int x;
    explicit IntWrap(int xx) : x(xx) {}

    IntWrap& operator=(int xx) & // 限制无法从右值, 也就是临时对象上调用
    {
        this->x = xx;
        return *this;
    }
};

int main()
{
    IntWrap(10) = 20;            // 编译错误, 此 operator= 必须从左值上调用
    return 0;
}
```

不过, 如果不加上这个引用符号, 本着最大限度兼容既有代码的规则, 这样的成员函数仍然可以从临时对象上调用.

当然话说回来, 这种代码毕竟也是极少数, 甚至上面那些极端的示例应该不会出现在生产项目中, 因此也不必太过担心这一规则兼容. 如果一定要针对各种不同的引用类型的成员函数重载, 那么应当用如下的方式编写代码

```cpp
struct MyClass {
    MyClass() {}

    // 在成员函数之后加上右值引用符号
    void print() &&     { std::cout << "rvalue" << std::endl; }

    // 为避免歧义, 成员函数如果有针对右值引用的重载, 在定义针对左值的重载时必须加上 & 符号
    // 对 const 限定的成员函数也一样
    void print() &      { std::cout << "non const lvalue" << std::endl; }
    void print() const& { std::cout << "const lvalue" << std::endl; }
};

int main()
{
    MyClass().print(); // 输出 : rvalue

    MyClass a;
    a.print();         // 输出 : non const lvalue

    MyClass const b;
    b.print();         // 输出 : const lvalue
    return 0;
}
```

以上就是右值引用和相应的重载决议机制加入后, 对现有体系的修正.

最后有一个小问题需要解释: 临时对象是否应该有 `const` 修饰, 换言之, 针对某个类型 `T` 是否应该有接受 `T const&&` 的重载, 以及是否应该有以 `const&&` 限制的成员函数呢? 答案为否. 通常情况下, 不应该为函数返回的对象还加上 `const` 限定, 因此也就不会实际产生 `T const&&` 类型; 而即使有这样的类型, 由于它带有了不可被修改的限制, 因此使用既有的引用类型 `T const&` 处理之, 效果也会一样.



## 左值引用与右值引用的相互转换

由于 C++ 中等号算符是可以重载的, 因此以等号赋值语法来讨论左右值不会有太大意义. 实际上 C++ 的左值概念更多的是基于是否可以取得对象地址, 并在这一地址空间上执行相应的行为来界定的. 并且, 它衍生出了被称之为 **同一性 (identity)** 的概念, 也就是*两个对象引用可以根据其地址是否相同而确定是否引用了同一个对象*.

而 C 和 C++ 均*禁止对临时对象使用取得地址算符* (前置单目 `&` 算符), 无法直接获取地址的表达式当然谈不上同一性, 在 C++11 中这些表达式被称作**纯右值 (pure rvalue)**. 字面常量, 对返回值类型定义为值类型的函数的调用, 各种运算 (包括所有原生对象的算术, 逻辑, 比较运算等), 以及对右值对象的成员, 还包括 lambda 表达式, 都属于纯右值.

同一性的特性还产生了一个 C++ 与 C 行为不一致的地方, 就是 C++ 中对空类型 (没有数据成员或虚函数, 若有父类, 其父类也必须全是空类型) 求 `sizeof` 得到的结果至少为 1, 而 C 中对空结构体求 `sizeof` 得到的是 0. 因此 C++ 可以确保两个对象的地址一定不同. (此外 C++ 中 `struct Empty {} x, y; ptrdiff_t m = &x - &y;` 这样的代码没问题, 但在 C 中会因除零错误而崩溃)

临时对象或字面量都是典型的右值. 而另一种右值则通过非 `const` 限定的左值对象转换而来, 它们被称作**临终值** (eXpiring value 或简写作 **xvalue**). 例如在上一节中提到的方法

```
int six = 6;
test_ref(static_cast<int&&>(six)); // 使用 static_cast 转换得到右值引用
```

当然用户不必每次需要将左值类型转换为临终值都写这么别扭的 `static_cast`, 在标准库中提供了一个函数包装, 它是 `std::move`. 上面的例子中的 `static_cast` 用 `std::move` 替换的等价实现会是这样的

```
int six = 6;
test_ref(std::move(six));
```

调用 `std::move`, 除了让编译器选择右值而不是左值引用的重载, 并没有其它的作用. 不过, 换一个重载在有些情况下大有其作用. 这些用况, 以及为何将左值表达式转换为右值引用的函数称作 `move`, 将在下一章移动语义中重点介绍.

反过来, 右值引用是否可以转化为左值引用呢? 当然可以, 而且不同的是, 甚至都不需要进行一次 `static_cast`. 在 C++11 中规定, 任何带有名字的引用, 这个名字构成的表达式都是一个左值引用, 因为它已经满足同一性的要求, 可以通过名字取得对象地址了 (虽然 C++ 标准没有规定临时对象具体存储在何处).

典型的情况是以函数参数的形式出现. 定义在栈上的局部变量如果是右值引用, 也会受这一规则制约. 例如

```cpp
void test_ref(int& m) { std::cout << "non-const " << m << std::endl; }
void test_ref(int const& m) { std::cout << "const " << m << std::endl; }
void test_ref(int&& m)  { std::cout << "rvalue " << m << std::endl; }

void proxy(int&& g)
{
    test_ref(g);
}

int main()
{
    int&& f = four();
    // 将右值引用传给 test_ref, 匹配的是左值引用重载
    test_ref(f);    // 输出 non-const 4

    // 将右值引用先传给 proxy, proxy 将右值引用形参传给 test_ref
    // 匹配的是左值引用
    proxy(four());  // 输出 non-const 4
    return 0;
}
```

也就是说无论是定义一个具名右值引用还是右值引用作为参数, 用它去调用函数实际匹配的重载都将是左值引用重载, 这是右值应用一个容易误用的特性.

如果需要将右值引用参数还原为一个右值, 则还需要再添加 `std::move` 调用. 如

```cpp
// ...

void proxy(int&& g)
{
    // 将参数 g 传给 std::move, 重新变为临终值
    test_ref(std::move(g));
}

int main()
{
    proxy(four());  // 输出 rvalue 4
    return 0;
}
```

因此在实际项目中*处理临时对象时, 应该立即使用之*, 而不建议在函数的栈中定义右值引用绑定临时对象, 更不应该将右值引用定义为对象成员.


## 广义引用与参数转发

在 C++11 中引入了右值引用来针对临时对象, 但是作为向前兼容, `const` 限定的左值引用仍然可以通配所有引用类型. 不过在新标准中还引入了一个特殊规则, 使得一些泛型引用类型的参数也可以适配任何参数. 这种参数类型被称为**广义引用 (universal reference)** 类型.

使用 `const` 限定的引用类型的缺点是, 无论实参是否为变量, 都因为加上了 `const` 限定而无法被修改了. 而引入广义引用要解决的问题, 就是保持各参数原有的状态.

### 广义引用

广义引用的基本规则是, 如果模板函数的某个参数为引用类型 `T&&`, 并且满足以下几个条件

* 类型 `T` 是这个函数的模板类型参数
* 类型参数没有被用户指定而是由编译器推导

那么此参数类型 `T&&` 是广义引用, 而不是一个右值引用类型.

广义引用类型的形参虽然语法上看起来像右值引用, 但它可以匹配任意类型的实参. 例如

```cpp
template <typename T>
void f(T&& t)   // 参数 T&& 中的 T 是模板函数 f 的模板类型参数
{
    std::cout << t << std::endl;
}

int main()
{
    f(0);       // 输出 0 : 可以匹配右值, 实际 T&& = int&&
    int x = 1;
    f(x);       // 输出 1 : 可以匹配左值, 实际 T&& = int&
    int const y = 2;
    f(y);       // 输出 2 : 可以匹配 const 左值, 实际 T&& = int const&
    return 0;
}
```

不得不说, 由于广义引用与右值引用的语法形式一样, 很容易就出现误解和误用. 比如以下两个很典型的例子, 其中出现的模板参数都**不是**广义引用, 因为它们违反了上述广义引用规则的第一条.

```cpp
template <typename T>
void g(std::vector<T>&& v);
//     ^^^^^^^^^^^^^^^^ 非广义引用而是右值引用; 因为参数类型是 std::vector<T>, 它不是模板类型参数 T

template <typename T>
struct X {
    template <typename U>
    void f(T&& t, U&& u);
    //     ^^^^^ T&& t 不是广义引用而是右值引用类型参数; 因为它不是函数的模板参数而是外层模板类的类型参数
    //           U&& u 是广义引用
};
```

而下面这个例子则演示了编译器是如何应用上述的第二条规则的

```cpp
template <typename T>
void f(T&& t) {} // 类型参数 T&& 定义上满足广义引用的条件

int main()
{
    int i = 0;

    f(i);        // 编译通过: 编译器认为 f 的参数是广义引用, 因此能够接受左值参数

    f<int>(i);   // 编译失败: 由于用户指定了 T = int, 因此编译器认为 f 的形参类型是 int&& 右值, 无法接受左值实参
                 // 即使函数在定义上满足广义引用的条件, 调用函数时也可能违反广义引用的条件
    return 0;
}
```

广义引用的一个直接应用就是在对参数没有具体类型要求的工具函数的场景. 比如用于将左值转换为临终值的 `std::move` 函数的参数就是一个广义引用. 其实现为

```cpp
// bits/move.h:99
template<typename _Tp>
typename std::remove_reference<_Tp>::type&& move(_Tp&& __t) // 此类型是泛型参数, 因此是一个广义引用
        noexcept // 这个简单的工具函数, 它不会抛出异常, 因此加上 noexcept 声明是有必要的
{
    // 使用 static_cast 将引用类型进行转换
    return static_cast<typename std::remove_reference<_Tp>::type&&>(__t);
}

// type_traits:1373
// remove_reference 可用于将任何引用类型还原成其值类型
// 因此 move 的返回值类型就会是 _Tp 类型参数去掉引用符号之后再加上右值引用
template<typename _Tp>
struct remove_reference
{
    typedef _Tp type;
};

template<typename _Tp>
struct remove_reference<_Tp&>
{
    typedef _Tp type;
};

template<typename _Tp>
struct remove_reference<_Tp&&>
{
    typedef _Tp type;
};
```

因此, 即使对一个右值使用了 `std::move` 也无妨, 其结果仍会被正确地当作一个右值对待.

### 引用折叠

在介绍广义引用基本语法时用了如下的例子

```cpp
template <typename T>
void f(T&& t) { std::cout << t << std::endl; }

int main()
{
                     f(0); // T&& = int&&      : 匹配右值引用
    int x = 1;       f(x); // T&& = int&       : 匹配左值引用
    int const y = 2; f(y); // T&& = int const& : 匹配 const 限定左值引用
    return 0;
}
```

这样写注解有一个细节问题, 就是当 `T&& = int&&` 成立时, 是否意味着 `T = int` 的特化; 以及 `T&& = int&` 时, 特化类型又是什么. 在这里解释一下广义引用匹配参数时, 具体的引用推导规则.

广义引用只可能匹配上述三个引用类型而不可能是值类型, 当广义引用匹配一个左值引用时, 推导出的类型实参为相应的左值引用类型; 而当广义引用类型匹配右值引用时, 推导出的类型实参则为相应的值类型, 即

```cpp
f(0);            // T&& = int&&      <=> T = int
int x = 1;
f(x);            // T&& = int&       <=> T = int&
int const y = 2;
f(y);            // T&& = int const& <=> T = int const&
```

反过来看上面结论的话, 就会发现, 当 `T = int` 时意味着, `T&& = int&&`, 这一点没问题, 但 `T = int&` 时, `T&& = int&`, 右值引用符号去哪里了呢?

这就是**引用折叠** (reference collapsing) 的效果. 在 C++ 中, 各种引用类型的叠加并不是做简单的数学运算, 用类型加上引用符号就得到相应的引用类型. 而引用类型相对于指针类型很大的一处不同也在于此: 存在指向指针的指针类型, 但不存在引用另一个引用的引用类型. 如

```cpp
typedef int* int_ptr;
int_ptr* x;           // x 的类型是 int**

typedef int& int_ref;
int_ref& y;           // y 的类型仍然是 int&
```

在这种情况下两个引用符号折叠在一起, 形成 `y` 的最终类型定义. 在 C++11 中加入了右值引用后, 引用折叠扩充成了以下三条规则

* 定义左值引用类型的右值引用, 结果是左值引用; 即 `T&  && => T&`
* 定义右值引用类型的左值引用, 结果是左值引用; 即 `T&& &  => T&`
* 定义右值引用类型的右值引用, 结果是右值引用; 即 `T&& && => T&&`

简而言之只有两个右值引用折叠在一起才会得出右值引用, 其他情况都会是左值引用. 写成代码示例就是

```cpp
#include <iostream>
#include <type_traits> // include is_lvalue_reference : 指出一个类型是否是左值引用
                       //         is_rvalue_reference : 指出一个类型是否是右值引用

int main()
{
    using int_lref = int&;
    using int_rref = int&&; // 使用 using 定义两种引用类型的别名, 然后对别名加上引用符号
                            // 可不能直接写 int& && 这样的类型

    // 输出 1 0 : 折叠为左值引用
    std::cout << std::is_lvalue_reference<int_lref&>::value << ' '
              << std::is_rvalue_reference<int_lref&>::value << std::endl;

    // 输出 1 0 : 折叠为左值引用, 附加上的右值引用符号失效
    std::cout << std::is_lvalue_reference<int_lref&&>::value << ' '
              << std::is_rvalue_reference<int_lref&&>::value << std::endl;

    // 输出 1 0 : 折叠为左值引用, 原有的右值引用符号失效
    std::cout << std::is_lvalue_reference<int_rref&>::value << ' '
              << std::is_rvalue_reference<int_rref&>::value << std::endl;

    // 输出 0 1 : 折叠为右值引用
    std::cout << std::is_lvalue_reference<int_rref&&>::value << ' '
              << std::is_rvalue_reference<int_rref&&>::value << std::endl;
    return 0;
}
```

### 完美转发

在 C++ 中一直有一个需要解决的问题就是让函数具备**完美转发** (perfect forwarding) 一些参数给其他函数的能力. 在设计上, 此功能可用于实现业务代码和非业务代码的分离. 比如

```cpp
// implements 是具体业务逻辑的实现函数
R implements(T const& t);

// 另实现一个包装函数, 包装函数中包含日志与统计
template <typename FuncType, typename ArgType>
auto wrapper(FuncType f, ArgType const& a) -> decltype(f(a))
{
    auto start = time();
    logging("Call implements start at %d", start);

    auto&& r = f(a); // 转发参数给业务逻辑函数

    auto end = time();
    logging("Call implements finished at %d", end);
    function_statistic("implements", end - start);
    return std::move(r);
}

int main()
{
    // 调用处可以这样使用 wrapper 与 implements
    R r = wrapper(implements, T());
    // ...
}
```

在上面的代码片段中, 负责业务逻辑的 `implements` 函数外围的日志和统计代码由 `wrapper` 函数管理. `wrapper` 虽然不会直接用到要向 `implements` 传递的参数, 但由于它要将参数传给 `implements`, 它仍需要一定程度上了解 `implements` 函数的签名.

比如在上面的例子里, 如果以后 `implements` 函数的参数变为非 `const` 的引用, 即声明改成了 `implements(T&)`, 那么 `wrapper` 函数的编译就会因为 `const` 修饰而问题. 或者反过来说, `wrapper` 函数只适合包装那些参数是 `const` 限定引用的函数.

那么, 是否存在更通用的引用参数 (暂且不考虑参数个数的问题) 声明, 使得无论被包装的函数的参数类型如何, 外层的包装函数都可以应对. 这就是参数完美转发要达到的目标.

在 C++11 之前这是无法做到的, 因为通配各种引用的是 `const` 限定引用, 这使得非 `const` 左值也被无故加上了无法修改的限制. 而在 C++11 中, 则可以通过广义应用来定义这样的包装函数.

```cpp
R implements(T const& t);

// 将参数 ArgType&& 的定义转换为广义引用
// 注意, FuncType 也被转换为了广义引用, 这样无论可调用对象实参是一般函数指针, 带有或不带有 const 的函数对象的引用都可适配之
template <typename FuncType, typename ArgType>
auto wrapper(FuncType&& f, ArgType&& a) -> decltype(f(a))
{
    // 调用开始前的工作

    auto&& r = implements(t);

    // 调用结束后的工作

    return std::move(r);
}
```

这样看起来很好. 然而事情不是这么简单, 因为前文中介绍过的具名右值引用的一个特性 --- 形参中的右值引用实际上表现为左值引用 --- 在广义引用的情况下也不例外. 所以看起来在 `wrapper` 传给 `implements` 的是广义引用, 而这些引用本应该保留它们原有的形式, 但实际上它们都会变成左值引用.

不妨来做个简单的实验.

```
#include <iostream>
#include <type_traits>

template <typename T, typename U>
int implements(T&& t, U&& u)
{
    std::cout << "at implements, t is l/r reference: "
              << std::is_lvalue_reference<decltype(t)>::value << ' '
              << std::is_rvalue_reference<decltype(t)>::value << std::endl;
    std::cout << "at implements, u is l/r reference: "
              << std::is_lvalue_reference<decltype(u)>::value << ' '
              << std::is_rvalue_reference<decltype(u)>::value << std::endl;
    return 0;
}

template <typename T, typename U>
int wrapper(T&& t, U&& u)
{
    std::cout << "at wrapper, t is l/r reference: "
              << std::is_lvalue_reference<decltype(t)>::value << ' '
              << std::is_rvalue_reference<decltype(t)>::value << std::endl;
    std::cout << "at wrapper, u is l/r reference: "
              << std::is_lvalue_reference<decltype(u)>::value << ' '
              << std::is_rvalue_reference<decltype(u)>::value << std::endl;
    return implements(t, u);
}

int main()
{
    std::unique_ptr<int> t;
    // 推导出 T 为左值, U 为右值的重载
    wrapper(t, std::unique_ptr<int>());

    /* 输出

    at wrapper, t is l/r reference: 1 0
    at wrapper, u is l/r reference: 0 1
    at implements, t is l/r reference: 1 0
    at implements, u is l/r reference: 1 0

    输出结束 */

    return 0;
}
```

从输出可以看到, 在 `wrapper` 函数里得到的参数类型还是预期的一个左值一个右值, 但是转发到 `implements` 函数里, 就全部成了左值. 这并不是用户希望的行为.

解决这个问题可以借鉴 `move` 的做法, 可以进行 `static_cast` 进行转换. 不过, 由于在 `wrapper` 函数中并不关心传入并转发给 `implements` 函数的 `T` `U` 等引用类型具体是什么, 故针对不同引用类型的 `static_cast` 的结构应该尽可能相似. 其实现方式可能类似这样

```
template <typename T, typename U>
int wrapper(T&& t, U&& u)
{
    std::cout << "at wrapper, t is l/r reference: "
              << std::is_lvalue_reference<decltype(t)>::value << ' '
              << std::is_rvalue_reference<decltype(t)>::value << std::endl;
    std::cout << "at wrapper, u is l/r reference: "
              << std::is_lvalue_reference<decltype(u)>::value << ' '
              << std::is_rvalue_reference<decltype(u)>::value << std::endl;
    return implements(static_cast<T&&>(t), static_cast<U&&>(u));
    //                ^^^^^^^^^^^^^^^^     ^^^^^^^^^^^^^^^^
}
```

为什么是这样的 `static_cast` 呢? 对于 `T = unique_ptr<int>&` 来说, 在它上面附加右值引用符号, 仍然会折叠到 `T&& = unique_ptr<int>&` 左值引用类型, 所以参数 `t` 上附加的 `static_cast` 其实什么都没做; 而对于 `U = unique_ptr<int>` 值类型来说, `U&&` 就是右值引用类型, 那么这次 `static_cast` 等价于对参数 `u` 进行了一次 `move`, 让它还原成了右值引用类型.

当然, 标准库中也提供了转发工具函数, 使得用户不必在代码中写上一堆 `static_cast`. 这个工具函数 `forward` 的声明如下

```
// bits/move.h:74
// 接受左值引用的重载
// 如果按照以上的做法, 只转发广义引用参数, 这一个重载就够了, 因为所有的具名引用都被认为是左值
template<class _Tp>
_Tp&& forward(typename std::remove_reference<_Tp>::type& __t) noexcept; // 与 move 一样不会抛出异常

// :85
// 针对纯右值的重载, 实际几乎用不到, 因为纯右值直接写在实参列表中即可
template<class _Tp>
_Tp&& forward(typename std::remove_reference<_Tp>::type&& __t) noexcept;
```

由于 `forward` 参数列表中使用 `remove_reference` 对模板参数类型 `T` 进行了一些转换, 因此不能直接写 `forward(u)` 来让编译器推导模板参数类型, 需要用户手动加上, 如

```
template <typename T, typename U>
int wrapper(T&& t, U&& u)
{
    // ...

    return implements(std::forward<T>(t), std::forward<U>(u));
    //                ^^^^^^^^^^^^^^^     ^^^^^^^^^^^^^^^
}
```

两次 `forward` 调用的类型特化, 详细解释如下

| `_Tp` | 返回值类型 `_Tp&&` | 参数类型 `std::remove_reference<_Tp>::type&`
| `T = unique_ptr<int>&` | `unique_ptr<int>&` 左值 | `unique_ptr<int>&`
| `U = unique_ptr<int>` | `unique_ptr<int>&&` 右值 | `unique_ptr<int>&`

可以看出, `forward` 是转发不同引用类型的有力工具. 在 "可变参数模板" 一章中将提到, `forward` 结合可变参数模板函数, 还能实现转发任意多个参数的功能.


# 移动语义
本章内容将包含 C++ 中一些非常重要的更新, 它们是移动语义及与之有关的一系列语言语义改造.

C++ 语言中长期以来有个令人困惑的特性: 对象复制构造. 在第一章中简单提到过, 无论什么类型的实例, 默认都是可复制的. 而如果不希望其具有复制的能力, 却反而需要额外编写一些代码.

在这一章中将详细说明这一特性的历史原因, 造成的问题以及在 C++11 中的改进方案. 这些改动造就了更完备的 C++ 语言.



## 对象声明周期语义

### 由历史原因造成的 C++ 基本特性

C++ 最早被作为一门 C with classes 语言被发明出来. 不得不说这一第一印象也成为了对 C++ 最为广泛接受的刻板的印象. 然而在超过 30 年的发展之后, C++ 这门语言有着繁多的语言特性, 是 C 语言无法企及的, 而兼容 C 语言, 也只是 C++ 众多语言特性中的一个部分.

在兼容 C 语言这个部分, C++ 可以利用几乎所有 C 语言的 API, 包括一些操作系统 API. 在其他高级语言中, 调用 C API 可能需要编译封装, 或打包成库, 或以虚拟机接口的形式才能供用户所使用, 而 C++ 代码中却可以几乎没有任何代价地直接调用, 对于开发者而言显然是重大利好. 然而这样做有一些也有一些不妥之处, 最终导致了 C++ 复制构造的产生.

为了实现与 C API 的兼容, *C++ 必须使用与 C 语言一致的栈式空间布局模型*, 即*栈式对象模型*. 这一点与其他许多高级语言不一样. 将对象分配在栈空间内的好处是对其成员的使用皆可以编译为从栈基指针偏移寻址, 执行效率会非常高. 比如以下定义

```cpp
struct Person {
    char name[16];
    int age;
};

int main()
{
    Person p; // 如果认为函数栈空间内定义的第一个对象的地址就是栈基址
    p.name;   // 那么引用 name 属性地址就相当于引用栈基指针
    p.age;    // 引用 age 属性相当于从栈基指针偏移 16 字节
              // 这些偏移量都可以静态给出, 因此执行效率会很高.

    // ...
}
```

当然, 优点往往会伴有缺点, 对于栈式对象模型也不例外: *其不足之处就是光凭栈内静态空间难以处理动态长度的数据*, 譬如, 若须将 `Person` 的 `name` 属性设定为可动态扩展长度的字符串, 则这一段数据所需的地址空间就需要从堆上分配, 而在 C 语言中很麻烦的是, 用户还需要在使用完毕后手动归还这些堆空间.

但若是编写 C++ 程序, 则有更好的方案. 作为个例, 这里使用标准模板库中的 `std::string` 定义 `Person` 的 `name` 属性就能很容易地处理变长字符串. 之所以 `string` 具有这样的能力, 正是其内部管理了一份在堆空间中的动态资源所致. 当空间不够时, `string` 对象可以扩展其持有的空间. 然而, 与 C 中需要用户手动管理资源不同, `string` 将资源归还的行为进行了封装, 对用户而言是透明的, 比如, 在栈区定义一个 `Person` 对象, 会让函数返回后自动执行一些额外的操作

```cpp
struct Person {
    std::string name;
    int age;
};

int main()
{
    Person p;
    std::cin >> p.name;
    // ...
    return 0;
    // 函数结束, 清理在栈上的对象 p:
    //     p.name 持有的资源被自动释放
    //     p.age 是个整数, 不用清理
}
```

这个规则当然不仅仅只被 `string` 所用, 更一般地, 在 C++ 中用于自动处理资源释放语言特性被称之为 "资源获取时初始化" (Resource Acquisition Is Initialization, 缩写为 RAII). 光看这个名字, 并不能很好地在字面上解释其背后的语言特性, 若要完整地说, 之后还应包含半句 "*对象析构时将资源释放*". 换言之, 在 C++ 中, 对于那些持有资源 (堆空间, 文件句柄等) 的对象, *编译器生成的代码*将保证这些**对象所持有的资源的有效期与该对象的生命期严格一致**, 并且在对象生命周期结束时使用指定的方法自动归还这些资源.

具体的做法是用户按照以下规则编写代码

* 在对象的*构造函数或生命周期*过程中获取资源
* 在对象的*析构函数中释放资源*

然后**编译器保证生成的应用程序有以下运行时行为**

* 对象生命周期结束后其*析构函数一定被调用*

在这样的保障下, 对象所控制的资源的自动释放机制得以实现. 这是 C++ 之于 C 语言的本质不同, 甚至是 C++ 相对于其他编程语言的一个独有的性质[[只有 C++, D, Rust 等屈指可数的几个流行语言支持 RAII]], 使得这门没有动态内存回收机制在某些情况下在资源自动回收方面比其它语言表现得更好.

### 对象及资源复制机制

在 C 中, 当一个函数的返回值定义为结构体时, 调用这个函数获得该结构体实例, 其行为是将这个实例的所有数据复制一份: 从被调用函数的栈区复制到调用者栈区. 譬如以下代码示例

```cpp
struct Person {
    char name[16];               // 栈区
    int age;                     // .-------------------.
};                               // |      main()       |
                                 // |                   |
Person read_person()             // | person q -------. |
{                                // | . name:char[16] |<---.
    Person p;                    // | | age:int       | |  |  函数返回时
    fgets(p.name, 16, stdin);    // | |_______________| |  |  整个 Person 对象会被复制
    scanf("%d", &p.age);         // |                   |  |  包括 16 字节的 char 数组
    return p;                    // |-------------------|  |  和一个 int
}                                // |   read_person()   |  |
                                 // |                   |  |
int main()                       // | person q -------. |  |
{                                // | . name:char[16] |----'
    Person q(read_person());     // | | age:int       | |
    // ...                       // | |_______________| |
    return 0;                    // |                   |
}
```

在 `main` 函数中调用了 `read_person` 后, 很有可能这个对象是从 `read_person` 函数中定义的 `p` 中复制数据而产生 `q`.[[聪明的编译器会优化规避类似这样的复制, 这种优化称之为 "返回值优化" 或简称为 RVO (**R**eturn **V**alue **O**ptimization), 但在一些复杂的情况下编译器可能不会贸然进行此类优化]] 对于以上定义的纯粹静态对象而言, 问题不大, 除了程序可能会因为大量的复制行为而变慢.

但如果 `Person` 的定义中包含携带资源的对象呢?

```cpp
struct Person {
    std::string name;
    int age;
};

Person read_person()
{
    Person p;
    std::cin >> p.name;
    std::cin >> p.age;
    return p;
}

int main()
{
    // C++ 亦会将被调用函数栈区内的 p 的数据复制到调用者栈区内的 q 中去
    Person q(read_person());
    // ...
    return 0;
}
```

由于 `Person` 对象会包含一个 `std::string` 对象, 如前所述, 作为控制资源 (堆空间中分配的字符串内容) 的对象, 其生命周期结束之后其持有的资源就失效了, 那么在 `read_person` 函数结束的时候, `p.name` 所包含的资源就被归还了, 那么其包含的 `name` 属性内容如何传递给调用者栈区的 `q.name` 中去呢?

首先, 显然*不可能等到 `p.name` 析构结束后再从 `p.name` 中复制出 `q.name`*, 因为 `p.name` 析构后其持有的资源已经失效, 不可作为复制的来源. 因此这时必然是先复制构造出 `q.name`, 然后再析构掉 `p.name`. 换言之, `p.name` 与 `q.name` 的生命周期会有一点重叠.

然后, 也是更重要的一点, `name` 这个属性是如何复制的? 在解答这个问题时 C++ 引入了有争议性的一个特性: 对象复制构造. 即由用户指定一个资源持有对象的复制行为, 称之为**复制构造函数**, 像 `std::string` 这样的类型, 它的复制构造函数行为被指定为

* 复制目标先分配与复制来源至少一样大的堆空间
* 将构造来源的堆空间上的内容复制到构造目标相应的堆空间上

换言之, 在 `p` 和 `q` 生命周期重叠的这么看似不起眼的一段时间内, 会发生很多事情, 包括新资源分配, 数据复制.

然而这种行为显然是不合理的, 有点像朋友找我借一本书, 我就把这本书带到复印店复印一整本给他, 然后烧了自己手头上这本. 对于字符串这样可以复制的资源来说虽有些蠢但至少还能复制得出副本; 但对于文件句柄, 线程锁, 或者遵守质能守恒的宇宙而言复制是不应发生的. 但是回头看一下这个特性的由来, 又会发现它本是为了兼容 C 在这一情况下的行为, 并且衍生出适用于 C++ 的至少更加安全的资源复制行为.

而不得不说这一兼容的代价是惨重的. 然而实际上, 这些复制行为是 C++ 的日常. 直到 C++11 标准出台.

在上一个标准 C++03 制定之后的 8 年时间里, 修正以上这种无意义的复制行为的补救措施逐步形成文案并被加入了新标准中, 最终形成了 C++11 标准中一个重要的更新: **移动语义** (move semantic). 简而言之, 移动语义允许一份资源从一个对象中**移动**到另一个对象中去, 使得资源可以在不同对象中以较低的运行开销交接, 扩展该资源的有效期.

## 移动构造函数

先来看看几个移动语义运作的例子.

```cpp
#include <iostream>
#include <string>

int main()
{
    std::string s0("hello, move semantic");
    std::string s1(s0);                       // 仍然是复制构造
    s1[7] = 'c';
    s1[9] = 'p';
    s1[10] = 'y';
    std::cout << "s0 => " << s0 << std::endl; // hello, move semantic
    std::cout << "s1 => " << s1 << std::endl; // hello, copy semantic
                                              // 复制构造之后, 两者所控制的资源的地址空间是独立的

    std::cout << std::endl << "000 MOVE CONSTRUCTION" << std::endl;
    std::string s2(std::move(s0));
    //             ^^^^^^^^^       以 move 后的 s0 临终值构造 s2 将会是 "移动构造" (move construction)

    // 具体的原理之后会详细介绍, 这里先看看移动构造之后各个对象的状态
    std::cout << "s0 EMPTY? " << s0.empty() << std::endl; // 1 : s0 在移动构造之后成了空字符串
    std::cout << "s1 => " << s1 << std::endl;             // hello, copy semantic : s1 不变
    std::cout << "s2 => " << s2 << std::endl;             // hello, move semantic : s2 接管了 s0 的内容

    std::cout << std::endl << "111 MOVE ASSIGNMENT" << std::endl;
    s0 = std::move(s1);
    //   ^^^^^^^^^      将 move 后的 s1 赋值给 s0 将会是 "移动赋值" (move assignment)

    std::cout << "s0 => " << s0 << std::endl;             // hello, copy semantic : s0 接管了 s1 的内容
    std::cout << "s1 EMPTY? " << s1.empty() << std::endl; // 1 : s1 在移动构造之后成了空字符串
    std::cout << "s2 => " << s2 << std::endl;
    return 0;
}
```

在这个例子中可以看到, 使用 `s0` 构造 `s1` 使用的仍然是复制构造, 复制之后修改 `s1` 不会对 `s0` 有任何影响; 而使用 `std::move(s0)` 产生 `s0` 的临终值, 用以构造 `s2` 后, `s0` 的内容就移交给了 `s2`, 因而变成了空字符串, 之后使用 `std::move(s1)` 给 `s0` 赋值也类似. 这就是移动构造或者移动赋值会产生的效果. 从此处亦可看出将转换左值表达式为右值引用类型的函数命名为 `move` 的原因, 而 "临终" 这一名字也很贴切地体现出了这一运行结果.

以上例子从表面观察如此, 但并不能保证这些字符串所控制的堆空间没有真正复制过, 要确信这一点, 可以用其他 STL 容器, 比如 `vector` 来验证之

```cpp
#include <iostream>
#include <vector>

// 探测复制行为的类型
// 发生普通构造, 复制构造, 析构时, 都会输出一些信息
struct CopyProbe {
    int value;

    explicit CopyProbe(int v)
        : value(v)
    {
        std::cout << "Construct " << this << " value=" << this->value << std::endl;
    }

    CopyProbe(CopyProbe const& rhs)
        : value(rhs.value)
    {
        std::cout << "Copy to " << this << " from " << &rhs
                  << " value=" << this->value << std::endl;
    }

    ~CopyProbe()
    {
        std::cout << "Destruct " << this << " value=" << this->value << std::endl;;
    }
};

int main()
{
                                                         // 以下为相应语句之后可能的输出
    CopyProbe p0(0);                                     // Construct 0xffefffbe0 value=0
    CopyProbe p1(1);                                     // Construct 0xffefffbf0 value=1

    std::vector<CopyProbe> v0;
    v0.reserve(10); // 预留一些空间, 避免追加元素时
                    // 触发重新分配, 引起元素复制输出
    v0.push_back(p0);                                    // Copy to 0x5c3a040 from 0xffefffbe0 value=0
    v0.push_back(p1);                                    // Copy to 0x5c3a044 from 0xffefffbf0 value=1

    std::cout << std::endl << "000 COPY CONSTRUCTION"
              << std::endl;                              // 000 COPY CONSTRUCTION
    std::vector<CopyProbe> v1(v0);                       // Copy to 0x5c3a0b0 from 0x5c3a040 value=0
                                                         // Copy to 0x5c3a0b4 from 0x5c3a044 value=1
    std::cout << "v0.size() " << v0.size() << std::endl; // v0.size() 2
    std::cout << "v1.size() " << v1.size() << std::endl; // v1.size() 2

    std::cout << std::endl << "111 MOVE CONSTRUCTION"
              << std::endl;                              // 111 MOVE CONSTRUCTION
    std::vector<CopyProbe> v2(std::move(v0));            //          (((没有输出)))
    std::cout << "v0.size() " << v0.size() << std::endl; // v0.size() 0
    std::cout << "v1.size() " << v1.size() << std::endl; // v1.size() 2
    std::cout << "v2.size() " << v2.size() << std::endl; // v2.size() 2

    std::cout << std::endl << "END" << std::endl;        // END
    return 0;                                            // Destruct 0x5c3a040 value=0
}                                                        // Destruct 0x5c3a044 value=1
                                                         // Destruct 0x5c3a0b0 value=0
                                                         // Destruct 0x5c3a0b4 value=1
                                                         // Destruct 0xffefffbf0 value=1
                                                         // Destruct 0xffefffbe0 value=0
```

从这个例子中可以看到, 在向 `v0` 中添加元素时, 还是会使用对象复制的方式将副本加入容器中; 使用 `v0` 构造 `v1` 时, 因为是复制构造, 所以 `v0` 中的两个元素各复制了一次, 输出了两行; 而之后使用移动构造的方式用 `v0` 构造 `v2` 时则没有输出, 说明移动构造时至少元素复制被避免了.

### 右值引用与移动函数

从代码表象上, 复制 `vector` 和移动 `vector` 的差别就在于是否对构造参数使用 `std::move` 这个函数. 这是 C++ 向前兼容的结果: 默认写法产生的行为仍然是复制, 确保以前的代码仍然可以正常工作. 而使用 `std::move` 只是为了产生一个右值引用类型.

之前介绍过, 右值引用是 C++11 中新引入的一种针对函数返回的临时对象的引用, 或从一个非 `const` 左值引用上强行转化而来, 以匹配接受右值引用参数的函数重载. 当然, 构造函数重载和 `operator=` 算符重载也都算是函数重载. 那么, 若这些特别的函数有接受右值引用类型参数的重载, 在使用右值实参进行重载决议时就会产生上述效果. 而这些特别的函数, 在 C++11 中则被命名为**移动构造函数 (move constructor)** 和**移动赋值 (move assignment) 算符重载**.

不难想象, 它们在 `vector` 中的声明应写作如下形式

```cpp
struct vector {
    vector(vector&& src);            // 移动构造函数
    vector& operator=(vector&& src); // 移动赋值算符重载
};
```

而其他类型的移动构造函数和移动赋值算符重载也类似.

当使用左值表达式去调用某个有重载函数时, 那么将匹配的是左值引用的重载, 如上面例子中直接使用 `v0` 去构造 `v1`, 就会匹配到复制构造函数. 相对地, 如果需要匹配移动构造函数, 就需要产生一个右值引用类型去匹配移动构造函数.

当然, 更典型的情况应该是针对临时对象的纯右值引用: 使用函数返回的临时对象去构造另一对象, 将优先匹配移动构造函数. 如下面这样的代码

```cpp
std::vector<int> make_some_vector()
{
    std::vector<int> r;
    // ...
    return std::move(r);
}

int main()
{
    std::vector<int> s(make_some_vector());
    // ...
}
```

在 `make_some_vector` 函数内很明显地使用 `std::move` 作用于即将返回的对象 `r`, 那么将 `r` 传出毫无疑问是移动构造; 而在 `main` 函数中, 使用 `make_some_vector()` 调用得到的返回值, 也就是一个临时对象作为构造函数参数, 同样会匹配 `vector` 的移动构造函数. 即上面这样的代码不会产生任何 `vector` 的复制. 本章开头所谈到的那些问题至此已经完全解决了.

对于那些没有定义移动构造函数的类型而言, 类似上述代码中以函数返回值作为构造参数的行为, 将仍然以复制构造函数作为备选匹配.

那么移动行为要如何实现呢? 这一点不妨来看看标准库容器是如何实现的. 以下便选取 `vector` 的源代码作为范例.

### `vector` 的存储结构与移动构造函数实现

`std::vector` 也许是 STL 中最常用的线性容器. 它有非常好的尾端插入效率和极快的随机寻访能力, 适用于不少常见场景. 从这些特性上不难猜测 `vector` 是对动态可变数组的封装, 实际上也正是如此. 以下是 `vector` 的存储结构的一种实现

```cpp
// bits/stl_vector.h:71
// vector 的基类, 将 vector 中管理堆空间资源的部分剥离到此基类中
template<typename _Tp, typename _Alloc>
struct _Vector_base {
    // :80
    // vector 数据存储结构 _Vector_impl 定义
    // 此内部类继承的 _Tp_alloc_type, 故也会被当作配置器使用
    // 此内部类中只定义了无参构造函数, 而没有其他构造函数, 也不包含显式析构函数
    // 这样做是为了让这个内部类非常单纯地仅仅处理数据元素
    struct _Vector_impl 
        : public _Tp_alloc_type
    {
        pointer _M_start;
        pointer _M_finish;
        pointer _M_end_of_storage;

        // :86
        // 在默认构造函数里, 仅仅是将三个指针都初始化为 0 (即 NULL)
        _Vector_impl()
            : _Tp_alloc_type()
            , _M_start(0)
            , _M_finish(0)
            , _M_end_of_storage(0)
        {}

        // :95
        // 从配置器类型引用构造, 仅初始化配置器部分
        // 三个成员指针仍然是被设置为空
        _Vector_impl(_Tp_alloc_type&& __a)
            : _Tp_alloc_type(std::move(__a))
            , _M_start(0)
            , _M_finish(0)
            , _M_end_of_storage(0)
        {}

        // ..
    };

    // :164
    // 使用以上内部类作为成员
    _Vector_impl _M_impl;

    // ...
};

// :208
// 以 protected 方式继承上述类型, 作为最终暴露给用户使用的 vector 模板
template <typename _Tp, typename _Alloc = std::allocator<_Tp>>
class vector
    : protected _Vector_base<_Tp, _Alloc>
{
    // :232
    typedef size_t size_type;

    // :644
    // 获取元素个数, _M_finish 与 _M_start 之差
    // _M_start 标记了元素存储的开始位置
    // _M_finish 标记了元素存储结束位置
    size_type size() const _GLIBCXX_NOEXCEPT
    {
        return size_type(this->_M_impl._M_finish - this->_M_impl._M_start);
    }

    // :724
    // 获取分配的存储容量, _M_end_of_storage 与 _M_start 之差
    // _M_start 亦标记了分配的空间的开始位置
    // _M_end_of_storage 标记了分配的空间结束位置
    size_type capacity() const _GLIBCXX_NOEXCEPT
    {
        return size_type(
            this->_M_impl._M_end_of_storage - this->_M_impl._M_start);
    }

    // ...
};
```

从 `size()`, `capacity()` 的实现可以看出, 当有元素存储时, 这些成员所标记出的连续线性的 `vector` 存储结构大致如下

:::
            _M_finish ----.
_M_start                  |             _M_end_of_storage
   |                      V                 |
   '->+---+---+---+---+---+---+---+---+<----'
      | E | E | E | E | E | - | - | - |
      +---+---+---+---+---+---+---+---+
      | <---- size -----> |           | size() 求得的元素个数
      | <-------- capacity ---------> | capacity() 求得的所分配的空间大小
:::

在观察了 `vector` 的存储结构之后, 现在就来看看 `vector` 是如何实现其移动构造函数的. 如之前所说, 大部分情况下用户从函数内返回一个 `vector` 对象并不希望它的内容被复制一份, 这个其实并不难做到, 代码如下

```cpp
class vector
    : protected _Vector_base<_Tp, _Alloc>
{
    // bits/stl_vector.h:217
    // 基类的简洁的别名
    typedef _Vector_base<_Tp, _Alloc> _Base;

    // :327
    // vector 移动构造函数定义
    // 函数体并没有内容, 直接使用基类的移动构造函数即可
    vector(vector&& __x) noexcept
        : _Base(std::move(__x))
    {}

    // ...
};

struct _Vector_base {
    // :142
    // 在基类的构造函数中, 让 _Vector_impl 配置器的部分进行移动构造
    // 这样构造之后, _Vector_impl 的三个成员指针都是空值
    // 而数据部分并非传入 _Vector_impl 构造函数, 而是使用其 swap 函数
    _Vector_base(_Vector_base&& __x)
        : _M_impl(std::move(__x._M_get_Tp_allocator()))
    {
        this->_M_impl._M_swap_data(__x._M_impl);
    }

    struct _Vector_impl {
        // :101
        // 在上面 _Vector_base 移动构造函数中调用的 _M_swap_data 函数的定义如下
        void _M_swap_data(_Vector_impl& __x)
        {
            std::swap(_M_start, __x._M_start);
            std::swap(_M_finish, __x._M_finish);
            std::swap(_M_end_of_storage, __x._M_end_of_storage);
        }
    };

    // ...
};
```

以上代码中可以看出 `vector` 的移动构造函数转调了其基类 `_Vector_base` 的移动构造函数, 后者的移动构造函数实现中, `_M_impl` 成员在初始化列表中使用的构造函数重载仅初始化了配置器部分, 这一点并不用太多关心, 而 `_M_impl` 的各数据部分仍然是全空, 也就是说此时负责数据结构的 `_M_impl` 仍然是一个空容器; 紧接着调用 `_Vector_impl::_M_swap_data` 函数, 此函数完成的工作一目了然: 三次 `std::swap` 将当前容器的指针与目标容器的指针值对换, 那么当前的 `_M_impl` 的内容就会是参数容器的数据, 而参数容器的数据则被交换为当前的, 而当前的容器数据在前面一步初始化时被设为空, 所以在移动构造结束后, 作为参数的容器会成为一个空的容器.

由于右值引用类型的参数是一个可修改的引用类型, 在上面的代码中, 它的成员可以被用于 `swap` 交换. 实际上, 所有移动构造函数的实现原理都是修改来源参数, "窃取" 其中的资源为自身所用, 而让来源参数进入 "空" 的状态. 不过请注意, 虽然在代码实现中移动构造通过交换两个容器的数据内容使得移动的来源回归到刚初始化的状态, 但标准中并不保证这一点, 而是规定作为移动来源的对象会进入一个可用但不确定的状态, 在下一次使用之前, 须调用容器的 `clear()` 函数重置其状态, 或对其进行赋值. 一般而言, 最好不要再使用它.^[[以交换成员的方式实现移动构造函数, 甚至也不是最优的方式. 考虑到 `swap` 的实现, 每交换一对成员需要三次赋值, 并不经济.]]

另外需要注意的是, 如果使用 `auto` 类型推导从右值初始化对象, 那么会优先调用移动构造函数, 并且定义出对象类型, 而非右值引用类型. 比如

```cpp
std::vector<int> create_vector() { return std::vector<int>{23, 29, 31, 37}; }

int main()
{
    auto x = create_vector();            // x 类型为 vector<int>, 从临时对象移动构造
    std::cout << x.size() << std::endl;  // 4

    auto y = std::move(x);               // y 类型为 vector<int>, 从 x 移动构造
    std::cout << x.empty() << std::endl; // 1 : 作为移动来源的 x 失去其中元素的控制权
    std::cout << y.size() << std::endl;  // 4 : 这些元素全部转交给 y
    return 0;
}
```

## 自动资源管理指针模板类型

上一节谈到了 STL 中具有代表性的容器 `vector` 实现移动构造函数的一种方式, 实质上是通过类似 `swap` 的机制将构造来源容器的内容交换给新构造的容器. 如果读者回忆一下, 可能立即会想到在 C++11 标准出台之前有一个模板类型就具有这样类似的行为, 它就是 `auto_ptr`.

这个来自上世纪的指针模板类型有一个诡异特性就是它在看起来被复制的时候实际上会发生移动, 如以下这段示例

```
std::auto_ptr<int> a(new int(91));
std::auto_ptr<int> b(NULL);

std::cout << (b.get() == NULL) << std::endl; // 1
std::cout << *a << std::endl;                // 91

b = a;

std::cout << *b << std::endl;                // 91
std::cout << (a.get() == NULL) << std::endl; // 1 : "赋值" 给 b 之后, a 就成了空指针
```

这个特性的初衷就是为了让一份资源同一时间只有一个, 因此当使用一个 `auto_ptr` 对象去构造另一个 `auto_ptr` 对象, 或像上面代码里这样使用赋值运算符时, 作为参数, 也就是指针原来的持有者会被设置为空值.

如果这样能够工作那当然是最好, 然而不要孤立地看这一小段代码, 若一个场景需要不定个数的 `auto_ptr`, 编写代码时可能会考虑使用一个 STL 容器如 `vector` 存储它们, 但即使只写这么三行代码

```
std::vector<std::auto_ptr<int> > x;
std::auto_ptr<int> e(new int(91));
x.push_back(e);
```

编译器便会报错: `vector` 在构造元素时无法将 `T const&` 转换成 `T&` 其中 `T` 是 `std::auto_ptr<int>`. 其中原因也很容易看出来, C++11 之前, `vector::push_back` 会以复制的方式传入的元素放入存储区内, 即要求模板参数类型 `T` 具有 `T(T const&)` 的复制构造函数定义, 而 `auto_ptr` 没有这一复制构造函数重载. 更确切地说, `auto_ptr` 正是被设计得不具备这一定义, 实际上, 它的看起来像复制构造的构造函数定义与一般意义上的复制构造函数截然不同, 源代码如下

```cpp
// backward/auto_ptr.h:86
template<typename _Tp>
class auto_ptr
{
private:
    _Tp* _M_ptr;
public:
    typedef _Tp element_type;

    // :112
    // 要求可以修改参数引用的 "复制" 构造函数
    auto_ptr(auto_ptr& __a) throw()
        : _M_ptr(__a.release())
    {}

    template<typename _Tp1>
    auto_ptr(auto_ptr<_Tp1>& __a) throw()
        : _M_ptr(__a.release())
    {}

    // :135
    // 要求可以修改参数引用的赋值算符重载函数
    auto_ptr& operator=(auto_ptr& __a) throw()
    {
        reset(__a.release());
        return *this;
    }

    template<typename _Tp1>
    auto_ptr& operator=(auto_ptr<_Tp1>& __a) throw()
    {
        reset(__a.release());
        return *this;
    }

    // :170
    ~auto_ptr()
    {
        delete _M_ptr;
    }

    // :224
    element_type* release() throw()
    {
        element_type* __tmp = _M_ptr;
        _M_ptr = 0;
        return __tmp;
    }

    // :239
    void reset(element_type* __p = 0) throw()
    {
        if (__p != _M_ptr) {
            delete _M_ptr;
            _M_ptr = __p;
        }
    }
};
```

这段代码摘选了 `auto_ptr` 中一些构造函数与相关成员函数的实现, 可以看到 `auto_ptr` 既不需要空间配置器也不支持设定指针释放方法, 析构函数实现中指明了该指针最终会被 `delete` 掉的命运. 代码很容易读懂, 唯一需要注意的就是之前说到的, 它并没有一般意义上的复制构造函数, 这里列出的两个构造函数以及两个 `operator=` 的重载都要求传入参数是一个非 `const` 引用, 以便在新对象构造完毕或赋值完毕后重置来源对象的指针为空.

### 指针语义

在介绍 C++11 标准中引入了新的替代方案之前, 先说说为什么自动释放资源的指针类型很重要, 或者反过来说为什么尽可能**不要**在代码中使用裸指针类型. 原因是不利于代码阅读. 比如这个 API

```cpp
struct hostent {
   char  *h_name;
   char **h_aliases;
   int    h_addrtype;
   int    h_length;
   char **h_addr_list;
};

struct hostent *gethostbyname(const char *name);
```

它返回一个指针, 这样的声明会让用户对返回值心存顾虑, 得继续看一下文档该怎么处理这个指针, 比如当上下文结束之后是否需要释放之类的; 当然更糟糕的是这个指针指向的结构体里有相当多的指针甚至指针的指针, 是否需要对它们进行一一释放? 换句话说, 这个 API 并不能很好地自文档化, 除非改名字叫

```cpp
struct hostent *gethostbyname_returns_pointer_to_static_data_so_dont_free(const char*);
```

但如果这是一个 C++ 风格的 API, 倘若使用过时的 `auto_ptr`, 对于用户而言仍会是非常易懂的

```cpp
auto_ptr<struct hostent> gethostbyname(const char *name);
```

如果返回值是这么声明的, 作为调用者当然立即知道要怎么去处理.

而封装的指针类型能与容器配合产生更好的可读性也是基于此原因. 假如在代码里看到一个这样的类定义

```cpp
class InputFiles {
    std::vector<std::istream*> files;
public:
    void add(std::istream* i)
    {
        files.push_back(i);
    }

    // ...

    ~InputFiles();
};
```

成员 `files` 中也许有成吨的指针, 但用户并不知道每个指针来自于哪里, 也不能确定在 `InputFiles` 的实例析构时这些指针指向的对象是否会被自动 `delete`, 自然也无法确定能否将 `std::cin` 的地址放进去, 等等, 除非阅读了文档甚至阅读了整个 `InputFiles` 析构有关的实现.

如果定义是这样就太赞了

```cpp
class InputFiles {
    std::vector<std::auto_ptr<std::istream> > files;
public:
    void add(std::auto_ptr<std::istream> i)
    {
        files.push_back(i);
    }
};
```

以上定义可以一目了然地自诠释 `files` 里的所有元素会随着 `InputFiles` 析构而析构, 只剩下一个问题: 它无法编译.

### `unique_ptr`

如上所述的这样, 在 C++11 标准之前自文档性和编译性似乎是有矛盾的, 而这一点在移动语义和 `unique_ptr` 引入后被改变了. 这个新引入的模板类型的主要用途便是*自动地管理控制权单一的一个指针或一个动态数组*. 例如, 它可以被以如下方式使用

```cpp
#include <memory>
#include <vector>
#include <fstream>

int main()
{
    // 利用 unique_ptr 管理一个 new 获得的对象地址, 与 auto_ptr 功能类似
    std::unique_ptr<int> one(new int(1));

    // 利用 unique_ptr 管理一个 new 获得的数组地址, 这一点 auto_ptr 无法做到
    std::unique_ptr<int[]> int_arr(new int[10]);

    // 使用对象池来管理某个类型的对象的方案
    struct ObjectInPool {
        static ObjectInPool* create()
        {
            // 创建对象
            return new ObjectInPool;
        }

        static void destroy(ObjectInPool* obj)
        {
            // 销毁对象
            delete obj;
        }
    private:
        ~ObjectInPool() {}
    };
    // 那么此时 unique_ptr 类型声明需要指定第二个模板参数
    // 并且在构造时传入相对应的函数作为第二参数
    std::unique_ptr<ObjectInPool, void(*)(ObjectInPool*)> obj(
            ObjectInPool::create(), ObjectInPool::destroy);

    // 从一个 unique_ptr 构造另一个 unique_ptr
    // 编译错误! unique_ptr 并没有从左值或 const 限定左值引用构造的函数重载
    std::unique_ptr<int> two(one);
    // 正确, unique_ptr 支持以右值引用类型进行移动构造
    std::unique_ptr<int> three(std::move(one));

    // 将 unique_ptr 作为 vector 的元素使用可行
    // 因为 vector::push_back 有接受右值引用的重载
    std::vector<std::unique_ptr<std::istream>> files;
    files.push_back(std::unique_ptr<std::istream>(
            new std::ifstream("hello.txt", std::ifstream::in)));
    return 0;
    // 以上所有栈区的 unique_ptr 和被包含在 vector 中的 unique_ptr 都会析构并自动释放其控制的资源
}
```

与 `auto_ptr` 相比, `unique_ptr` 除了提供了更加灵活的析构时行为覆盖机制, 还可以作为 `vector` 或其他 STL 容器的模板参数使用 (当然这个特性得益于所有 STL 容器都支持使用移动构造添加元素, 后文将提到).

现在来一探 `unique_ptr` 的实现. 首先是默认的指针销毁函数包装类型

```cpp
// bits/unique_ptr.h:53
template<typename _Tp>
struct default_delete
{
    // ...

    // :62 对 delete 的包装
    void operator()(_Tp* __ptr) const
    {
        // 判定模板参数类型 _Tp 是否已经给出完整定义
        static_assert(sizeof(_Tp) > 0, "can't delete pointer to incomplete type");
        delete __ptr;
    }
};
```

它以及代码中后面一个针对数组类型的模板偏特化是 `unique_ptr` 的官方指定默认第二模板参数类型; 而主菜 `unique_ptr` 的主要成员函数则如下

```cpp
// : 108
template <typename _Tp, typename _Dp = default_delete<_Tp> >
class unique_ptr
{
    class _Pointer {
        template<typename _Up>
        static typename _Up::pointer __test(typename _Up::pointer*);

        template<typename _Up>
        static _Tp* __test(...);

        typedef typename remove_reference<_Dp>::type _Del;
    public:
        typedef decltype(__test<_Del>(0)) type;
    };

    // : 126
    // 将指针类型和删除行为类型定义为一个整体 tuple
    //     tuple 将在后面的可变参数模板章节中介绍; 以下这种情况可以认为它等同于一个 std::pair
    typedef std::tuple<typename _Pointer::type, _Dp>  __tuple_type;
    __tuple_type _M_t;
public:
    typedef typename _Pointer::type pointer;
    typedef _Tp element_type;
    typedef _Dp deleter_type;

    // ...

    // 从裸指针构造, 接管这个指针并默认构造一个删除处理类型对象
    explicit unique_ptr(pointer __p) noexcept
        : _M_t(__p, deleter_type())
    {
        static_assert(!is_pointer<deleter_type>::value,
                      "constructed with null function pointer deleter");
    }

    // ...

    // :415
    // 获取指针
    // std::get<0> 是从 tuple 类型中取得相应位置的元素的方法
    // 若将 _M_t 看作一个 std::pair, std::get<0>(_M_t) 等价于 _M_t.first
    pointer get() const noexcept
    {
        return std::get<0>(_M_t);
    }

    // :248
    // 将指针的控制权交给调用者, 并重置此 unique_ptr 为空
    pointer release() noexcept
    {
        pointer __p = get();
        std::get<0>(_M_t) = pointer();
        return __p;
    }

    // :159
    // 移动构造函数
    // 令参数交出其内含指针的控制权, 用于初始化自身
    // 对于构造 deleter_type 使用到的 std::forward 函数会在后文中详细介绍
    unique_ptr(unique_ptr&& __u) noexcept
        : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter()))
    {}

    // :236
    // 获取 deleter; std::get<1> 相当于取 std::pair 的 second 成员
    deleter_type& get_deleter() noexcept
    {
        return std::get<1>(_M_t);
    }

    // :180
    // 析构函数: 若有必要, 删除指针指向的对象
    ~unique_ptr() noexcept
    {
        auto& __ptr = std::get<0>(_M_t);
        if (__ptr != nullptr)
            get_deleter()(__ptr);
        __ptr = pointer();
    }

    // :273
    // 删除复制构造函数和复制赋值算符
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
};
```

以上. `unique_ptr` 的使用方式以及代码实现中关于指针控制权管理和移交的部分并没有太难以理解的部分, 然而它无疑是 C++11 中非常重要的一个进步. 回顾这门脱胎于 C 的语言, 在 C 之上又增加了很多包装, 这些包装并不是为了显示华丽的技巧, 而往往是为了代码的可读性, 即代码应该一定程度上不需要注释就能表达清楚自身的作用. C++ 中引入 `std::string` 类型去替代 `char*`, 因为后者不能很好地表达它到底是一个字符串还是单纯的一个字符的地址; 而 C++ 中又引入引用类型 `char&` 来确定地表达这是一个字符的引用, 这是在类型系统上 C++ 做出的努力. 而在资源管理方面, C++ 做出的努力就是 `unique_ptr`, `shared_ptr` 等这些自动指针类型替代裸指针类型来明确其控制权.

### 容器元素类型的需求

在上文中提到了*所有 STL 容器都支持使用移动构造添加元素*, 这一点用标准的语言来说是元素类型是 "可移动构造的" (move-constructible) 或 "可复制构造的" (copy-constructible). 标准库中甚至提供了一些这样的类型判定工具, 如

```cpp
#include <memory>
#include <type_traits>

static_assert(std::is_move_constructible<std::auto_ptr<int>>::value,
              "auto_ptr is not move-constructible");
static_assert(std::is_copy_constructible<std::auto_ptr<int>>::value,
              "auto_ptr is not copy-constructible"); // 这一句报错
```

这段代码编译时, 编译器便会指出第二个 `static_assert` 的条件不满足. 但第一个 `static_assert` 没有报错, 是否意味着 `auto_ptr` 是可移动构造的因而可以当作 `vector` 的参数呢?

确实, 在代码中单独写上一行 `std::vector<std::auto_ptr<int>> x;` 的定义并不会引起编译错误, 甚至一些情况下使用 `push_back` 也不会引起编译错误, 如

```cpp
// 单独一个定义, 不会编译错误
std::vector<std::auto_ptr<int>> x;

// 使用右值 push_back 也不会引起编译错误
x.push_back(std::auto_ptr<int>(new int));

// 使用左值 push_back 才会引起编译错误
std::auto_ptr<int> m(new int);
x.push_back(m);
```

所以需要说明的是, `vector` 或其他容器并不是要求只要元素满足可移动构造或可复制构造两个特性之一便可, 并且不同的成员函数的使用方式对类型参数的要求可能是不同的. 一般而言, STL 容器对元素类型的基本要求是 "可擦除的" (erasable); 而要调用 `push_back` 则需要右值参数满足可移动插入 (move-insertable) 或其他参数满足可复制插入 (copy-insertable). 这些概念 (C++ concepts) 的定义实际上与一连串有些冗长的 `allocator_traits` 有关, 这里就不展开介绍了. 而上面例子里最后一次调用 `push_back` 出错就是因为左值的 `auto_ptr` 不满足可复制插入的概念.

### 在容器中存储引用

对象引用 (如 `std::string&` 类型) *并不满足以上容器对元素的移动或复制的要求, 因而无法声明一个 `std::vector<std::string&>` 的容器实例*. 这是由于 C++ 的设计, 引用在初始化的时候必须指定所引用的对象, 并且之后不能再变更. 如

```cpp
std::string message("hello, world");
std::string& ref_to_msg = message;

std::string another_message("nihao, shijie");

// 此处的等号并不能将引用变更为指向 another_message
// 而是等价于调用被引用的 message.operator=(another_message)
ref_to_msg = another_message;
```

相对而言, 裸指针类型却都是完完全全的值类型, 这一点上无疑引用与指针的语义有天壤之别. 而要表现一个存储 "弱" 引用的容器, 自然要借助一些包装类型.

在 C++11 中, 标准库引入了一个模板类型 `reference_wrapper` 来替代引用本身的语义, 其目的明晰, 用法简单, 虽然名字略长, 不便书写. 如

```cpp
#include <functional> // reference_wrapper, ref, cref
#include <iostream>
#include <vector>
#include <string>

int main()
{
    std::string message("hello, world");
    std::string message_pinyin("nihao, shijie");

    std::vector<std::reference_wrapper<std::string>> messages;
    // std::ref 构造一个相应类型的 std::reference_wrapper 对象 (如 std::make_pair 之于 std::pair)
    messages.push_back(std::ref(message));
    messages.push_back(std::ref(message_pinyin));

    // get() 获得引用; 此处赋值等价于赋值给 message
    messages[0].get() = "Hello, world!";
    std::cout << message << std::endl;         // 输出: Hello, world!

    // const 限定引用包装
    //   对 reference_wrapper 的参数添加 const
    //   使用 cref 构造引用对象
    std::reference_wrapper<std::string const> const_msg = std::cref(message);
    // const_msg.get().clear(); // 编译错误: get() 获取的是 const 限定引用
    std::cout << const_msg.get() << std::endl; // 输出: Hello, world!

    // 通过赋值可以让 reference_wrapper 绑定到另一个对象上
    const_msg = message_pinyin;
    std::cout << const_msg.get() << std::endl; // 输出: nihao, shijie

    // 上面一句变更 reference_wrapper 绑定的对象不会影响它原来绑定的对象
    std::cout << message << std::endl;         // 输出: Hello, world!
    return 0;
}
```

当然, 使用 `reference_wrapper` 时, *一定要确保其绑定的对象本身没有被析构掉, 否则会产生未定义行为*.

除了兼容容器元素之外, `std::reference_wrapper` 以及 `std::ref`/`std::cref` 也广泛用于各种可能需要传递引用的场景, 在后文的可变参数模板, 多线程等部分都会提到它们. 而所有这些指针和引用的封装类型的引入使绝大部分情形都可以使用对象而不是裸指针来编写程序:

* 若对象有严格的单一控制权, 使用 `unique_ptr`
* 若对象可能会由多个控制者决定生命周期, 使用 C++11 中引入的 `shared_ptr`
* 若只引用而并不具有对象的控制权, 使用引用; 如果要作为容器元素, 或对象成员等可更改绑定的场景, 使用 `reference_wrapper`

剩下的一小部分? 当与 C API, 特别是操作系统 API 交互时会有必要用到裸指针, 不过这时最好提供一个 C++ 的包装.


## 函数隐式生成规则

C++ 有一些规则会隐式地为用户生成复制构造函数, 复制赋值算符重载或析构函数, 在引入移动语义之后, 这些隐式生成还扩展到了移动构造函数与移动赋值算符重载. 本节中就来对 C++ 标准中这些部分加以说明.

在 C++11 标准之前, 有个 "三法则" (the rule of three) 约定, 指的是以下三个函数

* 析构函数
* 复制构造函数
* 赋值算符重载

*需要被定义, 如果用户没有定义它们, 则编译器会隐式生成它们*. 如

```cpp
struct AllImplicit {
    int x;
    int y;

    AllImplicit(int xx, int yy)
        : x(xx)
        , y(yy)
    {}
};

int main()
{
    AllImplicit a(10, 20);
    AllImplicit b(a);      // 调用隐式生成的复制构造函数
    AllImplicit c(0, 0);
    c = a;                 // 调用隐式生成的赋值算符重载

    std::cout << a.x << ',' << a.y << std::endl;
    std::cout << b.x << ',' << b.y << std::endl;
    std::cout << c.x << ',' << c.y << std::endl;

    return 0;
    // 调用隐式生成的析构函数
}
```

而隐式生成的复制构造函数, 复制算符重载和析构函数则是

```cpp
struct AllImplicit {
    AllImplicit(AllImplicit const& rhs)
        : x(rhs.x)
        , y(rhs.y)
    {}

    AllImplicit& operator=(AllImplicit const& rhs)
    {
        this.x = rhs.x;
        this.y = rhs.y;
    }

    ~AllImplicit() {}
};
```

编译器这么做的规则是调用其每个成员的复制构造函数对其进行初始化; 赋值算符重载类似, 为每个成员进行一次赋值; 析构函数则什么都不做. 对于以上这个例子而言, 默认的复制构造函数, 析构函数等已经足够了, 因为它并不包含任何**资源**的管理. 这也是编译器执行隐式函数生成的根据. 而这也正是在介绍 `constexpr` 时提到过的字面类型, 这些类型跟 `int`, `double` 等一样, 在 C++ 中被视为纯粹的基本数据类型, 不必在复制或析构时有特别的关照.

而以下这个例子, 就需要引入用户自定义的这一组函数

```cpp
class Buffer {
    typedef unsigned char byte;

    // _buffer 指针指向的是一块堆内存区
    byte* _buffer;
    // 以及这块堆内存区分配的大小
    std::size_t _size;
public:
    // 复制的时候, 不只复制指针的值, 而要根据被复制对象的资源信息
    // 另外分配一份相同大小的内存区, 并拷贝数据
    Buffer(Buffer const& rhs)
        : _buffer(rhs._size != 0 ? new byte[rhs._size] : nullptr)
        , _size(rhs._size)
    {
        std::copy(rhs._buffer, rhs._buffer + rhs._size, this->_buffer);
    }

    // C++ 隐式函数生成规则的逻辑在此体现为, 如果有以上定义的复制构造函数
    // 那么 operator= 可以用隐式生成的吗? 显然答案为否. 用户必须自己定义赋值行为
    Buffer& operator=(Buffer const& rhs)
    {
        if (this != &rhs) {
            Buffer tmp(rhs);
            this->swap(tmp);
        }
        return *this;
    }

    // C++ 隐式函数生成规则的逻辑在此体现为, 如果有以上定义的复制构造函数
    // 那么析构函数可以用隐式生成的吗? 显然答案亦为否. 用户必须自己定义析构行为
    ~Buffer()
    {
        delete[] this->_buffer;
    }

    void swap(Buffer& rhs);
};
```

以上的例子可以看出, 如果用户定义了这三个函数中的一个, 也**应当**定义另外两个, 这是由于在 C++ 的语义上, 自定义其中任何一个函数是有资源管理的情形.

是否需要编写相应的控制函数也显示出来 C++ 的类应当区分为两种: 基本数据对象类型和资源控制对象类型. 基本数据对象持有的都是可以平凡复制的基本数据, 不需要非平凡的复制或析构行为; 而资源控制对象型则需要用户定义更细致地复制和析构行为.

在 C++11 标准中, 这一约定被更换成了 "五法则" (the rule of five), 多出来的两个是移动构造函数和移动赋值算符重载. 对于新的这些函数的实现要领, 在 STL 源码中已经见识过了这里就不再举例赘述. 只是对它们而言情况稍有不同, 新的约定是

* 如果用户没有定义以上任何一个函数, 则隐式生成所有这五个函数; 隐式生成移动构造函数或移动赋值算符重载函数的规则是逐个移动构造或移动赋值对象的每个对应基类部分和每个对应成员部分
* 除非, 有基类或某成员将其中某个函数标记为 `delete`, 那么对应的函数不会隐式生成
* 若三法则中任何一个函数被用户定义, 则移动构造函数和移动赋值算符重载不会隐式生成

例如

```cpp
struct Person {
    std::string name;
    int age;

    // 由于三法则中任何一个函数都没有定义
    // 编译器隐式生成五法则中所有函数

    // 其中隐式生成的移动构造函数将类似于

    /*

    Person(Person&& x)
        : name(std::move(x.name)) // 移动构造 string 类型的 name 属性
        , age(std::move(x.age))   // int 类型的移动实际跟复制行为一样
    {}

    */

    // 这种隐式生成, 一般而言都应该是语义正确的
};

struct PointerHolder {
    // 作为成员的 unique_ptr 的复制构造, 复制赋值算符都被标记为 delete
    // 因此这个类也不会生成这两个函数
    std::unique_ptr<int> p;

    PointerHolder()
        : p(nullptr)
    {}

    // 如果不注释这一句, 那么移动构造函数和移动赋值算符重载都不会隐式生成
    // 下面使用处会报错
    // ~PointerHolder() {}
};

int main()
{
    Person p;
    p.name = "xiaoming";
    p.age = 10;

    Person q(std::move(p)); // 调用隐式生成的移动构造函数
    std::cout << p.name.empty() << std::endl; // 1 : p 作为移动来源, 其 name 属性管理的资源移交给了 q.name
    std::cout << p.age << std::endl;          // 10 : 移动之后基本数据类型的值还会保留

    std::cout << q.name << std::endl;         // xiaoming
    std::cout << q.age << std::endl;          // 10

    // ====================

    PointerHolder x;
    x.p = std::unique_ptr<int>(new int(40));

    // 调用隐式生成的移动构造函数
    PointerHolder y(std::move(x));
    std::cout << (x.p == nullptr) << std::endl; // 1
    std::cout << *y.p << std::endl;             // 40

    // 调用隐式生成的移动赋值算符
    PointerHolder z;
    z = std::move(y);
    std::cout << (y.p == nullptr) << std::endl; // 1
    std::cout << *z.p << std::endl;             // 40

    return 0;
    // 调用隐式生成的析构函数
}
```

上面最后一条规则向前兼容的防范, 现有代码中某个管理资源的类型立即使用支持 C++11 编译器编译时, 由于没有隐式生成移动相关函数, 从右值构造或赋值时还是会决议到复制构造函数或复制赋值算符重载. 因此在更新了编译器之后, 这些类型也要更新代码才能获得移动语义带来的优化.

五法则的着眼点在类型是否手动管理资源. *而在另一个领域里有一个小例外, 就是不包含资源, 但需要多态行为的基类在定义时*, 用户*必须定义一个虚析构函数*, 但并没有必要定义复制或移动的相关函数. 这时如果用户去一个个手写这些函数就太麻烦了, 尤其是移动相关的函数, 它们并不会被隐式生成. 为了解决这个问题, C++11 又引入了用于生成默认行为的构造函数, 赋值运算符的机制. 如

```cpp
struct BaseClass {
    // 空函数体的析构函数, 只是为了加上 virtual 修饰
    virtual ~BaseClass() {}

    // 复制相关函数
    // 在函数签名后使用 = default 来生成默认行为
    // 与 = delete 不同, 它只可以被用在这些能被隐式生成的函数之后
    BaseClass(BaseClass const&) = default;
    BaseClass& operator=(BaseClass const&) = default;

    // 移动相关函数
    BaseClass(BaseClass&&) = default;
    BaseClass& operator=(BaseClass&&) = default;

    // 无参数的构造函数也适用 = default; 在本例中这不是必需的
    BaseClass() = default;
};
```

使用 `= default` 生成默认行为的函数, *只能用于无参构造函数和五法则约定中的函数, 且析构函数不能是虚函数* (因此上例中析构函数不能使用 `= default`). 在函数签名后, *不能写初始化列表或函数体,* 而必须直接加上 `= default;` 声明. 而若类不需要其中的某些函数, 也最好使用 `= delete` 显式将其标记为不可用.
# 可变参数模板

虽然 C++ 语言是一门静态类型语言, 但因为有较为完善的泛型编程支持, 编写一些与类型无关的代码也没有太大困难.

而新引入的可变参数模板机制则让既有的泛型特性如虎添翼, 自此, 泛型函数或泛型类型中的泛型参数的个数也不必在编写时确定了, 有助于开发者编写出更加灵活的代码.
## 可变参数模板函数

可变参数这一特性, 早在 C 语言中就有了, 可变参数函数这一特性, 在 C 语言悠久的发展历史中, 实际上是很早就引入的一项特性, 这跟 C 的编译特性有关系. 早期的 C 语言并不支持前置函数声明, 而编译器在处理到没有定义过的函数调用时, 会假定该函数返回整型 (`int`) 并且*接受不定个数个整型参数*, 并按照这样的规则生成参数入栈和返回的代码, 因此 C 几乎天生支持这个看起来很复杂的语言特性.

其中最典型的运用当属与 C 语言标准 IO 的一族函数, 如

```cpp
int printf(char const* format, ...);
int scanf(char const* format, ...);
```

而作为 C++11 中新加入的**可变参数模板** (variardic template) 特性中的一个方面, **可变参数模板函数**当然不是 C++ "天生" 支持的特性, 它的设计是利用 C++ 中原本支持的重载机制和泛型函数机制来实现构造可以接受任意多个泛型参数的函数. 比如

```cpp
template <typename T, typename... More>      // typename 之后加上省略号 (...) 表示这是可变参数模板
void print(T const& t, More const&... more); // 相应地在泛型参数类型后也加上省略号
```

虽然也使用了省略号这一词法元素, 但它与 C 中的可变参数函数的机制不同. 实际上, 声明了以上函数, 等价于声明了这样一组不同参数个数的泛型函数重载

```cpp
template <typename T>
void print(T const& t);                                      // More 参数个数为 0

template <typename T, typename More0>
void print(T const& t, More0 const& more0);                  // More 参数个数为 1

template <typename T, typename More0, typename More1>
void print(T const& t, More0 const& more0, T2 const& more1); // More 参数个数为 2

// ... 任意多个这样的重载
```

每个参数的类型都是泛型类型, 而不是默认为是整数, 或由用户自己从固定参数中推定得出, 因此相对于 C 的可变参数函数, 这一机制也有更好的类型安全性.

### 运用与实现

可变参数模板函数的运用通常都是对某种允许有任意多个参数的行为的建模, C 语言在这个方面用得最多的是格式化输入输出, 那么作为一个简化的例子, 不妨来考虑一个需求: 输出任意多个 (至少一个) 对象, 以逗号分隔它们, 而不需要考虑格式化输出. 如以下的调用所示

```cpp
print(0);                             // 输出: 0

int const x = 10;
std::string msg("A quick brown fox");
print(x, msg, 3.14);                  // 输出: 10, A quick brown fox, 3.14
print(msg, "and a lazy dog", &x);     // 可能的输出: A quick brown fox, and a lazy dog, 0xffefffc4c

print();                              // 无法编译
```

从以上示例也可以看出, 每个传递给 `print` 的参数的类型也可以是任意类型的, 这与 STL 算法库中实现迭代, 累加, 变换等需求的函数有本质区别. STL 算法函数都是从给定的迭代区间中获取参数, 而这些参数都有同样的类型, 这一点与可变参数模板函数要达成的目的不同.

因此, 要实现以上的需求, 需要引入的函数不仅仅是接受任意个参数的函数, 而且所有这些参数都是泛型参数. 此函数的声明在本节开始的时候给出了

```cpp
template <typename T, typename... More>
void print(T const& t, More const&... more);
```

现在介绍其中各部分的含义. 此模板函数的声明中有两个 `typename` 但其接受的模板参数是至少 1 个. 这就是因为第二个 `typename` 之后的省略号 `...` 表示此参数为一个类型**参数包** (parameter pack). 参数包指的是从**零个到任意多个**类型参数, 因此参数列表中的 `More const&... more` 指的是从 0 个到任意多个参数, 那么*若要函数至少接受 1 个参数*, 就需要在前面额外加上一个 `T const& t`.

这两部分的位置不可颠倒, 也就是*形式参数列表中参数包只能出现在列表最后*. 但出现在 `template` 声明中的 `typename` 没有这个限制

```cpp
template <typename T, typename... More>
void print(More const&... more, T const& t); // 错误, 参数包应该放在参数列表最后

template <typename... More, typename T>      // 将 typename... 放在模板声明的其他位置可以编译
void print(T const& t, More const&... more);
```

函数的实现可以按照以下思路进行

```cpp
template <typename T, typename... More>
void print(T const& t, More const&... more)
{
    std::cout << t;             // 输出第一个对象
    if (/* (a) more 代表的参数包内有多于 1 个参数 */) {
        std::cout << ", ";
        print(/* (b) 将 more 中的参数展开到此处作为实参, 以输出剩下的对象 */);
    } else {
        std::cout << std::endl;
    }
}
```

以上 (a) (b) 两处都需要用到可变参数模板的配套设施, 即以下 C++11 中新增的语法

* (a) 用 `sizeof...(More)` 或 `sizeof...(more)` 得到参数包中的参数个数, 这是*一个编译时常数*
* (b) `print(more...)` 将参数包 `more` 中的参数展开为 `print` 调用的实参

将这些内容补充到上面实现中, 便是

```cpp
template <typename T, typename... More>
void print(T const& t, More const&... more)
{
    std::cout << t;
    if (sizeof...(more) > 0) {
        std::cout << ", ";
        print(more...);
    } else {
        std::cout << std::endl;
    }
}
```

按照可变参数模板函数的逻辑, 以上代码实际上等价于编写了一族函数重载

```cpp
template <typename T>
void print(T const& t)
{
    std::cout << t;
    if (0 > 0) {                // 没有 More 参数, sizeof...(more) 为 0
        std::cout << ", ";
        print();                // 展开时 print 就没有参数了
    } else {
        std::cout << std::endl;
    }
}

template <typename T, typename More0>
void print(T const& t, More0 const& more0)
{
    std::cout << t;
    if (1 > 0) {                // More 参数个数为 1
        std::cout << ", ";
        print(more0);           // 展开时 print 有 more0 一个参数
                                // 匹配上一重载
    } else /* ... */
}

template <typename T, typename More0, typename More1>
void print(T const& t, More0 const& more0, More1 const& more1)
{
    std::cout << t;
    if (2 > 0) {                // More 参数个数为 2
        std::cout << ", ";
        print(more0, more1);    // 展开时 print 有 2 个参数
                                // 匹配上一重载
    } else /* ... */
}

// 更多参数的情况
```

简而言之, `print(more...)` 这个带有参数包的表达式, 就是编译器为用户将参数包中的参数填入函数调用的实参列表中. 当然还有一些较为复杂的情况, 将在下一节中详细说明.

不过很遗憾的, 编译器会在 `print(more...)` 这一句报错, 提示给 `print` 函数提供了 0 个参数, 对应于第一个没有 `more` 参数的重载.

虽然 `sizeof...` 求得的是编译时常数, 编译器应该能在编译时就优化并只选出条件分支语句其中一个路径, 不过这种优化的时机要晚于编译两个路径, 所以还未开始优化, 就会先给出编译错误.

而正确的实现应当是另行提供一个仅 1 参数的重载, 来替代编译器生成的. 如下

```cpp
template <typename T>
void print(T const& t)      // 提供一个单独的重载, 处理没有 more 参数的情况
{
    std::cout << t;
    std::cout << std::endl; // 只有一个参数的重载也包括了 sizeof...(more) == 0 时的分支路径
}

template <typename T, typename... More>
void print(T const& t, More const&... more)
{
    std::cout << t;
    std::cout << ", ";      // 只留下 sizeof...(more) > 0 的分支路径
    print(more...);
}
```

提供了这个重载后, 也同时将分支语句中的两个路径拆分到两个重载中去了, 换言之, 在后面一个重载中, 实现所表现出的逻辑是, `more` 中肯定有至少一个参数, 不可能是 0 个.

这实际上也是可变参数模板的重载匹配规则所确保的. *当有给定个数个参数的重载提供时会被优先匹配,* 所以在给 `print` 的参数只有 1 个时, 就会匹配前一个重载. 当然, 这有一个前提: 在后一个重载实现时, 应当先给出前一个重载的前置声明或实现, 否则后一个重载也不会知道当参数包个数为 0 时去匹配前一个重载了.

下面是一个完整的例子.

```cpp
#include <iostream>

template <typename T>
void print(T const& t)
{
    std::cout << t << std::endl;
}

template <typename T, typename... More>
void print(T const& t, More const&... more)
{
    std::cout << t << ", ";
    print(more...);
}

int main()
{
    print(0);

    int const x = 10;
    std::string msg("A quick brown fox");
    print(x, msg, 3.14);
    print(msg, "and a lazy dog", &x);
    return 0;
}
```

可以看出, 可变参数模板函数的实现实质上是不断对模板进行递归特化, 并逐渐减少参数包中参数数量, 最终耗尽参数包而得以匹配到更一般的非可变参数的重载来实现的, 也因此在实现可变参数模板函数时, 一般需要定义一个单独的重载来匹配参数包中参数个数为 0 的情形.

而严格地讲, `print` 调用自身来 "**递归**" 实现的说法*并不正确*, 因为每次调用生成的特化函数都是不同的函数. 当后文中为了叙述方便, 仍然会说这样的模板函数或模板类型递归地调用自身, 或递归地特化自己来实现.

这个例子也能展现出 C 中的可变参数函数和 C++11 的可变参数模板函数之间的本质区别. 对于 C 中的函数, 如标准 IO 中正统的 `printf`, *其参数的个数和类型都是从模式字符串推导出来的*, 而可变参数模板函数的参数类型都*是编译时可以确定的*, 体现了模板函数更好的类型安全性. 而而其缺点也很典型, 就是不同类型的特化会生成不同的代码, 使程序体积增大, 不过在新世纪的今天, 为了代码的可维护性, 这应该也不算大问题了.

### 重载决议

如上面所说的, 当同时存在一个可变参数的重载, 和一个固定个数参数的重载时, 会优先适配后者, 如

```cpp
template <typename T>
void print(T const& t) { /* ... */ }

template <typename T, typename... More>
void print(T const& t, More const&... more) { /* ... */ }

template <typename T, typename U, typename S>
void print(T const& t, U const& u, S const& s) // 增加一个固定 3 参数的重载
{
    std::cout << "matches me, no further output" << std::endl;
}

int main()
{
    // ...
    print(msg, "and a lazy dog", &x); // 输出 matches me, no further output
    return 0;
}
```

此外, 如果固定个数参数的重载同时也有固定的类型而非泛型类型, 那么与既有标准中的行为一样, 这些更精准的重载将在合适时被优先匹配.

可变参数模板还有一种特别的重载: 更换参数包类型的引用形式

```cpp
template <typename T>
void print(T const& t) { /* ... */ }

template <typename T, typename... More>
void print(T const& t, More const&... more) // 参数包引用形式为 const 限定引用
{
    std::cout << t << " [C] ";              // 分隔符为 [C]
    print(more...);
}

template <typename T, typename... More>
void print(T const& t, More&... more)       // 参数包引用形式为非 const 限定引用
{
    std::cout << t << " [-] ";              // 分隔符为 [-]
    print(more...);
}

int main()
{
    int const x = 10;
    std::string msg("A quick brown fox");
    print(x, msg, 3.14);                    // 输出: 10 [C] A quick brown fox [C] 3.14
    print(x, msg);                          // 输出: 10 [-] A quick brown fox
    return 0;
}
```

从这个例子中可以看出, 如果加上一个非 `const` 限定引用的重载版本, 而且调用时参数包中的实参又恰好都是非 `const` 的左值, 那么也会遵循*尽可能精准的规则匹配*非 `const` 限定的版本. 当然这种做法并不建议, 而应该使用广义引用

```cpp
template <typename T, typename... More>
void print(T const& t, More&&... more)  // More 是模板参数类型, 因此这不是右值引用, 而是广义引用
{
    // ...
}
```

实际情况中, 根据是否允许修改参数, 选择性地给出 `const` 限定引用或广义引用之一即可.

###  可变个整数型常数模板

除了可以在 `typename` 关键字之后加省略号表示多个类型参数之外, 整数类型参数的个数也可以是可变的. 如上面所说的

```cpp
template <typename T, int... I> // 任意多个整数参数
void func();
```

在自定义字面量后缀一节中提到的如下模板函数定义, 其中模板参数为 `char... ch`, `ch` 参数包中包含该字符串中每一个字符. 可通过如下方式实现之

```cpp
#include <iostream>
#include <gmpxx.h> // GMP 高精度数值库, 包括高精度整数类型 mpz_class 和高精度浮点数类型 mpf_class 等
                   // 由于 gcc 4.5 以上版本依赖 GMP 库, 若正确安装了 gcc, 应该可以直接包含此头文件
                   // 链接时, 需要增加 -lgmp -lgmpxx 参数

template <char... ch>
mpf_class operator "" _mf()
{
    // 将参数包展开到数组初始化列表中, 等价于 {ch0, ch1, ch2, /* ... */, 0}
    // 末尾处的 0 表示 nul 字符, 换言之这一自定义字面量重载的模板参数中没有自带 nul 字符
    char s[] = {ch..., 0};
    return mpf_class(s);
}

/* 以上重载完全等价于下面的重载, 而 char const* 参数比可变模板参数要更容易使用
   因此若不是要将 char... ch 中的字符常量当作编译时常量使用, 建议用以下重载
mpf_class operator "" _mf(char const* s)
{
    return mpf_class(s);
}
*/

int main()
{
    // 传给模板的字符参数包为 '1' 'e' '+' '1' '0' '0' '0' 共 7 个字符
    std::cout << 1e+1000_mf / 100 << std::endl; // 输出为 1e+998, 超过 double 类型可表示的范围
    return 0;
}
```

### 类型约束

最后需要提一下, 可变参数模板这一特性*并没有 "可变参数但不是模板" 的形式*. 比如, 需要可变个字符串作为参数, 不能写作

```cpp
std::string concat_all(std::string const&... s);
```

这种情况下仍然只能写为泛型声明, 然后通过其他手段来验证参数类型是否满足条件. 比如最简单的做法, 利用 `is_convertible` 判定参数是否可以转换为 `string`

```cpp
#include <type_traits> // is_convertible

template <typename T, typename... U>
void concat_all(T const& t, U&&... u)
{
    static_assert(
        // C++11 中新加的泛型类型 is_convertible
        // 用于确定其第一参数类型是否可以转换为第二参数类型
        std::is_convertible<T, std::string>::value,
        "not convertible to string");

    // ...
}
```

对可变参数模板函数的介绍就到此, 接下来将详细说明各种参数包, 也就是省略号在可变参数模板特性中的使用方式.

在以上例子中, 代码中出现 `...` 表示这是一个省略号词法元素, 若是写成注释如 `/* ... */` 则表示这里有更多但不重要的或者任意的代码. 本书之后的代码部分也将沿用这种记法.

## 参数包

在上一节的例子中参数包省略号出现在了三种不同的位置, 这也是参数包的三种语法形式. 分别是

```cpp
// a. 出现在模板内关键字之后, 如

  // 不定个数个类型
  template <typename... T>
  // 等价于声明如下的模板
  template <typename T0, typename T1, typename T2, /* 任意多个参数 */>

  // 不定个数个常数
  template <int... N>
  // 等价于声明如下的模板
  template <int N0, int N1, int N2, /* 任意多个参数 */>

  // 类似的, 不定个数个模板类型
  template <template <typename> class... T>

// b. 出现在类型上下文中, 如

  template <typename... T>
  void f(T&&... args);
  // 等价于
  template <typename T0, typename T1, typename T2, /* 任意多个 */>
  void f(T0&& arg0, T1&& arg1, T2&& arg2, /* 相应的任意多个 */);

// c. 出现在表达式上下文中, 如

  template <typename... T>
  void f(T&&... args)
  {
      g(args...);
      // 等价于用逗号分隔拆开 args 包
      g(arg0, arg1, arg2, /* 相应的任意多个 */);

      // 注意, 并不等价于逗号运算符, 不能单独写出来是
      // 如 g(0, (args..)) 是错误的写法, 其中 (args..) 并不会变成逗号分隔的表达式
  }
```

头一种情形就像武术的起手式, 无论是可变模板函数还是可变模板类的开头必然都有它, 但变化并不多, 在模板声明时视情况写上即可.

而类型上下文中的省略号则可用于任何可能出现任意多个类型的位置, 除了上一节中的例子里提到的直接以模板类型为各参数类型的 `print` 函数, 也包括如下这样的参数声明方式

```cpp
template <typename... T>
void g(std::vector<T>&&... args);
// 等价于
template <typename T0, typename T1, /* 任意多个 */>
void g(std::vector<T0>&& arg0, std::vector<T1>&& arg1, /* 相应的任意多个 */);
```

那么这个 `g` 模板函数可以接受任意多个任意元素类型的 `vector` 对象参数. 需要注意的是, 上面这个写法跟下面的写法

```cpp
template <typename... T>
void g(std::vector<T...>&& args);
```

完全不同, 后面这种写法是将参数包展开为 `std::vector` 的模板参数

```cpp
template <typename T0, typename T1, /* ... */>
void g(std::vector<T0, T1, /* ... */>&& args);
```

如果这个参数包恰好只有一个参数, 或者恰好有两个参数且第二个参数又恰好是个 `allocator` 类型, 这个模板还姑且可以特化, 但其他情况就大错特错了.

除了可以在形参列表中出现参数包, 在*类型继承处也可以出现任意多个类型*, 这似乎有点出乎意料, 但确实可以这么干

```cpp
template <typename... T>
class MyClass: public T...
{
    // ...
};

// 等价于

template <typename T0, typename T1, /* ... */>
class MyClass
    : public T0
    , public T1 // 所有继承访问限制均与第一个相同, 如这里都是 public 继承
    /* ... */
{
    // ...
};
```

当然一般并不会直接这么用, 且一旦参数包里有两个类型相同的参数, 或者有原生类型, 那么这种继承就无法编译. 故使用时需要一些技巧, 作为一个对可变模板参数继承的例子, 下一节将介绍 `std::tuple` 的实现方式.

而表达式上下文中的参数包则花样更多一些, 参数包表达式可以带着表达式模式展开. 比如

```cpp
template <typename... T>
void f(T&&... args)
{
    // 原样展开
    g(args...); // => g(arg0, arg1, /* ... */);

    // 函数调用模式的展开
    g(h(args)...); // => g(h(arg0), h(arg1), /* ... */);

    // 运算模式的展开
    g(args < value...); // => g(arg0 < value, arg1 < value, /* ... */);
    // 如果是数值常数, 要加个空格以免省略号被当作小数点
    g(args < 0 ...); // => g(arg0 < 0, arg1 < 0, /* ... */);

    // 还可以将以上模式组合在一起
    g(m(args) < n(value)...); // => g(m(arg0) < n(value), m(arg1) < n(value), /* ... */);
}
```

理解这种模式展开不妨将省略号视作一个优先级非常低的后置算符, 然后将省略号之前的表达式当作模式展开参数包

```cpp
template <typename... T>
void f(T&&... args)
{
    g(h(args)...);
//    ^^^^^^^ 省略号之前的表达式
//  按此模式展开成
    g(h(arg0), h(arg1), /* ... */);
//    ^^^^^^^  ^^^^^^^

    g(m(args) < n(value)...);
//    ^^^^^^^^^^^^^^^^^^ 省略号之前的表达式, 省略号的 "优先级" 低于比较运算或任何其他算符
//  按此模式展开成
    g(m(arg0) < n(value), m(arg1) < n(value), /* ... */);
//    ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^
}
```

为了*让代码更容易看明白, 可以给模式表达式额外加上一层括号, 以及加上额外的空格让代码显得更清晰*, 比如上述最后一个例子可以写成

```cpp
    g( ( m(args) < n(value) )... );
```

再举一例

```cpp
// bits/vector.tcc:291
// vector::emplace 函数实现
// 置位式构造, 给定一个位置 (首参数) 在这个位置上构造元素
template <typename... _Args>
iterator emplace(iterator __position, _Args&&... __args)
{
    size_type const __n = __position - begin();
    if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
            && __position == end())
    {
        _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                                 std::forward<_Args>(__args)...);
//                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
        ++this->_M_impl._M_finish;
    } else {
        _M_insert_aux(__position, std::forward<_Args>(__args)...);
//                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    }
    return iterator(this->_M_impl._M_start + __n);
}
```

构造参数是一组可变广义引用, 它们最终将被直接传递给元素的某个构造函数重载, 传递的过程当然要用到前文中提到的完美转发. 然而问题是如何完美转发一组任意多个参数呢? 答案就在这里, 以 `forward` 调用为模式展开参数包.

需要注意的是, `forward` 的特化类型参数 `_Args` 是个类型参数包, 在这个模式里相应的类型和相应的值在同一个表达式中一同展开, 相当于以下代码. 这也可以视作一种 `forward` 的固定用法.

```cpp
template <typename _Arg0, typename _Arg1, /* ... */>
iterator emplace(iterator __position, _Arg0&& __arg0, _Arg1&& __arg1, /* ... */)
{
    // ...
    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                             std::forward<_Arg0>(__arg0),
                             std::forward<_Arg1>(__arg1),
                             /* ... */);
    // ...
}
```

这种固定用法非常适合于这种场景: 某个函数仅处理一部分参数, 然后让所有其他参数都透过此函数传给另一个函数, 并且转发的参数的个数是不定的. 像上面的例子一样, 这一写法在 STL 中也被广泛使用, 各种容器在 C++11 中都添加了类似 API 支持置位式构造元素, 通过这样的函数入口提供构造参数, 容器内部在分配好的空间上再根据参数构造对象, 而避免了任何构造好的元素的复制或移动. 比如, `vector` 有 `emplace_back` API 支持在容器的末尾进行插入

```cpp
struct Point {
    int x;
    int y;

    Point(int xx, int yy)
        : x(xx)
        , y(yy)
    {}
};

int main()
{
    std::vector<Point> pts;
    // 以下两个调用的效果相同, 均为向 vector 末尾添加 x=2, y=3 的 Point 对象
    pts.push_back(Point(2, 3)); // 使用 push_back 将已经构造的对象加入 vector 中
    pts.emplace_back(2, 3);     // 使用 emplace_back 将用来构造 Point 的参数传入, 而无需直接构造对象
    return 0;
}
```

以上就是省略号的各种用法. 到此为止可变参数模板机制都以可变参数模板函数为例, 而接下来将介绍 C++11 中 STL 加入的可变参数模板类 `tuple` 的实现技巧.


## 元组类

在第一章介绍 `unique_ptr` 时简单提过 `tuple` 类型. 因为在 `unique_ptr` 中定义的 `tuple` 类型只用了两个模板参数, 逻辑上与使用 `pair` 类型相同, 故也没有更深入解释.

作为可变参数模板类型的一个先驱, `tuple` 的使用和实现都有很典型, 围绕 `tuple` 本身进行分析, 便能大致摸清可变参数模板类型的实现方式和一些技巧了.

= 基本使用

`tuple` 类型的用法与 `pair` 非常类似, 只是因其使用了可变参数模板特性, 可以扩展到一次包括任意多个元素.

```cpp
// 以单个类型特化 tuple
std::tuple<int> x(0);
// 通过 get<int> 函数获取 tuple 指定位置上的元素的左值引用; 此处获取的是字符串的引用
// 不可以用下标索引 x[0]
std::cout << std::get<0>(x) << std::endl; // 0

// 以三个类型特化 tuple
std::tuple<std::string, double, int> y("hello", 3.14, 2);
std::cout << std::get<0>(y) << std::endl; // hello
std::cout << std::get<1>(y) << std::endl; // 3.14
std::cout << std::get<2>(y) << std::endl; // 2

// 不包含任何元素的 tuple
std::tuple<> tuple_of_nothing;

// 特化类型分别是 int, int, std::string 的 tuple
std::tuple<int, int, std::string> point(0, 0, "origin");

// 若 tuple 非 const 限定, 那么获取了引用就能修改它们了
std::get<2>(point) = "A";
std::get<0>(point) += 1;

// make_tuple 类似与 make_pair, 返回由其参数类型特化出的一个 tuple 对象
std::cout << (point == std::make_tuple(1, 0, "A")) << std::endl; // 1
```

不过, 像 `tuple` 或 `pair` 这样单纯将若干个对象聚合在一起的结构的可读性非常差. 如下面这个例子用到了 `std::map` 和 `std::pair`

```
void vote_for(std::map<std::string, int>& votes, std::string const& name)
{
    std::pair<std::map<std::string, int>::iterator, bool>
            r = votes.insert(std::make_pair(name, 0));
    if (r.second) {
        // 有新的名字被加入了
    }
    r.first->second += 1;
//  ^^^^^^^^^^^^^^^
}
```

函数的逻辑是给某个人投票, 如果这个人没有记录, 新建之并触发新建事件, 然后给这个人票数加一. 由于 `map::insert` 的返回值是一个 `pair` 里套着另一个实质上还是 `pair` 的迭代器对象, 票数加一这句代码 `r.first->second += 1` 看起来简直是随手拼凑的涂鸦. 假如它能写作 `r.iterator->value += 1` 都会好很多, 可惜由于使用的是 `pair` 因而只得用 `first`, `second` 这样的成员名字. `tuple` 同理. 因此, 不建议在实际项目中大量使用 `pair` 或 `tuple`.

= 实现原理

`pair` 的结构非常简洁明了, 包含两个模板参数类型定义的数据成员; 然而 `tuple` 并不能这样实现, 因为没有参数包展开语法能够用于定义一组成员.

因此, `tuple` 使用多重继承来实现. 这种多重继承并不是直接在类型继承处展开模板参数包, 否则有以下导致编译失败的可能

* 模板参数含有原生类型, 原生类型不能用于继承
* 模板参数类型可能是 `final` 修饰的, 不能用于继承
* 模板参数含有两个相同的类型, 不能重复继承一个类型

要解决以上问题, `tuple` 的实现中运用了如下的包装模板 `_Head_base`, 用来包装参数类型

```
// tuple:78
// 参数包装类型声明, 各模板参数含义如下
// _Idx:             索引标识
// _Head:            将由传给 tuple 的模板参数来特化的元素类型参数
// _IsEmptyNotFinal: 是否是空结构体 (不含数据成员或虚函数) 且非 final 修饰
template<std::size_t _Idx, typename _Head, bool _IsEmptyNotFinal>
struct _Head_base;

// :81 类型参数是空结构体, 且不为 final 修饰的特化: 继承此类型
template<std::size_t _Idx, typename _Head>
struct _Head_base<_Idx, _Head, true>
    : public _Head // _Head 为父类
{
    // ...
};

// :128 除以上情况的特化: 聚合此类型
template<std::size_t _Idx, typename _Head>
struct _Head_base<_Idx, _Head, false>
{
    // :174 使用 _Head 类型定义的成员
    _Head _M_head_impl;

    // ...
};
```

而 `tuple` 以如下方式使用 `_Head_base`

```
// :185 先导定义, 用于产生索引标识的 _Tuple_impl
template<std::size_t _Idx, typename... _Elements>
struct _Tuple_impl;

// :192 类型参数包 _Elements 的数量降为 0 的偏特化
// 既然所有类型参数已经使用完毕, 这是一个空结构体
template<std::size_t _Idx>
struct _Tuple_impl<_Idx> {};

// :230 更一般的偏特化, 至少 1 个 _Head 参数, 剩下的类型被称之为 _Tail
template<std::size_t _Idx, typename _Head, typename... _Tail>
struct _Tuple_impl<_Idx, _Head, _Tail...>
        // _Tuple_impl 递归特化, 将 _Tail 传递过去, 同时将 _Idx 加上 1 以产生不同的特化类型
    : public _Tuple_impl<_Idx + 1, _Tail...>
        // 将 _Head_base 作为自己的基类; 使用 private 继承防止对象被基类引用误用
    , private _Head_base<_Idx, _Head,
                                      // 是否采用继承的方式产生 _Head_base, 后文将详细分析
                                      __empty_not_final<_Head>::value>
{
    // ...
};

// :389 暴露出的 tuple 类型, 以 0 为初始 _Idx
template<typename... _Elements>
class tuple
    : public _Tuple_impl<0, _Elements...>
{
    // ...
};
```

`tuple` 类型直接继承的是内部类型 `_Tuple_impl`, 后者直接继承各种 `_Head_base` 的特化. 用 `_Head_base` 将需要继承的类型, 也就是传给 `tuple` 的模板参数类型包装起来, 这样无论原始类型是什么都可以裹在这个模板里继承.

然后, 使用 `_Idx` 整型参数对每个 `_Head_base` 基类进行一次顺序编号, 这样即使有相同参数类型 `T`, 其通过不同编号参数特化出的基类. 如特化 `std::tuple<int, int>`, 产生的两个基类 `_Head_base<0, int>` 和 `_Head_base<1, int>` 不是同一类型.

下面对 `std::tuple<int, std::string, bool>` 这个特化的继承方式作一个图解, 以更清晰地理解其结构

:::
tuple<int, std::string, bool>
 |
 |
 '----: _Tuple_impl<0, int, std::string, bool>    // _Elements = int, std::string, bool
          |
          |
          |---: _Head_base<0, int, false>
          |
          |
          '---: _Tuple_impl<1, std::string, bool> // _Elements = std::string, bool
                  |
                  |
                  |---: _Head_base<1, std::string, false>
                  |
                  |
                  '---: _Tuple_impl<2, bool>      // _Elements = bool
                          |
                          |
                          |-: _Head_base<2, bool, false>
                          |
                          |
                          '-: _Tuple_impl<3>      // _Elements 为空
:::

而 `_Head_base` 最后有一个 `bool` 参数, 用以决定此 `_Head_base` 是否将参数类型作为父类使用, 而不是作为成员. 为何要有继承方式的偏特化呢? 把所有类型参数全部用聚合的方式, 定义为类型成员不行吗?

行是行, 但是会有代价. 在介绍对象的同一性时提到过, 为了确保两个对象地址不同, C++ 规定对空结构体求 `sizeof` 要得到一个非 0 值; 而若将这个结构体定义为另一个结构体的成员, 那么再加上内存对齐, 后者可能会占用更多的空间. 不妨看看下面这个测试

```
int main()
{
    struct E {};
    std::cout << sizeof(E) << std::endl;   // 1 : 同一性基本要求

    struct F { E e; };
    std::cout << sizeof(F) << std::endl;   // 1 : 将空结构体作为成员, 体积不会继续增加

    struct G { E e; int x; };
    std::cout << sizeof(int) << std::endl; // 4
    std::cout << sizeof(G) << std::endl;   // 8 : 但如果在空结构体成员后加上 int 成员
                                           //     因为内存对齐, 空结构体实际消耗了 4 字节
    struct H: E { int x; };
    std::cout << sizeof(H) << std::endl;   // 4 : 空结构体作为父类继承, 就只占用 int 的空间
    return 0;
}
```

从最后 `H` 的定义看出, 如果是继承空结构体, 然后在子类中加入其他成员, 则其没有额外空间消耗. 这个优化被称之为**空基类优化** (Empty Base Optimization, 简称 EBO). 也就是说, `std::tuple` 的实现倾向于用这种技巧来节省空间. 下面这两段代码便可以一窥其中端倪.

```
// 使用聚合的 HeadBase
template <typename Head>
struct HeadBaseAggr { Head head; };

template <typename First, typename Second>
struct TupleAggr
    : HeadBaseAggr<First>
    , HeadBaseAggr<Second>
{};

// 两个空类型和一个包含 int 的类型
struct E {};
struct F {};

int main()
{
    // 继承聚合模板类型的特化, 求得 sizeof 却是 2
    // 因为继承了两个空间占用各 1 字节的基类
    std::cout << sizeof(TupleAggr<E, F>) << std::endl;   // 2

    // 此处更明显, 使用聚合会引起编译器生成内存对齐的结构, 进一步增加空间消耗
    std::cout << sizeof(TupleAggr<E, int>) << std::endl; // 8
    return 0;
}
```

而使用继承的方式, 结果则是

```
template <typename Head>
struct HeadBaseInherit: Head {};

// 两种 Tuple 都使用继承, 只是继承的基类模板不同
template <typename First, typename Second>
struct TupleInherit
    : HeadBaseInherit<First>
    , HeadBaseInherit<Second>
{};

// 两个空类型和一个包含 int 的类型
struct E {};
struct F {};
struct G { int x; };

int main()
{
    // 用两个空结构体来特化, 结果纯继承方式求得 sizeof 为 1
    // 因为这是纯粹继承的方式, 基类占用的空间可以被完全优化掉
    // 剩下 1 字节是同一性的要求
    std::cout << sizeof(TupleInherit<E, F>) << std::endl; // 1

    // 大小等于 G 类型, 也就是 int 类型
    std::cout << sizeof(TupleInherit<E, G>) << std::endl; // 4
    return 0;
}
```

可能有读者会问, 什么情况下会向 `std::tuple` 传递一个空结构体呢? 真的会有这样的用况吗? 有! 例子就在第一章: `unique_ptr` 中, 使用 `tuple<pointer_type, deleter_type>` 来管理, 也许会有读者当时就觉得很困惑, 为什么要用个 `tuple` 而不是 `pair`, 或者直接分别用 `pointer_type`, `deleter_type` 定义两个成员呢? 看了上面这部分, 答案自然浮出水面: `std::default_deleter` 就是一个空结构体 (只有非虚成员函数, 也算空结构体), 使用 这种情况下 `tuple` 能使 `unique_ptr` 的空间占用与裸指针相同, 不必产生额外消耗.

= 向值类型的转换

最后简单分析一下 `make_tuple` 实现的一些注意事项. `make_tuple` 的定义是

```
// tuple:858
template<typename... _Elements>
constexpr // 与 make_pair 一样, 在元素类型都是字面类型时被 constexpr 修饰
tuple<typename __decay_and_strip<_Elements>::__type...> // 返回 tuple 类型中的参数类型是经过转换的
make_tuple(_Elements&&... __args)                       // 参数类型是广义引用
{
    typedef tuple<typename __decay_and_strip<_Elements>::__type...> __result_type;
    return __result_type(std::forward<_Elements>(__args)...);
}
```

虽然在本节开头的例子中说它 "返回由其参数类型特化" 的 `tuple`, 但实际上 `make_tuple` 对结果 `tuple` (以及 `make_pair` 对 `pair`) 的特化行为要更复杂. 至少从上面的声明中可以看出, 返回类型并非直接是 `tuple<_Elements...>` 而是用了叫做 `__decay_and_strip` 的类型转换. 这种做法与其参数类型全是广义引用有关, 比如给定以下的代码

```
int x = 0;
int const y = 1;

std::make_tuple(x, y, "A");
```

就例子中的这个表达式 `std::make_tuple(x, y, "A")` 而言, 按广义引用类型参数的推导方式, `_Elements = {int&, int const&, char const(&)[2]}`, 得到的结果亦会是 `tuple<int&, int const&, char const(&)[2]>`, 这与想要得到的 `tuple<int, int, char const*>` 相去甚远. 因此 `make_tuple` 并非照搬参数类型给 `tuple`, 而要经过一次类型转换去掉引用类型, 以及将数组转化为指针等, 具体包括

* 若给定的类型 `T` 是任何引用, 去掉其引用
* 若给定的类型 `T` 是某个 `U[]` 类型, 则将 `T` 转换成 `U*` 类型
* 若给定的类型 `T` 是一个函数, 则转换为函数指针类型
* 同时去掉给定类型的 `const` `volatile` 修饰
* 将 `reference_wrapper` 转换成引用类型

可以看出这个规则除开最后一条, 其他与第一章提到的 `auto` 自动推导得出的类型一致.

这种防止从广义引用参数推导出左值引用类型引用, 并且要求在需要引用时传入 `reference_wrapper` 的行为也被称为退化复制 (decay copy). 除了在 `tuple` 中, 在后文中的 `bind`, `thread` 也有使用.

如果希望 `tuple` 的元素类型就是 `reference_wrapper`, 则应该显式写出, 如

```
int main()
{
    int x = 0;
    int y = 5;
    // 显式写出元素类型为 reference_wrapper
    std::tuple<std::reference_wrapper<int>, int> t = make_tuple(std::ref(x), y);

    std::cout << x << std::endl;    // 0
    std::cout << y << std::endl;    // 5

    // 因为 x 是引用传入的, 这里自增会改变 x 的值; 但不会改变以值传入的 y 的值
    std::get<0>(t).get()++;
    std::get<1>(t)++;

    std::cout << x << std::endl;    // 1
    std::cout << y << std::endl;    // 5
    return 0;
}
```