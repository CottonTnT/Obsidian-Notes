# 语言与语法功能改进


## 空指针

### 为什么

 C 和 C++ 中在处理空指针的时候却并没有起到表率作用. 用户一般会用 `NULL` 来表示空指针, 但它并不是关键字, 而是一个宏. 在 C 中它通常被定义为 `(void*)0`, 而 C++ 中因为禁止 `void*` 指针类型向其他指针类型隐式转换, 因此在既有的编译器实现中它通常被定义为整数字面量 0, 或是其它不那么明确的指针常量.

这是个很容易让编译器产生误解的规则. 比如在 C++ 中以 `NULL` 作为实参时, 可能使得重载决议出错

```cpp
void f(int x) { std::cout << "overload int" << std::endl; }
void f(int* p) { std::cout << "overload int ptr" << std::endl; }

f(NULL); // NULL 被定义为 0 时输出 "overload int", 而另一些实现会报重载决议错误
         // 而不会直接决议为对 f(int*) 的调用
```

### 有什么
在 C++11 中引入新的空指针**关键字** `nullptr` 来解决这一问题. 不过, 考虑到向前兼容性, `NULL` 宏的定义并没有被直接改成这一关键字, 要使用它的话必须写上 `nullptr` 这一名字. 如, 修改上面的代码为

```cpp
f(nullptr); // 输出为 overload int ptr
```

`nullptr` 不仅仅可以表示空指针的值, 它还有一个独立的类型 `std::nullptr_t`. 当然这一类型的所有实例都相同, 即都是空指针.

空指针类型并不很常用. 它允许引入针对空指针类型的重载. 如

```cpp
void f(int* p) { std::cout << "overload int ptr" << std::endl; }
void f(std::nullptr_t) { std::cout << "overload nullptr" << std::endl; }

int main()
{
    f(nullptr);       // 输出 overload nullptr

    int* p = nullptr; // 虽然 p 是空指针, 但其类型是 int*
    f(p);             // 输出 overload int ptr

    // 可以使用 nullptr_t 定义对象实例, 这些实例都是空指针
    std::nullptr_t q;
    f(q); // 输出 overload nullptr
    return 0;
}
```


## 禁止赋值构造


### 为什么
C++ 受到诟病的一点是每个类型都会有一个复制构造函数, 即使用户不编写之, 编译器也会合成一个. 而某些类型, 比如文件流 `fstream` 又是不可复制的. 在既有标准中, 用户想到各种方法来应对这一编译器 "特性", 典型的做法是将复制构造函数声明为 `private` 访问限制的, 且只声明而不实现它. 如

```cpp
struct NonCopyable {
    NonCopyable() {}
private:
    NonCopyable(NonCopyable const&); // 声明为 private, 没有实现
};

int main()
{
    NonCopyable n;
    NonCopyable m(n);                // 编译错误
    return 0;
}

// 报错信息为: 此类型的复制构造函数为私有
// error: ‘NonCopyable::NonCopyable(const NonCopyable&)’ is private
```

这种封印的手法的问题一是报错词不达意, 二是偶尔在类的内部出现误用时 (类的内部可是能够使用 `private` 复制构造函数的), 它将导致链接错误而非编译错误, 而链接错误往往又是无法看到源代码行号的.


### 有什么
C++11 标准中打算收拾掉这一乱象, 给出一个简单的方案让用户可以明显地指出某个函数不需要了. 如

```cpp
struct NonCopyable {
    NonCopyable() {}
    NonCopyable(NonCopyable const&) = delete;
};

NonCopyable n;
NonCopyable m(n); // 编译失败, 报错为复制构造函数被删除了
                  // use of deleted function ‘NonCopyable::NonCopyable(const NonCopyable&)’
```

也就是在需要删除的函数后加上一个小尾巴 `= delete`, 这样此类型就无法复制构造了. 当然这只是在语法上限制了复制行为, 有关无法复制的类型更详细的特性, 本书将在 "移动语义" 一章将进行讨论.

这一机制除了可以用来禁止合成复制构造函数之外还可以用来取消掉由基类继承而来的函数, 或防止类型转化重载, 如

```cpp
struct Base {
    void print()
    {
        std::cout << "Base" << std::endl;
    }
};

struct Inherit: Base {
    // 在子类中声明父类中出现过的 print() 函数
    // 并标记为 delete, 那么无法从子类对象调用此函数
    void print() = delete;
};

void f(int x) {}
void f(char ch) = delete; // 标记 char 为参数的重载为 delete

int main()
{
    Base b;
    b.print();
    Inherit i;
    i.print();  // 编译错误: print 在子类中被标记为 delete 了

    f(10);      // 正确: 匹配参数为 int 的重载
    f('c');     // 编译错误: 匹配为参数为 char, 但被删除掉的重载
                // 如果没有 f(char) 的声明, 参数将被扩宽为 int 匹配 f(int) 的重载
    return 0;
}
```


## 即写即用都函数定义


C++11 新增的较为复杂的一个新语法就是 lambda 函数对象. 在本节中将简单介绍如何使用基本的 lambda 语法替代一般函数.

### 为什么
在标准库中提供了许多便利的算法函数, 这些算法函数允许用户传入指定的函数作为算法的策略. 比如最常用的算法函数之一的 `std::sort`, 它允许用户传入一个比较器, 表示如何比较两个对象以决定它们的顺序. 例如

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

struct Person {
    int age;
    std::string name;

    Person(int a, std::string const& n)
        : age(a)
        , name(n)
    {}
};

// 根据两个属性分别排序的函数
bool cmp_by_age(Person const& lhs, Person const& rhs)
{
    return lhs.age < rhs.age;
}

bool cmp_by_name(Person const& lhs, Person const& rhs)
{
    return lhs.name < rhs.name;
}

int main()
{
    std::vector<Person> p{
        {24, "lisi"},
        {23, "zhangsan"},
        {25, "wangwu"},
    };
    std::sort(p.begin(), p.end(), cmp_by_age);
    for (auto const& x: p) {
        std::cout << x.name << " : " << x.age << std::endl;
    }
    /* 输出
    zhangsan : 23
    lisi : 24
    wangwu : 25
    */

    std::sort(p.begin(), p.end(), cmp_by_name);
    for (auto const& x: p) {
        std::cout << x.name << " : " << x.age << std::endl;
    }
    /* 输出
    lisi : 24
    wangwu : 25
    zhangsan : 23
    */
    return 0;
}
```

虽然这样可以实现功能, 但显然, 将 `cmp_by_age` 对 `cmp_by_name` 分离为单独的函数*违背了函数的本意* --- 之所以分离出单独定义的函数是为了代码重用和逻辑封装. 而在本例中, 对象的比较方法作为排序逻辑的一环, 本应在 `sort` 的调用处, *单独定义成全局函数反而割裂了代码逻辑.*

再试想实现下面这一逻辑: 在容器中找到第一个 `age` 小于 20 的对象, 如果使用标准库中的 `find_if`, 应写为

```cpp
bool age_less_than_20(Person const& p)
{
    return p.age < 20;
}

// ...
std::vector<int> p;
// ...
auto i = std::find_if(p.begin(), p.end(), age_less_than_20);
if (i != p.end()) {
    std::cout << i->name << " : " << i->age << std::endl;
}
```

然而想必不会有人这么死脑筋, 相对于下面这样的 for 循环, 上面的写法实在是太繁琐了可以认为这是标准库的用户心中的算计和权衡: 像 `sort`, `set_intersection` 这样的算法函数, 即使需要在其他地方定义冗长的函数也无妨, 因为这些算法本身更复杂; 而像 `find_if`, `count_if` 甚至如 `for_each` 这样的函数则不然, 通常情况下, 一个 for 循环足以替代相应的功能

```
for (auto const& x: p) {
    if (x.age < 20) {
        std::cout << x.name << " : " << x.age << std::endl;
        break;
    }
}
```

### 有什么
而在 C++11 中, 用户可以用 lambda 匿名函数这一更简洁的方式来编写并使用这个函数指针, 下面就用这种方法改写上面的例子
```cpp
int main()
{
    std::vector<Person> p{
        {24, "lisi"},
        {23, "zhangsan",
        {25, "wangwu"},
    };

    // 使用匿名函数作为 sort 的比较器参数
    // 这是一个函数, 它以一对方括号开头, 之后是参数列表, 然后是花括号括起的函数体
    // 但它没有名字, 故被称作匿名函数
    std::sort(p.begin(), p.end(),
            /* 从这里开始 */
            [](Person const& lhs, Person const& rhs) // (a)
            {
                return lhs.age < rhs.age;
            }
            /* 到这里结束 */
    );
    for (auto const& x: p) {
        std::cout << x.name << " : " << x.age << std::endl;
    }
    /* 输出

    zhangsan : 23
    lisi : 24
    wangwu : 25

    */

    std::sort(p.begin(), p.end(),
            [](Person const& lhs, Person const& rhs) // (b)
            {
                return lhs.name < rhs.name;
            }
    );
    for (auto const& x: p) {
        std::cout << x.name << " : " << x.age << std::endl;
    }
    /* 输出

    lisi : 24
    wangwu : 25
    zhangsan : 23

    */

    // 类似地, 也可以使用匿名函数作为 find_if 的筛选条件参数
    auto i = std::find_if(p.begin(), p.end(),
            [](Person const& x)                      // (c)
            {
                return x.age < 20;
            }
    );
    if (i == p.end()) {
        std::cout << "no such person" << std::endl;
    }
    /* 输出

    no such person

    */

    p.push_back(Person(16, "xiaoliu"));

    auto j = std::find_if(p.begin(), p.end(),
            [](Person const& x)                      // (d)
            {
                return x.age < 20;
            }
    );
    if (j != p.end()) {
        std::cout << j->name << " : " << j->age << std::endl;
    }
    /* 输出

    xiaoliu : 16

    */

    return 0;
}
```

(a) (b) (c) (d) 各处就是这一新语法. 


## 禁止继承或覆盖

### 为什么
另一可能的需求是防止类型被继承, 在 C++03 中的技巧是将构造函数定义为 `private` 限定, 这样子类无法构造父类部分. 而后对外暴露工厂函数以产生对象. 如

```cpp
struct DontInherit {
    // 对外暴露工厂方法产生实例
    static DontInherit construct()
    {
        return DontInherit();
    }
private:
    // 将自身构造函数设为私有的
    DontInherit() {}
};

struct SubClass: DontInherit {
    // 在子类中, 这一无参默认构造函数将不会被隐式生成
    // 手动加上此构造函数也无法编译
    // SubClass() : DontInherit() {}
};

int main()
{
    // DontInherit 的实例化要借助于工厂方法
    DontInherit d = DontInherit::construct();

    // 但子类将无法实例化, 此处编译失败
    SubClass s;
    return 0;
}
```

### 有什么
在 C++11 中, 不允许类型被继承这一特性直接被编译器所支持, 新引入的关键字为 `final`, 与 Java, C# 等语言中的基本一致 (除了关键字摆放的位置). 它除了*可以禁止类型被继承, 也能禁止单一虚函数被覆盖*. 其语法如下

```cpp
struct Animal {
    virtual void say() = 0;
    virtual void breed() = 0;
    virtual ~Animal() {}
};

struct Bird : Animal {
    // 1.在虚函数后加上 final 关键字, 该虚函数无法被子类覆盖
    void breed() final { std::cout << "lay eggs" << std::endl; }
};

// 2.在类名后加上 final 关键字, 该类无法被继承
struct Duck final : Bird {
    void say() { std::cout << "ga" << std::endl; }

    // 编译错误: 基类的 breed 是 final 的
    void breed() {}
};

// 编译错误: Duck 是 final 的
struct DonaldDuck : Duck {};
```

这一特性*有助于编译器执行优化*. 若子类将其某个虚函数标记为 `final` 修饰, 或者该子类本身是 `final` 修饰的, 那么这些成员函数的调用将被编译器视为非虚函数调用, 这样就不必在运行时去查找虚表了.

除了 `final` 关键字之外, 另一与虚函数有关的关键字 `override` 可以用来确定当前定义的函数是否覆盖了父类的虚函数. 这一关键字不是必须的, *加上的话有助于检查虚函数签名的正确性*.

```cpp
struct Animal {
    virtual void say() = 0;
    virtual void breed() = 0;
    virtual ~Animal() {}

    void drink() {}
};

struct Bird : Animal {
    // 正确: 此函数覆盖了父类中声明的 void breed() 函数
    void breed() override { std::cout << "lay eggs" << std::endl; }

    // 编译错误: 此函数签名与父类中的 breed 函数不同, 多了 int 参数
    void breed(int x) override
    { std::cout << "lay " << x << " eggs" << std::endl; }

    // 编译错误: 此函数签名与父类中的 breed 函数不同, 多了 const 限定
    void breed() const override
    { std::cout << "lay eggs" << std::endl; }

    // 编译错误: 父类中的 drink() 函数并不是虚函数
    void drink() override {}
};
```

## 编译时断言

在 C++03 标准中, 另一由于没有编译器支持而实现得很繁琐的简单需求是编译时断言, 在 C++11 中则直接将关键字 `static_assert` (C 语言中为 `_Static_assert`) 加入语言本身, 由编译器来检查某个编译时条件是否满足. 其语法如下

```cpp
// 在编译时常量 BOOL_CONSTANT 为 false 时给出一个编译错误, 错误信息为 ERROR_MESSAGE
static_assert(BOOL_CONSTANT, ERROR_MESSAGE);

// 例
static_assert(true, "this is ok");
static_assert(false, "cause a compile error"); // 此行会产生编译错误
static_assert(sizeof(int) == 4, "int is not 4 bytes");
```


## 函数无异常声明
### 为什么
C++03 中, 在函数签名中可以增加一个 `throw(except_a, except_b, /* ... */)` 的抛出声明, 表示函数*只会*抛出这些异常类型, 而一个空的 `throw()` 表示函数*不会*抛出异常. 如

```cpp
void f() throw(std::runtime_error); // f 可能抛出 std::runtime_error, 不可能抛出其他类型异常
void g() throw();                   // g 不会抛出任何异常
```


### 有什么
而 C++11 中新增了关键字 `noexcept`, 其功能之一是*将上述抛出声明简化为二元形式, 即可能抛出, 或不可能抛出*. 其语法形式是在函数签名最后加上 `noexcept(bool 常量)`, 该参数 `bool` 常量表示此函数是否不会抛出异常, 这一常量默认为 `true` (但如果根本不写 `noexcept` 的话, 表示该函数可以抛出异常).

```cpp
void f() noexcept(true);     // f 不会抛出异常
void g(int) noexcept(false); // g 可能抛出异常
void h() noexcept            // h 不会抛出异常; 这时不需要圆括号
void k();                    // 什么也不写: k 可能抛出异常
```

*声明一个函数不会抛出异常有利于编译器生成更简单的可执行文件*. 但如果一个带有 `noexcept(true)` 声明的函数中直接或间接抛出了异常, `std::terminate` 会*被立即调用*, 默认情况下意味着进程将马上结束.

该关键字的另一作用是*在编译时评估一个函数调用是否会抛出异常*, 并返回一个 `bool` 值常量. 这个函数表达式只在编译时使用, 不会被运行求值, 类似 `sizeof` 一样.

```cpp
// 沿用上面的定义
std::cout << noexcept(f()) << std::endl;  // 1
std::cout << noexcept(g(0)) << std::endl; // 0
```

将这两者结合起来, 可以实现一个需求: 如果函数 X 中只调用了函数 Y, 那么函数 X 是否抛出异常取决于 Y 是否抛出异常. 写成代码是这样的

```cpp
void f() noexcept;

void g() noexcept(noexcept(f()))
//                ^^^^^^^^^^^^^  f 不会抛出异常, 故此表达式为 true
//       noexcept(    true     ) 因此这里等价于声明此函数不抛出异常
{
    f();
}

template <typename T>            // 泛型中的运用
void h() noexcept(noexcept(T())) // h 函数是否抛出异常取决于 T 类型构造时产生异常
{ /* ... */ }
```

这是一个美好的愿景, 但在实际运用时, 如果要将一个函数所有调用的其他函数都写进 `noexcept` 声明中的话, 推广这一声明是极其困难甚至不可能完成的. 最坏的情况下甚至可能在 `noexcept` 里的部分相当于把整个函数重新实现一遍.

因此, 实际上只有一些很简单的函数才会加上这一声明. 另外, *析构函数默认都带有* `noexcept(true)` 声明.

需要注意的是, 使用 `noexcept(true)` 以及 `throw()` 声明*都不会强制编译器检查函数是否真的不会抛出异常*, 比如以下代码

```cpp
void f(int x) noexcept
{
    if (x < 0) {
        throw std::out_of_range("");
    }
}
```

虽然在函数体中很明确地有一句 `throw`, 但是编译器并不会在处理这段代码时报错.

## 基于范围的循环

### 为什么

在 C 和 C++ 里有两类循环语句, 一是 `while` 或 `do`-`while`, 另一是 `for` 循环. 相对于 `while` 系的按单一条件循环的语法, `for` 的不同之处在于多出了*迭代初始化*和*迭代变更*两个成分. 如

```cpp
size_t const SZ = 10;
int arry[SZ];
for (size_t i = 0; i < SZ; ++i) {
    arry[i] = i * 2 + 1;
}

// 等价于以下 while 循环

size_t j = 0;
while (j < SZ) {
    arry[j] = j * 2 + 1;
    ++j;
}
```

由于开发者之间对循环的功能达成了共识, 上述 `for` 循环一眼就能看出来是在逐个访问数组的每个元素, 因此相对于使用 `while`, `for` 循环在语义上更为明确, 容易理解.

不过, 在 C++ 中由于标准容器的引入, 这种 `for` 循环会*由于一些容器类型无法按照索引下标随机访问而无法使用*.  因此标准库中设立了迭代器 (iterator) 的机制来帮助用户遍历任何容器中的元素. 如

```cpp
std::set<int> s;

for (size_t i = 0; i < s.size(); ++i) {
    // 编译错误: std::set 集合类型不具备按照下标随机访问的能力
    int val = s[i];
}

for (std::set<int>::iterator i = s.begin(); i != s.end(); ++i) {
    // 正确: 通过迭代器访问元素
    int val = *i;
    std::cout << val << std::endl;
}
```


### 有什么
相对而言这种写法还是容易接受的. 不过, C++11 中又设计了一个新语法, 让针对容器迭代语义进一步简化. 这种基于范围的循环 (range-based loop) 语法如下

```cpp
std::set<int> s;

// 在 for 关键字的括号中使用
// 类型名 标识符 冒号 (:) 要进行迭代的容器 (任何表达式)
// 这一写法与上面传统的 for 循环写法完全等价
for (int val: s) {
    std::cout << val << std::endl;
}
```

编译器处理这一语法的机制实际上就是调用给定的容器表达式的 `begin()` 和 `end()` 函数产生迭代器对象, 然后调用迭代器对象的寻址算符重载 (前置 `operator*()` 重载) 获得相应的元素, 赋值给 `for` 的括号里定义的标识符.

如果提供容器的表达式是个函数调用, 这个调用只会被执行一次. 换言之, 这个表达式只会在循环开始前被求值一次.

```cpp
std::vector<std::string> make_vector()
{
    std::cout << "call make_vector" << std::endl;
    std::vector<std::string> x;
    x.push_back("hello");
    x.push_back("world");
    return x;
}

for (std::string s: make_vector()) {
    std::cout << "s= " << s << std::endl;
}

// 等价于以下代码, make_vector() 函数调用只有一次
std::vector<std::string> __ranged_for_loop_expr(make_vector());
for (std::vector<std::string>::iterator i = __ranged_for_loop_expr.begin();
     i != __ranged_for_loop_expr.end();
     ++i)
{
    std::string s = *i;
    // ...
}

/* 输出

call make_vector
s= hello
s= world

*/
```

另外, 像上面这样写, 每次迭代返回的 `std::string` 对象都会被复制到循环中定义的 `s` 变量里去, 这当然有些性能损耗. 在不需要复制的情况下, 可以将这一变量定义为引用.

```cpp
// 以引用的方式使用迭代的元素
for (std::string const& s: make_vector()) {
    std::cout << "s= " << s << std::endl;
}

// 也可以去掉引用的 const 限制; 这样的话, 循环体中更改引用意味着直接修改了容器内元素的内容
std::vector<std::string> v(make_vector());
for (std::string& s: v) {
    s += " !";
}

for (std::string const& s: v) {
    std::cout << "s= " << s << std::endl;
}

/* 更改了元素之后, 以上一个 for 循环的输出为

s= hello !
s= world !

*/
```

然而, 这一方便的新特性并*没有顾及到逆向迭代*, 也就是说无法通过逆向迭代器 (reverse iterator) 对容器内容进行循环. 不过, 可以在需要的时候加上这样一套工具类型 (需要用户自己添加; STL 中直到 C++17 都没有提供)

``` cpp
template <typename C>
struct reverse_iteration {
    C& c;
    reverse_iteration(C& c_): c(c_) {}

    // 其 begin end 函数返回所引用的容器的 rbegin() rend() 以产生逆向迭代器
    typename C::reverse_iterator begin() { return c.rbegin(); }
    typename C::reverse_iterator end() { return c.rend(); }
};

template <typename C>
struct reverse_iteration<C const> { // 针对 const 限定的偏特化
    C const& c;
    reverse_iteration(C const& c_): c(c_) {}

    // 此偏特化使用 const_reverse_iterator
    typename C::const_reverse_iterator begin() { return c.rbegin(); }
    typename C::const_reverse_iterator end() { return c.rend(); }
};

template <typename C>
reverse_iteration<C> make_reverse(C& c)
{
    return reverse_iteration<C>(c);
}

std::vector<std::string> v(make_vector());
for (std::string const& s: make_reverse(v)) {
    std::cout << "s= " << s << std::endl;
}

/* 输出

call make_vector
s= world
s= hello

*/
```

从这个例子中也可以看出, 如果用户自己实现了一个容器类型, 或者哪怕是上述这样的包装类型, 只要有合适的 `begin()` 和 `end()` 成员函数实现, 就能用在基于范围的循环语法中.


## 嵌套模板结束符号


在 C++ 中, 若使用一个模板类型的特化作为另一个模板的类型参数, 连续两个模板的结束符号 `>` 会合在一起变为右移算符 `>>`, 如

```cpp
std::vector<std::pair<int, int>> x;
//                            ^^
std::vector<std::pair<int, std::set<std::string>>> y;
//                                             ^^^ 还可能出现无符号右移算符
```

在 C++03 中这种写法是不允许的, 模板结束处的连续尖括号之间必须加上空格. 而 C++11 标准则允许这样写, 即上述代码可以被支持 C++11 的编译器正确解析. 不过此改动也不是完美的, 这一规则加入后一些原来可以编译通过的代码反而会出错. 如

```cpp
template <int I>
struct A {};

// 使用右移运算表达式特化接受整型参数的模板
// C++03 中可以编译通过, C++11 中报错
A<3 >> 1> x;
// 两个标准中都认可的写法, 在表达式两边加上括号
A<(3 >> 1)> x;
```

当然也不能说这是设计上的不周, 现实中像上面这样偏偏用到一个右移运算来特化的例子屈指可数, 而嵌套模板的使用则比比皆是. 所以这只是牺牲不常见的用况来方便更常见的写法, 还是很有道理的.



## 新的类型别名机制

### 为什么
在编写代码时, 可以为一些类型设置别名, 使得代码更容易理解. 在既有标准中, 可以使用 `typedef` 关键字定义类型的别名. 如

```cpp
typedef unsigned char byte;
```

以上代码中将类型 `unsigned char` 定义为 `byte`. 就这样直白的别名设置而言, `typedef` 还算看得过去, 但下面这些情况就略显晦涩了

```cpp
typedef int int_arr[10];
typedef int (* fn_type)(int, int);
```

其中第一个别名设置是将 10 个 `int` 构成的数组定义成名为 `int_arr` 类型; 第二个则定义了名为 `fn_type` 类型, 它的类型是函数指针, 这类函数指针指向的函数接受两个 `int` 参数, 返回一个 `int`. 这两种类型别名的语法都将名字放在了语句中间某个位置, 读起来并不直观.

### 有什么
为了改善这一弊端, 在 C++11 中为 `using` 指派了一个新功能, 使得用户可以用更加清晰的方式为类型指定别名. 以上面三种类型别名为例, 它们可写作

```cpp
// 语法形式为
// using 别名 = 类型
using byte = unsigned char;         // 普通类型, 直接写在等号右侧
using int_arr = int[10];            // 数组类型, 用类型名加上方括号和数量
using fn_type = int (*)(int, int);  // 函数指针类型, 在返回值类型和参数列表之间加上 (*)
```

这一语法形式与 `typedef` 不同的是, 在类型别名和实际的类型之间, 显式地插入了一个等号, 等号左边的标识符就是别名. 如此一来, 用户在阅读代码时就能立即明白为怎样的类型设置了什么别名.

除了提供更为明了的类型别名语法, `using` 还可支持泛型类型定义, 如

```cpp
// 语法: 在 template < ... > 泛型声明后立即加上 using 语句
// 泛型参数 T 必须指定, 而 Alloc 有默认值 std::allocator<T>
template <typename T, typename Alloc = std::allocator<T>>
using vec_iter = typename std::vector<T, Alloc>::iterator;

std::vector<int> x;
// 使用 int 特化 vec_iter 别名, 另一泛型参数是默认的 std::allocator<int>
// 因此特化出的类型 vec_iter<int> 为
// std::vector<int, std::allocator<int>>::iterator
vec_iter<int> i = x.begin();
```


##  对象初始化的改进

> 统一的对象初始化语法

C++11 开始统一千奇百怪的对象初始化语法了, 同时各种 STL 容器增加预设元素的初始化方式.

### 为什么
这个故事还要从 C 的一个语法点说起. 在 C 语言中, 如下的代码

```cpp
struct Point {
    int x;
    int y;
};

Point p = {0, 1};
int a[] = {0, 1};
```

同样的 `{0, 1}` 在编译器看来语义是截然不同的, 对 `p` 而言是初始化其成员, 对 `a` 而言则既要推导 `a` 的大小又要设定其元素的值.

而在 C++03 中, 如果为 `Point` 定义一个构造函数, 以下写法就不正确了

```cpp
struct Point {
    int x;
    int y;

    Point(int x_, int y_): x(x_), y(y_) {}
};

Point p = {0, 1}; // 错误: 非 POD 的类型不能用初始化列表构造
```

不过, 只要用 C++11 的编译器, 上述代码中的编译错误就立即消失了. 实际上, C++11 中添加以上语法作为一则初始化语法, 或者说调用构造函数的语法. 如

```cpp
Point p = {0, 1};   // 与初始化 POD 的语法相同
Point q{0, 1};      // 亦可省去等号

// 这两种写法均等价于传统写法
Point r(0, 1);
```

也就是说, 针对构造函数, 可以使用花括号替代圆括号. 这一特性还有助于减少调用无参构造函数时的书写错误. 例如

```cpp
struct Point {
    // ...
    Point() : x(0), y(0) {}
};

Point p();
```

上例中定义 `p` 的实际上并不是调用无参构造函数初始化一个 `Point` 对象, 实际上它是一个函数前置声明, 该函数没有参数并返回 `Point`. 这一新人杀手级语言 "特性" 导致的错误通常在修改代码时, 去掉了构造参数都但没有去掉括号而产生. 而在新语法中, 它可以这样写

```cpp
Point p{};
```

另外, 用户可以利用这一语法特性简化一些 `return` 语句. 当函数需要返回以特定构造函数构造的对象时, 可以使用花括号语法, 而不必写出类名. 如

```cpp
std::string make_string()
{
    return {};
    // 而不需要写
    // return std::string();
}

Point make_point(int x, int y)
{
    return {x, y};
    // 而不需要写
    // return Point{x, y};
}
```

除了以上单个对象的构造语法有所更改, 批量构造对象的语法语义也变得不同. 类似 `int a[] = {0, 1};` 这一例子中, 数组初始化时给出的花括号括起的整数值序列, 它不仅仅可以用于构造数组, 现在也可以用于构造容器了. 比如

```cpp
std::vector<int> x = {0, 1};
// 当然, 也可以去掉等号
std::vector<int> y{2, 3, 5, 7};

for (int i: x) {
    std::cout << "x contains " << i << std::endl;
}
/* 输出
x contains 0
x contains 1
*/

for (int i: y) {
    std::cout << "y contains " << i << std::endl;
}
/* 输出
y contains 2
y contains 3
y contains 5
y contains 7
*/
```

如果编译时知道一个容器里该有些什么东西, 直接写到构造函数里, 比先定义出容器再一个个添加要简单多了.

这一语法看起来很奇特, 不过并不神秘, 也不仅仅被 STL 容器所用 (不仅 `vector`, 其他所有的 STL 容器都支持这样构造). 在 C++11 中, 编译器处理到花括号扩起的类型相同的表达式时, 就会试图将其转换为称作 `std::initializer_list` 的泛型类的实例, 而 STL 容器之所以可以这样构造, 无非是因为它们都有参数 `initializer_list<value_type>` 的构造函数. 当然, 不仅构造函数可将初始化列表当作参数, 一般函数也可以, 如

```cpp
#include <iostream>
#include <initializer_list>

// 以 initializer_list 为参数的函数, 这是一个泛型类型, 需要特化
void f(std::initializer_list<int> x)
{
    // initializer_list 实例的 size() begin() end() 函数使它可以表现得像一个标准容器
    std::cout << "initializer_list size=" << x.size() << std::endl;
    for (int i: x) {
        std::cout << "-- element " << i << std::endl;
    }
}

int main()
{
    f({1, 1, 2, 3});
    /* 输出

    initializer_list size=4
    -- element 1
    -- element 1
    -- element 2
    -- element 3

    */

    f({});
    /* 输出

    initializer_list size=0

    */
    return 0;
}
```

而像 `std::map` 这样, 元素类型不是一个单一的值而是键值对, 在初始化的时候就需要混合使用初始化列表和之前介绍的用花括号括起构造参数的做法

```cpp
std::pair<std::string, int> jan{"jan", 1};
std::map<std::string, int> x{ // map<std::string, int> 中的值类型是 pair<std::string const, int>

    jan,                      // 可以使用一个 pair 实例来复制构造

    {"feb", 2},               // 也可以使用花括号括起的两个值调用构造函数
    {"mar", 3},
};
std::cout << x["feb"] << std::endl; // 2
```

不过这样看起来, 花括号的作用又非常混乱了. 即, *如果花括号中各个元素的类型一致, 那么它被编译器视作一个初始化列表实例; 否则编译器将根据花括号中各表达式的类型, 尝试决议出一个构造函数重载进行调用.*

然而, 假如像上面 `Point` 类那样, 其构造函数的参数类型恰好都是相同的, 构造参数看起来像个初始化列表, 编译器不会很困惑吗?

确实初始化列表的语法仍有歧义. 在这种情况下, 用初始化列表语法去调用函数时, 将*优先匹配*以 `initializer_list` 为参数的重载, 若不存在此重载才会以其他重载作为备选. 比如下面的例子

```cpp
void f(std::initializer_list<int> x) // (a)
{
    std::cout << "initializer_list" << std::endl;
}

void f(Point p)                      // (b)
{
    std::cout << "point" << std::endl;
}

int main()
{
    f({0, 0});                       // 输出: initializer_list
    return 0;
}
```

例子中定义了两个重载, 重载决议会判定为调用 (a), 而将 (a) 删除掉的话, 则重载 (b) 会被执行.

### 委托构造函数

当为一个成员很多的类型编写一组构造函数重载时, 需要给每个构造函数都写上长长的初始化列表. 如

```cpp
struct Person {
    std::string first_name;
    std::string last_name;
    std::string address;
    int score;
    int age;

    // 显式初始化每个成员的完整初始化
    Person(std::string const& fname, std::string lname, std::string const& addr,
           int s, int a)
        : first_name(fname)
        , last_name(lname)
        , address(addr)
        , score(s)
        , age(a)
    {}

    // 只为部分成员执行默认初始化
    // 传统的做法仍然需要将一些原生成员放到初始化列表中
    Person(std::string const& fname, std::string lname, int a)
        : first_name(fname)
        , last_name(lname)
                            // address 作为 string 类型成员, 有构造函数保证其正确初始化, 不必写入初始化列表
        , score(0)          // 但整数或指针等原生类型需要显式初始化
        , age(a)
    {}
};
```

这种写法一方面初始化列表的代码显得臃肿不堪, 另一方面维护难度也很大, 如果新增原生类型成员, 每个构造函数的初始化列表里都需要加上对其的初始化.

在 C++11 中新增了一种初始化列表的书写方式, 即允许一个构造函数调用另一个构造函数作为初始化对象的手段, 如以上代码中的第二个构造函数重载可以调用第一个重载. 如

```cpp
struct Person {
    // ...

    Person(std::string const& fname, std::string lname, std::string const& addr,
           int s, int a)
        : first_name(fname)
        , last_name(lname)
        , address(addr)
        , score(s)
        , age(a)
    {}

    // 使用委托构造函数的做法是, 将另一构造函数的调用作为唯一成分写在初始化列表中
    // 这个例子中, 上一个构造函数重载中初始化了所有成员
    // 其他构造函数都可调用上一构造函数重载, 不用担心漏掉个别成员的初始化
    Person(std::string const& fname, std::string lname, int a)
        : Person(fname, lname, "", 0, a)
    {}
};
```

需要注意的是, C++ 构造函数对成员初始化的要求是不重不漏, 当委托另一构造函数进行构造后, 隐含着 "所有成员都已被正确初始化" 这一结果, 因此不能继续在初始化列表中加任何成分, 或者委托调用其他的构造函数. 例如下面是一些可能误用的情况

```cpp
struct Person {
    // ...
    Person(std::string const& fname, std::string lname, int a)
        : Person(fname, lname, "", 0, a)
        , age(0) // 错误: 不能再初始化其他成员了
    {}
};

struct Base { int x; Base(int x_): x(x_) {} };

struct Inherit : Base {
    int y;

    // 正确: 先调用父类构造函数初始化父类的部分, 再初始化本身的成员
    Inherit(int x_, int y_): Base(x_), y(y_) {}
    // 正确: 委托构造
    Inherit(int x_): Inherit(x_, 0) {}

    Inherit(int x_)
        : Base(x_)
        , Inherit(x_, 0) // 错误, 对父类初始化后, 不能再使用委托构造
    {}
};
```

### 成员缺省初始化

另一可以简化构造函数代码的特性则是为那些无论如何都需要初始化, 并且有固定初始化模式的成员设置缺省的初始化方式. 比如

```cpp
std::string current_date();

class Logger {
    // 为这个 ofstream 类型成员设定缺省的初始化方式
    std::ofstream output{"logs/log-" + current_date() + ".log"};

    int id;
    std::string format;
public:
    Logger(int id)                              // (a)
        : id(id)
    {}

    Logger(int id, std::string const& fmt);     // (b)
        : id(id)
        , format(fmt)
    {}

    Logger(std::string const& filename, int id) // (c)
        : output(filename, std::ios_base::app);
        , id(id)
    {}
};
```

在上例中有三个构造函数重载, 其中 (a) 和 (b) 都没有显式初始化 `output` 成员, 但是 `output` 成员其默认构造函数又不能产生一个可以正常工作的文件流对象, 于是就需要给出一个缺省的初始化方式, 这种初始化就是将构造参数直接写在成员声明处. 如果像 (c) 重载那样指定了 `output` 的初始化方法, 那么指定的缺省初始化就不会被执行.

从例子中还可以看出, 虽然成员初始化参数的模式只能设定一种, 但并不妨碍从这种模式中得出不同的实参, 如果 `current_date()` 这个函数能返回不一样的值, 那么构造不同 `Logger` 实例时其 `output` 指定的文件名仍可以是不同的.

以上写法中不能将初始化的花括号改成圆括号, 否则语法上会被编译器识别为成员函数定义.

```
struct A {
    int m(0); // 错误: 这会被编译器认为是定义函数
    int n{0}; // 正确: 使用花括号括起参数
    int p{};  // 正确: 使用花括号, 无初始化参数, int 被置为 0
};
```

可以复制构造的成员亦可用等号设定初始值^[[使用等号的语法会让编译器认为是复制构造, 但编译器通常会优化掉. 恰好例子中的流对象是不可复制构造的, 因此只有上面这种写法.]]. 如下面例子中的写法也都是正确的.

```
struct A {
    int m = 0;                           // 直接使用等号加上初始值
    std::string s = "1";                 // 相当于 = std::string("1")
    std::string t = std::string(3, '2'); // 显式写作复制构造形式
};
```

## 类型推导
>略

