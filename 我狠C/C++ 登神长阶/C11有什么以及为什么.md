# 语言与语法功能改进


## 空指针

### 为什么

 C 和 C++ 中在处理空指针的时候却并没有起到表率作用. 用户一般会用 `NULL` 来表示空指针, 但它并不是关键字, 而是一个宏. 在 C 中它通常被定义为 `(void*)0`, 而 C++ 中因为禁止 `void*` 指针类型向其他指针类型隐式转换, 因此在既有的编译器实现中它通常被定义为整数字面量 0, 或是其它不那么明确的指针常量.

这是个很容易让编译器产生误解的规则. 比如在 C++ 中以 `NULL` 作为实参时, 可能使得重载决议出错

```cpp
void f(int x) { std::cout << "overload int" << std::endl; }
void f(int* p) { std::cout << "overload int ptr" << std::endl; }

f(NULL); // NULL 被定义为 0 时输出 "overload int", 而另一些实现会报重载决议错误
         // 而不会直接决议为对 f(int*) 的调用
```

### 有什么
在 C++11 中引入新的空指针**关键字** `nullptr` 来解决这一问题. 不过, 考虑到向前兼容性, `NULL` 宏的定义并没有被直接改成这一关键字, 要使用它的话必须写上 `nullptr` 这一名字. 如, 修改上面的代码为

```cpp
f(nullptr); // 输出为 overload int ptr
```

`nullptr` 不仅仅可以表示空指针的值, 它还有一个独立的类型 `std::nullptr_t`. 当然这一类型的所有实例都相同, 即都是空指针.

空指针类型并不很常用. 它允许引入针对空指针类型的重载. 如

```cpp
void f(int* p) { std::cout << "overload int ptr" << std::endl; }
void f(std::nullptr_t) { std::cout << "overload nullptr" << std::endl; }

int main()
{
    f(nullptr);       // 输出 overload nullptr

    int* p = nullptr; // 虽然 p 是空指针, 但其类型是 int*
    f(p);             // 输出 overload int ptr

    // 可以使用 nullptr_t 定义对象实例, 这些实例都是空指针
    std::nullptr_t q;
    f(q); // 输出 overload nullptr
    return 0;
}
```


## 禁止赋值构造


### 为什么
C++ 受到诟病的一点是每个类型都会有一个复制构造函数, 即使用户不编写之, 编译器也会合成一个. 而某些类型, 比如文件流 `fstream` 又是不可复制的. 在既有标准中, 用户想到各种方法来应对这一编译器 "特性", 典型的做法是将复制构造函数声明为 `private` 访问限制的, 且只声明而不实现它. 如

```cpp
struct NonCopyable {
    NonCopyable() {}
private:
    NonCopyable(NonCopyable const&); // 声明为 private, 没有实现
};

int main()
{
    NonCopyable n;
    NonCopyable m(n);                // 编译错误
    return 0;
}

// 报错信息为: 此类型的复制构造函数为私有
// error: ‘NonCopyable::NonCopyable(const NonCopyable&)’ is private
```

这种封印的手法的问题一是报错词不达意, 二是偶尔在类的内部出现误用时 (类的内部可是能够使用 `private` 复制构造函数的), 它将导致链接错误而非编译错误, 而链接错误往往又是无法看到源代码行号的.


### 有什么
C++11 标准中打算收拾掉这一乱象, 给出一个简单的方案让用户可以明显地指出某个函数不需要了. 如

```cpp
struct NonCopyable {
    NonCopyable() {}
    NonCopyable(NonCopyable const&) = delete;
};

NonCopyable n;
NonCopyable m(n); // 编译失败, 报错为复制构造函数被删除了
                  // use of deleted function ‘NonCopyable::NonCopyable(const NonCopyable&)’
```

也就是在需要删除的函数后加上一个小尾巴 `= delete`, 这样此类型就无法复制构造了. 当然这只是在语法上限制了复制行为, 有关无法复制的类型更详细的特性, 本书将在 "移动语义" 一章将进行讨论.

这一机制除了可以用来禁止合成复制构造函数之外还可以用来取消掉由基类继承而来的函数, 或防止类型转化重载, 如

```cpp
struct Base {
    void print()
    {
        std::cout << "Base" << std::endl;
    }
};

struct Inherit: Base {
    // 在子类中声明父类中出现过的 print() 函数
    // 并标记为 delete, 那么无法从子类对象调用此函数
    void print() = delete;
};

void f(int x) {}
void f(char ch) = delete; // 标记 char 为参数的重载为 delete

int main()
{
    Base b;
    b.print();
    Inherit i;
    i.print();  // 编译错误: print 在子类中被标记为 delete 了

    f(10);      // 正确: 匹配参数为 int 的重载
    f('c');     // 编译错误: 匹配为参数为 char, 但被删除掉的重载
                // 如果没有 f(char) 的声明, 参数将被扩宽为 int 匹配 f(int) 的重载
    return 0;
}
```


## 即写即用都函数定义


C++11 新增的较为复杂的一个新语法就是 lambda 函数对象. 在本节中将简单介绍如何使用基本的 lambda 语法替代一般函数.

### 为什么
在标准库中提供了许多便利的算法函数, 这些算法函数允许用户传入指定的函数作为算法的策略. 比如最常用的算法函数之一的 `std::sort`, 它允许用户传入一个比较器, 表示如何比较两个对象以决定它们的顺序. 例如

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

struct Person {
    int age;
    std::string name;

    Person(int a, std::string const& n)
        : age(a)
        , name(n)
    {}
};

// 根据两个属性分别排序的函数
bool cmp_by_age(Person const& lhs, Person const& rhs)
{
    return lhs.age < rhs.age;
}

bool cmp_by_name(Person const& lhs, Person const& rhs)
{
    return lhs.name < rhs.name;
}

int main()
{
    std::vector<Person> p{
        {24, "lisi"},
        {23, "zhangsan"},
        {25, "wangwu"},
    };
    std::sort(p.begin(), p.end(), cmp_by_age);
    for (auto const& x: p) {
        std::cout << x.name << " : " << x.age << std::endl;
    }
    /* 输出
    zhangsan : 23
    lisi : 24
    wangwu : 25
    */

    std::sort(p.begin(), p.end(), cmp_by_name);
    for (auto const& x: p) {
        std::cout << x.name << " : " << x.age << std::endl;
    }
    /* 输出
    lisi : 24
    wangwu : 25
    zhangsan : 23
    */
    return 0;
}
```

虽然这样可以实现功能, 但显然, 将 `cmp_by_age` 对 `cmp_by_name` 分离为单独的函数*违背了函数的本意* --- 之所以分离出单独定义的函数是为了代码重用和逻辑封装. 而在本例中, 对象的比较方法作为排序逻辑的一环, 本应在 `sort` 的调用处, *单独定义成全局函数反而割裂了代码逻辑.*

再试想实现下面这一逻辑: 在容器中找到第一个 `age` 小于 20 的对象, 如果使用标准库中的 `find_if`, 应写为

```cpp
bool age_less_than_20(Person const& p)
{
    return p.age < 20;
}

// ...
std::vector<int> p;
// ...
auto i = std::find_if(p.begin(), p.end(), age_less_than_20);
if (i != p.end()) {
    std::cout << i->name << " : " << i->age << std::endl;
}
```

然而想必不会有人这么死脑筋, 相对于下面这样的 for 循环, 上面的写法实在是太繁琐了可以认为这是标准库的用户心中的算计和权衡: 像 `sort`, `set_intersection` 这样的算法函数, 即使需要在其他地方定义冗长的函数也无妨, 因为这些算法本身更复杂; 而像 `find_if`, `count_if` 甚至如 `for_each` 这样的函数则不然, 通常情况下, 一个 for 循环足以替代相应的功能

```
for (auto const& x: p) {
    if (x.age < 20) {
        std::cout << x.name << " : " << x.age << std::endl;
        break;
    }
}
```

### 有什么
而在 C++11 中, 用户可以用 lambda 匿名函数这一更简洁的方式来编写并使用这个函数指针, 下面就用这种方法改写上面的例子
```cpp
int main()
{
    std::vector<Person> p{
        {24, "lisi"},
        {23, "zhangsan",
        {25, "wangwu"},
    };

    // 使用匿名函数作为 sort 的比较器参数
    // 这是一个函数, 它以一对方括号开头, 之后是参数列表, 然后是花括号括起的函数体
    // 但它没有名字, 故被称作匿名函数
    std::sort(p.begin(), p.end(),
            /* 从这里开始 */
            [](Person const& lhs, Person const& rhs) // (a)
            {
                return lhs.age < rhs.age;
            }
            /* 到这里结束 */
    );
    for (auto const& x: p) {
        std::cout << x.name << " : " << x.age << std::endl;
    }
    /* 输出

    zhangsan : 23
    lisi : 24
    wangwu : 25

    */

    std::sort(p.begin(), p.end(),
            [](Person const& lhs, Person const& rhs) // (b)
            {
                return lhs.name < rhs.name;
            }
    );
    for (auto const& x: p) {
        std::cout << x.name << " : " << x.age << std::endl;
    }
    /* 输出

    lisi : 24
    wangwu : 25
    zhangsan : 23

    */

    // 类似地, 也可以使用匿名函数作为 find_if 的筛选条件参数
    auto i = std::find_if(p.begin(), p.end(),
            [](Person const& x)                      // (c)
            {
                return x.age < 20;
            }
    );
    if (i == p.end()) {
        std::cout << "no such person" << std::endl;
    }
    /* 输出

    no such person

    */

    p.push_back(Person(16, "xiaoliu"));

    auto j = std::find_if(p.begin(), p.end(),
            [](Person const& x)                      // (d)
            {
                return x.age < 20;
            }
    );
    if (j != p.end()) {
        std::cout << j->name << " : " << j->age << std::endl;
    }
    /* 输出

    xiaoliu : 16

    */

    return 0;
}
```

(a) (b) (c) (d) 各处就是这一新语法. 


## 禁止继承或覆盖

### 为什么
另一可能的需求是防止类型被继承, 在 C++03 中的技巧是将构造函数定义为 `private` 限定, 这样子类无法构造父类部分. 而后对外暴露工厂函数以产生对象. 如

```cpp
struct DontInherit {
    // 对外暴露工厂方法产生实例
    static DontInherit construct()
    {
        return DontInherit();
    }
private:
    // 将自身构造函数设为私有的
    DontInherit() {}
};

struct SubClass: DontInherit {
    // 在子类中, 这一无参默认构造函数将不会被隐式生成
    // 手动加上此构造函数也无法编译
    // SubClass() : DontInherit() {}
};

int main()
{
    // DontInherit 的实例化要借助于工厂方法
    DontInherit d = DontInherit::construct();

    // 但子类将无法实例化, 此处编译失败
    SubClass s;
    return 0;
}
```

### 有什么
在 C++11 中, 不允许类型被继承这一特性直接被编译器所支持, 新引入的关键字为 `final`, 与 Java, C# 等语言中的基本一致 (除了关键字摆放的位置). 它除了*可以禁止类型被继承, 也能禁止单一虚函数被覆盖*. 其语法如下

```cpp
struct Animal {
    virtual void say() = 0;
    virtual void breed() = 0;
    virtual ~Animal() {}
};

struct Bird : Animal {
    // 1.在虚函数后加上 final 关键字, 该虚函数无法被子类覆盖
    void breed() final { std::cout << "lay eggs" << std::endl; }
};

// 2.在类名后加上 final 关键字, 该类无法被继承
struct Duck final : Bird {
    void say() { std::cout << "ga" << std::endl; }

    // 编译错误: 基类的 breed 是 final 的
    void breed() {}
};

// 编译错误: Duck 是 final 的
struct DonaldDuck : Duck {};
```

这一特性*有助于编译器执行优化*. 若子类将其某个虚函数标记为 `final` 修饰, 或者该子类本身是 `final` 修饰的, 那么这些成员函数的调用将被编译器视为非虚函数调用, 这样就不必在运行时去查找虚表了.

除了 `final` 关键字之外, 另一与虚函数有关的关键字 `override` 可以用来确定当前定义的函数是否覆盖了父类的虚函数. 这一关键字不是必须的, *加上的话有助于检查虚函数签名的正确性*.

```cpp
struct Animal {
    virtual void say() = 0;
    virtual void breed() = 0;
    virtual ~Animal() {}

    void drink() {}
};

struct Bird : Animal {
    // 正确: 此函数覆盖了父类中声明的 void breed() 函数
    void breed() override { std::cout << "lay eggs" << std::endl; }

    // 编译错误: 此函数签名与父类中的 breed 函数不同, 多了 int 参数
    void breed(int x) override
    { std::cout << "lay " << x << " eggs" << std::endl; }

    // 编译错误: 此函数签名与父类中的 breed 函数不同, 多了 const 限定
    void breed() const override
    { std::cout << "lay eggs" << std::endl; }

    // 编译错误: 父类中的 drink() 函数并不是虚函数
    void drink() override {}
};
```

## 编译时断言

在 C++03 标准中, 另一由于没有编译器支持而实现得很繁琐的简单需求是编译时断言, 在 C++11 中则直接将关键字 `static_assert` (C 语言中为 `_Static_assert`) 加入语言本身, 由编译器来检查某个编译时条件是否满足. 其语法如下

```cpp
// 在编译时常量 BOOL_CONSTANT 为 false 时给出一个编译错误, 错误信息为 ERROR_MESSAGE
static_assert(BOOL_CONSTANT, ERROR_MESSAGE);

// 例
static_assert(true, "this is ok");
static_assert(false, "cause a compile error"); // 此行会产生编译错误
static_assert(sizeof(int) == 4, "int is not 4 bytes");
```


## 函数无异常声明
### 为什么
C++03 中, 在函数签名中可以增加一个 `throw(except_a, except_b, /* ... */)` 的抛出声明, 表示函数*只会*抛出这些异常类型, 而一个空的 `throw()` 表示函数*不会*抛出异常. 如

```cpp
void f() throw(std::runtime_error); // f 可能抛出 std::runtime_error, 不可能抛出其他类型异常
void g() throw();                   // g 不会抛出任何异常
```


### 有什么
而 C++11 中新增了关键字 `noexcept`, 其功能之一是*将上述抛出声明简化为二元形式, 即可能抛出, 或不可能抛出*. 其语法形式是在函数签名最后加上 `noexcept(bool 常量)`, 该参数 `bool` 常量表示此函数是否不会抛出异常, 这一常量默认为 `true` (但如果根本不写 `noexcept` 的话, 表示该函数可以抛出异常).

```cpp
void f() noexcept(true);     // f 不会抛出异常
void g(int) noexcept(false); // g 可能抛出异常
void h() noexcept            // h 不会抛出异常; 这时不需要圆括号
void k();                    // 什么也不写: k 可能抛出异常
```

*声明一个函数不会抛出异常有利于编译器生成更简单的可执行文件*. 但如果一个带有 `noexcept(true)` 声明的函数中直接或间接抛出了异常, `std::terminate` 会*被立即调用*, 默认情况下意味着进程将马上结束.

该关键字的另一作用是*在编译时评估一个函数调用是否会抛出异常*, 并返回一个 `bool` 值常量. 这个函数表达式只在编译时使用, 不会被运行求值, 类似 `sizeof` 一样.

```cpp
// 沿用上面的定义
std::cout << noexcept(f()) << std::endl;  // 1
std::cout << noexcept(g(0)) << std::endl; // 0
```

将这两者结合起来, 可以实现一个需求: 如果函数 X 中只调用了函数 Y, 那么函数 X 是否抛出异常取决于 Y 是否抛出异常. 写成代码是这样的

```cpp
void f() noexcept;

void g() noexcept(noexcept(f()))
//                ^^^^^^^^^^^^^  f 不会抛出异常, 故此表达式为 true
//       noexcept(    true     ) 因此这里等价于声明此函数不抛出异常
{
    f();
}

template <typename T>            // 泛型中的运用
void h() noexcept(noexcept(T())) // h 函数是否抛出异常取决于 T 类型构造时产生异常
{ /* ... */ }
```

这是一个美好的愿景, 但在实际运用时, 如果要将一个函数所有调用的其他函数都写进 `noexcept` 声明中的话, 推广这一声明是极其困难甚至不可能完成的. 最坏的情况下甚至可能在 `noexcept` 里的部分相当于把整个函数重新实现一遍.

因此, 实际上只有一些很简单的函数才会加上这一声明. 另外, *析构函数默认都带有* `noexcept(true)` 声明.

需要注意的是, 使用 `noexcept(true)` 以及 `throw()` 声明*都不会强制编译器检查函数是否真的不会抛出异常*, 比如以下代码

```cpp
void f(int x) noexcept
{
    if (x < 0) {
        throw std::out_of_range("");
    }
}
```

虽然在函数体中很明确地有一句 `throw`, 但是编译器并不会在处理这段代码时报错.

## 基于范围的循环

### 为什么

在 C 和 C++ 里有两类循环语句, 一是 `while` 或 `do`-`while`, 另一是 `for` 循环. 相对于 `while` 系的按单一条件循环的语法, `for` 的不同之处在于多出了*迭代初始化*和*迭代变更*两个成分. 如

```cpp
size_t const SZ = 10;
int arry[SZ];
for (size_t i = 0; i < SZ; ++i) {
    arry[i] = i * 2 + 1;
}

// 等价于以下 while 循环

size_t j = 0;
while (j < SZ) {
    arry[j] = j * 2 + 1;
    ++j;
}
```

由于开发者之间对循环的功能达成了共识, 上述 `for` 循环一眼就能看出来是在逐个访问数组的每个元素, 因此相对于使用 `while`, `for` 循环在语义上更为明确, 容易理解.

不过, 在 C++ 中由于标准容器的引入, 这种 `for` 循环会*由于一些容器类型无法按照索引下标随机访问而无法使用*.  因此标准库中设立了迭代器 (iterator) 的机制来帮助用户遍历任何容器中的元素. 如

```cpp
std::set<int> s;

for (size_t i = 0; i < s.size(); ++i) {
    // 编译错误: std::set 集合类型不具备按照下标随机访问的能力
    int val = s[i];
}

for (std::set<int>::iterator i = s.begin(); i != s.end(); ++i) {
    // 正确: 通过迭代器访问元素
    int val = *i;
    std::cout << val << std::endl;
}
```


### 有什么
相对而言这种写法还是容易接受的. 不过, C++11 中又设计了一个新语法, 让针对容器迭代语义进一步简化. 这种基于范围的循环 (range-based loop) 语法如下

```cpp
std::set<int> s;

// 在 for 关键字的括号中使用
// 类型名 标识符 冒号 (:) 要进行迭代的容器 (任何表达式)
// 这一写法与上面传统的 for 循环写法完全等价
for (int val: s) {
    std::cout << val << std::endl;
}
```

编译器处理这一语法的机制实际上就是调用给定的容器表达式的 `begin()` 和 `end()` 函数产生迭代器对象, 然后调用迭代器对象的寻址算符重载 (前置 `operator*()` 重载) 获得相应的元素, 赋值给 `for` 的括号里定义的标识符.

如果提供容器的表达式是个函数调用, 这个调用只会被执行一次. 换言之, 这个表达式只会在循环开始前被求值一次.

```cpp
std::vector<std::string> make_vector()
{
    std::cout << "call make_vector" << std::endl;
    std::vector<std::string> x;
    x.push_back("hello");
    x.push_back("world");
    return x;
}

for (std::string s: make_vector()) {
    std::cout << "s= " << s << std::endl;
}

// 等价于以下代码, make_vector() 函数调用只有一次
std::vector<std::string> __ranged_for_loop_expr(make_vector());
for (std::vector<std::string>::iterator i = __ranged_for_loop_expr.begin();
     i != __ranged_for_loop_expr.end();
     ++i)
{
    std::string s = *i;
    // ...
}

/* 输出

call make_vector
s= hello
s= world

*/
```

另外, 像上面这样写, 每次迭代返回的 `std::string` 对象都会被复制到循环中定义的 `s` 变量里去, 这当然有些性能损耗. 在不需要复制的情况下, 可以将这一变量定义为引用.

```cpp
// 以引用的方式使用迭代的元素
for (std::string const& s: make_vector()) {
    std::cout << "s= " << s << std::endl;
}

// 也可以去掉引用的 const 限制; 这样的话, 循环体中更改引用意味着直接修改了容器内元素的内容
std::vector<std::string> v(make_vector());
for (std::string& s: v) {
    s += " !";
}

for (std::string const& s: v) {
    std::cout << "s= " << s << std::endl;
}

/* 更改了元素之后, 以上一个 for 循环的输出为

s= hello !
s= world !

*/
```

然而, 这一方便的新特性并*没有顾及到逆向迭代*, 也就是说无法通过逆向迭代器 (reverse iterator) 对容器内容进行循环. 不过, 可以在需要的时候加上这样一套工具类型 (需要用户自己添加; STL 中直到 C++17 都没有提供)

``` cpp
template <typename C>
struct reverse_iteration {
    C& c;
    reverse_iteration(C& c_): c(c_) {}

    // 其 begin end 函数返回所引用的容器的 rbegin() rend() 以产生逆向迭代器
    typename C::reverse_iterator begin() { return c.rbegin(); }
    typename C::reverse_iterator end() { return c.rend(); }
};

template <typename C>
struct reverse_iteration<C const> { // 针对 const 限定的偏特化
    C const& c;
    reverse_iteration(C const& c_): c(c_) {}

    // 此偏特化使用 const_reverse_iterator
    typename C::const_reverse_iterator begin() { return c.rbegin(); }
    typename C::const_reverse_iterator end() { return c.rend(); }
};

template <typename C>
reverse_iteration<C> make_reverse(C& c)
{
    return reverse_iteration<C>(c);
}

std::vector<std::string> v(make_vector());
for (std::string const& s: make_reverse(v)) {
    std::cout << "s= " << s << std::endl;
}

/* 输出

call make_vector
s= world
s= hello

*/
```

从这个例子中也可以看出, 如果用户自己实现了一个容器类型, 或者哪怕是上述这样的包装类型, 只要有合适的 `begin()` 和 `end()` 成员函数实现, 就能用在基于范围的循环语法中.


## 嵌套模板结束符号


在 C++ 中, 若使用一个模板类型的特化作为另一个模板的类型参数, 连续两个模板的结束符号 `>` 会合在一起变为右移算符 `>>`, 如

```cpp
std::vector<std::pair<int, int>> x;
//                            ^^
std::vector<std::pair<int, std::set<std::string>>> y;
//                                             ^^^ 还可能出现无符号右移算符
```

在 C++03 中这种写法是不允许的, 模板结束处的连续尖括号之间必须加上空格. 而 C++11 标准则允许这样写, 即上述代码可以被支持 C++11 的编译器正确解析. 不过此改动也不是完美的, 这一规则加入后一些原来可以编译通过的代码反而会出错. 如

```cpp
template <int I>
struct A {};

// 使用右移运算表达式特化接受整型参数的模板
// C++03 中可以编译通过, C++11 中报错
A<3 >> 1> x;
// 两个标准中都认可的写法, 在表达式两边加上括号
A<(3 >> 1)> x;
```

当然也不能说这是设计上的不周, 现实中像上面这样偏偏用到一个右移运算来特化的例子屈指可数, 而嵌套模板的使用则比比皆是. 所以这只是牺牲不常见的用况来方便更常见的写法, 还是很有道理的.



## 新的类型别名机制

### 为什么
在编写代码时, 可以为一些类型设置别名, 使得代码更容易理解. 在既有标准中, 可以使用 `typedef` 关键字定义类型的别名. 如

```cpp
typedef unsigned char byte;
```

以上代码中将类型 `unsigned char` 定义为 `byte`. 就这样直白的别名设置而言, `typedef` 还算看得过去, 但下面这些情况就略显晦涩了

```cpp
typedef int int_arr[10];
typedef int (* fn_type)(int, int);
```

其中第一个别名设置是将 10 个 `int` 构成的数组定义成名为 `int_arr` 类型; 第二个则定义了名为 `fn_type` 类型, 它的类型是函数指针, 这类函数指针指向的函数接受两个 `int` 参数, 返回一个 `int`. 这两种类型别名的语法都将名字放在了语句中间某个位置, 读起来并不直观.

### 有什么
为了改善这一弊端, 在 C++11 中为 `using` 指派了一个新功能, 使得用户可以用更加清晰的方式为类型指定别名. 以上面三种类型别名为例, 它们可写作

```cpp
// 语法形式为
// using 别名 = 类型
using byte = unsigned char;         // 普通类型, 直接写在等号右侧
using int_arr = int[10];            // 数组类型, 用类型名加上方括号和数量
using fn_type = int (*)(int, int);  // 函数指针类型, 在返回值类型和参数列表之间加上 (*)
```

这一语法形式与 `typedef` 不同的是, 在类型别名和实际的类型之间, 显式地插入了一个等号, 等号左边的标识符就是别名. 如此一来, 用户在阅读代码时就能立即明白为怎样的类型设置了什么别名.

除了提供更为明了的类型别名语法, `using` 还可支持泛型类型定义, 如

```cpp
// 语法: 在 template < ... > 泛型声明后立即加上 using 语句
// 泛型参数 T 必须指定, 而 Alloc 有默认值 std::allocator<T>
template <typename T, typename Alloc = std::allocator<T>>
using vec_iter = typename std::vector<T, Alloc>::iterator;

std::vector<int> x;
// 使用 int 特化 vec_iter 别名, 另一泛型参数是默认的 std::allocator<int>
// 因此特化出的类型 vec_iter<int> 为
// std::vector<int, std::allocator<int>>::iterator
vec_iter<int> i = x.begin();
```


##  对象初始化的改进

> 统一的对象初始化语法

C++11 开始统一千奇百怪的对象初始化语法了, 同时各种 STL 容器增加预设元素的初始化方式.

### 为什么
这个故事还要从 C 的一个语法点说起. 在 C 语言中, 如下的代码

```cpp
struct Point {
    int x;
    int y;
};

Point p = {0, 1};
int a[] = {0, 1};
```

同样的 `{0, 1}` 在编译器看来语义是截然不同的, 对 `p` 而言是初始化其成员, 对 `a` 而言则既要推导 `a` 的大小又要设定其元素的值.

而在 C++03 中, 如果为 `Point` 定义一个构造函数, 以下写法就不正确了

```cpp
struct Point {
    int x;
    int y;

    Point(int x_, int y_): x(x_), y(y_) {}
};

Point p = {0, 1}; // 错误: 非 POD 的类型不能用初始化列表构造
```

不过, 只要用 C++11 的编译器, 上述代码中的编译错误就立即消失了. 实际上, C++11 中添加以上语法作为一则初始化语法, 或者说调用构造函数的语法. 如

```cpp
Point p = {0, 1};   // 与初始化 POD 的语法相同
Point q{0, 1};      // 亦可省去等号

// 这两种写法均等价于传统写法
Point r(0, 1);
```

也就是说, 针对构造函数, 可以使用花括号替代圆括号. 这一特性还有助于减少调用无参构造函数时的书写错误. 例如

```cpp
struct Point {
    // ...
    Point() : x(0), y(0) {}
};

Point p();
```

上例中定义 `p` 的实际上并不是调用无参构造函数初始化一个 `Point` 对象, 实际上它是一个函数前置声明, 该函数没有参数并返回 `Point`. 这一新人杀手级语言 "特性" 导致的错误通常在修改代码时, 去掉了构造参数都但没有去掉括号而产生. 而在新语法中, 它可以这样写

```cpp
Point p{};
```

另外, 用户可以利用这一语法特性简化一些 `return` 语句. 当函数需要返回以特定构造函数构造的对象时, 可以使用花括号语法, 而不必写出类名. 如

```cpp
std::string make_string()
{
    return {};
    // 而不需要写
    // return std::string();
}

Point make_point(int x, int y)
{
    return {x, y};
    // 而不需要写
    // return Point{x, y};
}
```

除了以上单个对象的构造语法有所更改, 批量构造对象的语法语义也变得不同. 类似 `int a[] = {0, 1};` 这一例子中, 数组初始化时给出的花括号括起的整数值序列, 它不仅仅可以用于构造数组, 现在也可以用于构造容器了. 比如

```cpp
std::vector<int> x = {0, 1};
// 当然, 也可以去掉等号
std::vector<int> y{2, 3, 5, 7};

for (int i: x) {
    std::cout << "x contains " << i << std::endl;
}
/* 输出
x contains 0
x contains 1
*/

for (int i: y) {
    std::cout << "y contains " << i << std::endl;
}
/* 输出
y contains 2
y contains 3
y contains 5
y contains 7
*/
```

如果编译时知道一个容器里该有些什么东西, 直接写到构造函数里, 比先定义出容器再一个个添加要简单多了.

这一语法看起来很奇特, 不过并不神秘, 也不仅仅被 STL 容器所用 (不仅 `vector`, 其他所有的 STL 容器都支持这样构造). 在 C++11 中, 编译器处理到花括号扩起的类型相同的表达式时, 就会试图将其转换为称作 `std::initializer_list` 的泛型类的实例, 而 STL 容器之所以可以这样构造, 无非是因为它们都有参数 `initializer_list<value_type>` 的构造函数. 当然, 不仅构造函数可将初始化列表当作参数, 一般函数也可以, 如

```cpp
#include <iostream>
#include <initializer_list>

// 以 initializer_list 为参数的函数, 这是一个泛型类型, 需要特化
void f(std::initializer_list<int> x)
{
    // initializer_list 实例的 size() begin() end() 函数使它可以表现得像一个标准容器
    std::cout << "initializer_list size=" << x.size() << std::endl;
    for (int i: x) {
        std::cout << "-- element " << i << std::endl;
    }
}

int main()
{
    f({1, 1, 2, 3});
    /* 输出

    initializer_list size=4
    -- element 1
    -- element 1
    -- element 2
    -- element 3

    */

    f({});
    /* 输出

    initializer_list size=0

    */
    return 0;
}
```

而像 `std::map` 这样, 元素类型不是一个单一的值而是键值对, 在初始化的时候就需要混合使用初始化列表和之前介绍的用花括号括起构造参数的做法

```cpp
std::pair<std::string, int> jan{"jan", 1};
std::map<std::string, int> x{ // map<std::string, int> 中的值类型是 pair<std::string const, int>

    jan,                      // 可以使用一个 pair 实例来复制构造

    {"feb", 2},               // 也可以使用花括号括起的两个值调用构造函数
    {"mar", 3},
};
std::cout << x["feb"] << std::endl; // 2
```

不过这样看起来, 花括号的作用又非常混乱了. 即, *如果花括号中各个元素的类型一致, 那么它被编译器视作一个初始化列表实例; 否则编译器将根据花括号中各表达式的类型, 尝试决议出一个构造函数重载进行调用.*

然而, 假如像上面 `Point` 类那样, 其构造函数的参数类型恰好都是相同的, 构造参数看起来像个初始化列表, 编译器不会很困惑吗?

确实初始化列表的语法仍有歧义. 在这种情况下, 用初始化列表语法去调用函数时, 将*优先匹配*以 `initializer_list` 为参数的重载, 若不存在此重载才会以其他重载作为备选. 比如下面的例子

```cpp
void f(std::initializer_list<int> x) // (a)
{
    std::cout << "initializer_list" << std::endl;
}

void f(Point p)                      // (b)
{
    std::cout << "point" << std::endl;
}

int main()
{
    f({0, 0});                       // 输出: initializer_list
    return 0;
}
```

例子中定义了两个重载, 重载决议会判定为调用 (a), 而将 (a) 删除掉的话, 则重载 (b) 会被执行.

### 委托构造函数

当为一个成员很多的类型编写一组构造函数重载时, 需要给每个构造函数都写上长长的初始化列表. 如

```cpp
struct Person {
    std::string first_name;
    std::string last_name;
    std::string address;
    int score;
    int age;

    // 显式初始化每个成员的完整初始化
    Person(std::string const& fname, std::string lname, std::string const& addr,
           int s, int a)
        : first_name(fname)
        , last_name(lname)
        , address(addr)
        , score(s)
        , age(a)
    {}

    // 只为部分成员执行默认初始化
    // 传统的做法仍然需要将一些原生成员放到初始化列表中
    Person(std::string const& fname, std::string lname, int a)
        : first_name(fname)
        , last_name(lname)
                            // address 作为 string 类型成员, 有构造函数保证其正确初始化, 不必写入初始化列表
        , score(0)          // 但整数或指针等原生类型需要显式初始化
        , age(a)
    {}
};
```

这种写法一方面初始化列表的代码显得臃肿不堪, 另一方面维护难度也很大, 如果新增原生类型成员, 每个构造函数的初始化列表里都需要加上对其的初始化.

在 C++11 中新增了一种初始化列表的书写方式, 即允许一个构造函数调用另一个构造函数作为初始化对象的手段, 如以上代码中的第二个构造函数重载可以调用第一个重载. 如

```cpp
struct Person {
    // ...

    Person(std::string const& fname, std::string lname, std::string const& addr,
           int s, int a)
        : first_name(fname)
        , last_name(lname)
        , address(addr)
        , score(s)
        , age(a)
    {}

    // 使用委托构造函数的做法是, 将另一构造函数的调用作为唯一成分写在初始化列表中
    // 这个例子中, 上一个构造函数重载中初始化了所有成员
    // 其他构造函数都可调用上一构造函数重载, 不用担心漏掉个别成员的初始化
    Person(std::string const& fname, std::string lname, int a)
        : Person(fname, lname, "", 0, a)
    {}
};
```

需要注意的是, C++ 构造函数对成员初始化的要求是不重不漏, 当委托另一构造函数进行构造后, 隐含着 "所有成员都已被正确初始化" 这一结果, 因此不能继续在初始化列表中加任何成分, 或者委托调用其他的构造函数. 例如下面是一些可能误用的情况

```cpp
struct Person {
    // ...
    Person(std::string const& fname, std::string lname, int a)
        : Person(fname, lname, "", 0, a)
        , age(0) // 错误: 不能再初始化其他成员了
    {}
};

struct Base { int x; Base(int x_): x(x_) {} };

struct Inherit : Base {
    int y;

    // 正确: 先调用父类构造函数初始化父类的部分, 再初始化本身的成员
    Inherit(int x_, int y_): Base(x_), y(y_) {}
    // 正确: 委托构造
    Inherit(int x_): Inherit(x_, 0) {}

    Inherit(int x_)
        : Base(x_)
        , Inherit(x_, 0) // 错误, 对父类初始化后, 不能再使用委托构造
    {}
};
```

### 成员缺省初始化

另一可以简化构造函数代码的特性则是为那些无论如何都需要初始化, 并且有固定初始化模式的成员设置缺省的初始化方式. 比如

```cpp
std::string current_date();

class Logger {
    // 为这个 ofstream 类型成员设定缺省的初始化方式
    std::ofstream output{"logs/log-" + current_date() + ".log"};

    int id;
    std::string format;
public:
    Logger(int id)                              // (a)
        : id(id)
    {}

    Logger(int id, std::string const& fmt);     // (b)
        : id(id)
        , format(fmt)
    {}

    Logger(std::string const& filename, int id) // (c)
        : output(filename, std::ios_base::app);
        , id(id)
    {}
};
```

在上例中有三个构造函数重载, 其中 (a) 和 (b) 都没有显式初始化 `output` 成员, 但是 `output` 成员其默认构造函数又不能产生一个可以正常工作的文件流对象, 于是就需要给出一个缺省的初始化方式, 这种初始化就是将构造参数直接写在成员声明处. 如果像 (c) 重载那样指定了 `output` 的初始化方法, 那么指定的缺省初始化就不会被执行.

从例子中还可以看出, 虽然成员初始化参数的模式只能设定一种, 但并不妨碍从这种模式中得出不同的实参, 如果 `current_date()` 这个函数能返回不一样的值, 那么构造不同 `Logger` 实例时其 `output` 指定的文件名仍可以是不同的.

以上写法中不能将初始化的花括号改成圆括号, 否则语法上会被编译器识别为成员函数定义.
``` struct A {
    int m(0); // 错误: 这会被编译器认为是定义函数
    int n{0}; // 正确: 使用花括号括起参数
    int p{};  // 正确: 使用花括号, 无初始化参数, int 被置为 0
};
```

可以复制构造的成员亦可用等号设定初始值^[[使用等号的语法会让编译器认为是复制构造, 但编译器通常会优化掉. 恰好例子中的流对象是不可复制构造的, 因此只有上面这种写法.]]. 如下面例子中的写法也都是正确的.

```
struct A {
    int m = 0;                           // 直接使用等号加上初始值
    std::string s = "1";                 // 相当于 = std::string("1")
    std::string t = std::string(3, '2'); // 显式写作复制构造形式
};
```

## 类型推导
>略


# 常量与字面量

在既有 C++ 标准中, 使用常量要么通过枚举 (enumeration), 要么通过 `const` 限定的名字定义. 而两者多多少少都有一些缺陷: 枚举由于其可以隐式与整数类型互相转换, 因而缺乏类型和取值范围的约束; 而 `const` 关键字有时仅仅表示用户无法修改而并非该值本身是常数, 产生一些二义性.

在新标准中引入了许多常量和字面量的改进, 让枚举类型的运用更加安全, 提供了语义更明确的常量, 并且还加入了用户自定义字面量的机制. 本章中便来一一介绍它们.


## 枚举类型改进


在 C++11 中, 用户可以给枚举类型指定更精确和严格的类型了, 这一点体现在两方面: *允许指定枚举类型的宽度和符号;* 允许在引用枚举常量时要求*用户显式指定枚举的域来减少名字冲突的可能性*.

第一项特性的具体做法是, 在声明枚举类型时如声明继承一样, 为这个枚举类型指定一个 "父类" 类型. 当然, 这与继承并无任何关系, 只是规定此枚举类型可能的取值范围, 这样做可以让编译器提供更好的取值检查. 如

``` cpp
enum flags : unsigned short {//规定枚举类型取值范围
    READONLY = 1,
    READWRITE = 2,
    ADMIN = 4,
};
```

以上声明中规定了 `flags` 枚举中的常量是无符号数且位宽与 `short` 类型一样. 一旦编译器检查到该类型的某个常量取值超过此返回就会报错, 如

```cpp
enum uint_enum : unsigned int {X = -1}; // 错误: -1 不是无符号整数
enum byte_enum : char {Y = 128};        // 错误: 128 超过了 char 的表示范围
```

当然, 为枚举指定类型限定*仍然只能使用整型*, 不能写如 `enum X : double` 的声明.

第二项特性的具体做法是, 在 `enum` 关键字后加上 `struct` 或 `class` 关键字 (凭个人喜好或编码规范, 对编译器而言完全无区别), 作用是所有该枚举类型定义的常量不能直接引用, *必须加上枚举类型名*, 这样做*可以避免枚举常量重名的问题.* 如

```cpp
enum class Province {HUBEI, HUNAN, GUANGDONG, HAINAN};
enum struct City {WUHAN, CHANGSHA, GUANGZHOU, HAIKOU};

Province p = Province::HUBEI; // 正确
City c = City::WUHAN;         // 正确: 以 enum 名作为名字空间访问
City d = WUHAN;               // 错误: WUHAN 在当前上下文中未定义
```

这两个特性也可以结合在一起使用, 如

```cpp
enum class Direction: unsigned char {RIGHT, DOWN, LEFT, TOP};
Direction d = Direction::RIGHT;
```


## constexpr

### 为什么 
除了使用枚举类型, 在 C++ 中也可以使用 `const` 来定义常量, 并且除了整数类型的常量, 它也可以作用于其它类型, 如 `double` 浮点数等.

不过, 使用 `const` 来限定一个名字, 其*初衷只是表示其无法修改, 而若其以常数初始化, 那么编译器认为被定义的名字表示一个常量* (当然常量必然无法修改). 这会产生一定的二义性, 并在给一些代码带来麻烦, 比如

``` cpp
template <int I>
class A {};

void f()
{
    int const N = 5;
    A<N> a; // 合法: 编译器认为 N 是编译时常量
}

void g()
{
    int n = 5;
    int const M = n;
    A<M> a; // 不合法: 编译器认为 M 只是一个无法修改的量
}
```

### 有什么
而在 C++11 中, 一个新的用来定义编译时常量的机制加入了标准. 标准引入了 `constexpr` 这一关键字以区分 `const` 关键字, *使用这一关键字定义的值必须是编译时常数*, 因而可以用于定义固定长度的数组, 或像上例中那样特化模板, `static_assert`, 以及任何需要一个常数的地方. 这一机制的另一个方面是允许通过函数计算返回一个编译时常数, 即使用 `constexpr` 关键字定义的函数在*参数都为常数的情况下*返回的值也可以被认为是一个常数.


而如果使用了 `constexpr` 无法定义出一个常数, 或者 `constexpr` 修饰的函数不满足某些条件, 那么编译器会立即报错. 这也避免了出现 `const` 那样不明确的语义.

### 基本语法和使用

使用 `constexpr` 修饰一个名字定义, 让它一定是编译时常数, 写法是将 `constexpr` 关键字放在定义语句的开头.

``` cpp
constexpr int N = 5;        // 定义 N 为常量 5

template <int I>
class A {};
A<N> a;                     // 可以用于特化模板

static_assert(N == 5, "");  // 可以用于 static_assert
```

与 `const` 不同的是, 它*必须由其他编译时常数在定义处立即初始化*, 不能用于声明形式参数. 另外, 如果*用作定义类的成员, 它必须是 `static` 修饰的*.

```cpp
int x = 0;
const int y = x;                // 这样写是允许的

int m = 0;
constexpr int n = m;            // 错误: 初始值 m 不是一个编译时常数

void f(constexpr int N) {}      // 错误: 不能作为参数

struct X {
    constexpr int M = 6;        // 错误
    constexpr static int M = 6; // 正确: 必须带上 static 修饰
};
```

其中的理由也不复杂: 使用 `constexpr` 就是在定义编译时常量, 因此编译器当然需要一个常量去初始化它; 并且类型的各个实例也没有必要共享一个编译时常量, 声明为静态是合适的做法. 而如果在函数体内定义一个 `constexpr` 修饰的量, *它自动获得 `static` 修饰, 无须显式写出*. 当然, *一般而言这些常量并不会真的被编译器放入程序的静态存储区, 它们往往在编译时就被替换为常数了*.

除了用来定义常量, `constexpr` 关键字也可以用来修饰函数. 修饰全局或静态函数时, *表示这个函数在参数都为常量时将返回一个常量*. 比如

```cpp
constexpr int square(int x)
{
    return x * x;
}

// 也可以修饰模板函数
template <typename T>
constexpr T cube(T x)
{
    return x * x * x;
}

constexpr int I = square(5);     // 25
constexpr int K = cube(-5);      // -125
constexpr double L = cube(1.6);  // 4.096
```

也就是说, 上面这些函数调用实际上由编译器自己执行并计算出了结果, 然后当作编译时常量使用.

这样定义的函数也能在参数不为常量时使用, 不过这样的话, 返回值也就不能作为常量看待了

```cpp
int x = 5;
int y = cube(x);        // 正确: 参数 x 不是编译时常量, 但是可用来调用 cube, 其结果被视为变量
constexpr z = cube(x);  // 错误: 参数 x 不是编译时常量, 调用 cube 返回的结果不被认可为常量
```

在以上例子中的 `constexpr` 函数都比较简单, 不过实际上, `constexpr` 修饰函数时, 有一些规则迫使它**必须**这么简单. 这些规则是

* *调用时必须已经给出完整定义而非前导声明*
* 非构造函数的 `constexpr` 函数只能包括一条 `return` 作为非编译时语句 ("编译时语句" 是笔者的造语, 指代如 `static_assert`, `typedef`, `using`, `enum` 等只在编译时产生效果的语句)
* 构造函数的初始化列表中的表达式, `return` 的表达式中, 只能引用 a) 参数 b) 编译时常量 c) 其他 `constexpr` 函数调用 d) 以上项目的运算或成员 (有运算符重载的情况视作 c 项)

第一条规则是理所当然的, 它保证编译器知道这一函数的定义并能够在编译时模拟执行它.

而接下来一条规则就非常严苛了, 甚至这样的代码也不会被认可[[在 C++14 中这一约束被放宽了, 允许函数在栈上定义 `const` 量或使用简单的分支语句]]

```cpp
constexpr int successor(int x)
{
    constexpr int C = 1; // 可以将这一句改为 enum {C = 1}; 通过编译
    return x + C;
}
```

最后一条规则中约束了这些函数能使用的值也应该都是常数, 毕竟要在编译时执行这些代码. 并且, 函数调用中如果有其他函数也不会产生其他效果, 因为被调用的那些也都是 `constexpr` 函数.

说到这里不得不提, 所有的数学库函数都**不**是 `constexpr` 修饰的. 比如求平方根, 虽然理论上来说完全可以在编译时求得任何常数的平方根, 但实际上 `sqrt` 函数的实现中有产生副作用的可能性, 因为在参数为负数时, `errno` 会被设置 `EDOM` 表示发生了一个定义域错误.

不过这些也只是一些说辞. 在不考虑定义域的情况下, 自行定义 `constexpr` 求平方根函数并不是不可能

```cpp
// 使用二分法求平方根
// PRECISION 值为精度要求
constexpr double PRECISION = 1e-3;

// 猜测值 guess 的平方和原参数 x 小于在容许范围内, 也就是小于精度要求时, 认为此猜测值足够好
constexpr bool good_enough(double x, double guess)
{
    // | x - guess * guess | < PRECISION
    return -PRECISION < x - guess * guess && x - guess * guess < PRECISION;
}

// 如果猜测值 guess 足够好就返回它, 否则, 递归求更精确的值
constexpr double sqrt_impl(double x, double guess)
{
    return good_enough(x, guess) ? guess : sqrt_impl(x, (guess + x / guess) / 2);
}

// 求平方根的功能入口, 以 1.0 作为初始猜测值
constexpr double sqrt_c(double x)
{
    return sqrt_impl(x, 1.0);
}

constexpr double X = sqrt_c(2); // 约为 1.41422
constexpr double Y = sqrt_c(3); // 约为 1.73214
```

从上面这一连串的 `constexpr` 函数也可以看出在严格的规则约束下能做到什么程度. 譬如使用 `?:` 三目算符替代分支语句, 包括使用递归都是允许的. 不过如果递归的次数过深, 编译器会选择报一个错误, 避免在可能实际上有缺陷的代码中越陷越深. 譬如, 利用上述代码求 `sqrt_c(-2)` 时, 在 `sqrt_impl` 中是会无限递归的, 这时会以编译错误收场.

### 自定义常量类型

引入 `constexpr` 的好处除了区分一般 `const` 而获得更明确语义, 和使用函数计算常量之外这两点之外, C++11 还允许自定义常量的类型. 举个例子, 下面这种代码也是可行的

```cpp
struct Vector2d {
    double x;
    double y;

    constexpr Vector2d(double xx, double yy) // (a) constexpr 修饰的构造函数
        : x(xx)
        , y(yy)
    {}

    constexpr double length() const          // (b) constexpr 修饰的成员函数
    {
        // 使用刚才例子中的 sqrt_c
        return sqrt_c(x * x + y * y);
    }
};

constexpr Vector2d v{3.0, 4.0};              // (c) 使用上面定义的 Vector2d 定义常量 v
constexpr double x = v.x;                    // (d) 使用常量 v 的属性定义常量 x
constexpr double len = v.length();           // (e) 使用常量 v 计算得出常量 len
```

这个例子中, `Vector2d` 这个类型定义的内部有两个带有 `constexpr` 修饰的函数, 一是其构造函数, 另一个是非静态成员函数. 然后定义了 `Vector2d` 的实例 `v`, 它以 `constexpr` 修饰, 其被认为是一个编译时常量; 然后, 使用其成员去初始化常量 `x`, 或调用其成员函数 `length()` 得到常量返回值去初始化 `len`.

例子中多次出现了 `constexpr`, 不过其中的内在联系很清晰, 它们是这样的

* 自定义一个可以被用作常量的类型, 那么它必须有*至少一个* `constexpr` 构造函数 (a)
* 应当使用有 `constexpr` 构造函数来构造被定义为常量的实例 (c), 当然, 这时*传给构造函数的实参必须全部是常量*
* 当一个自定义类型的实例被定义为常量后, 它的*成员将都被视作常量* (d) (除了 `mutable` 修饰的成员, 它们仍然被视作一般变量)
* 由于常量对象的各成员都被视作常量, 因此在这些成员上的运算, 或使用这些成员调用其他 `constexpr` 函数, 得到的也将是一个常量; 并且, 可以使用 `constexpr` 修饰成员函数, 让它在对象本身是常量时尽可能返回一个常量 (b)
* 对常量对象调用其 `constexpr` 修饰的成员函数能得到一个常量 (e)

反过来说, 如果上面 (a) 处构造函数的 `constexpr` 被去掉, 那么 (c) 处就无法编译通过, 连带 (d) (e) 也出错; 而如果去掉 (b) 处成员函数的 `constexpr`, 那么 (e) 处调用 `v.length()` 将不被认为得到的是一个编译时常量, 因而初始化 `len` 时产生一个错误.

使用 `constexpr` 修饰成员函数的基本规则跟修饰一般函数差不多, 也是只能有一条 `return` 语句, 其表达式用到的只能是参数或者其他常量等等, 不过还加上一条, 就是可以使用对象自身非 `mutable` 的成员. 另外, *`constexpr` 修饰的成员函数在 C++11 标准中自动带有 `const` 修饰, 但在 C++14 标准中去掉了这一规则, 所以在写代码时最好还是显式写上 `const`*.

而使用 `constexpr` 修饰构造函数的规则就不太一样了: 首先, 构造函数并不需要 `return` 一个值, 于是函数体内不允许有任何非编译期语句; 构造函数的重点在其初始化列表, 如果调用委托构造函数或父类的构造函数, 那么被委托的构造函数或其父类的对应构造函数必须也是 `constexpr` 修饰的; 调用其他构造函数的参数表达式, 或其他成员的初始化表达式中, 所有用到的部分也都必须是常量, 与约束一般 `constexpr` 函数 `return` 表达式的规则相同.

除了以上作用于各个函数上的规则, 用来定义常量的类型本身还有其他要求. 在 C++11 中, 描述能够用来定义常量的类型的术语是**字面类型** (literal type), 所有的基本数据类型都是字面类型, 而自定义字面类型, 则必须满足以下条件

* 该类有至少一个非复制构造函数是 `constexpr` 修饰的
* 该类型有一个平凡的析构函数, 它的每个基类和非静态成员也须递归地满足这个要求

第一条规则在前面中已经说过了, 如果没有 `constexpr` 修饰的构造函数, 那么无法合理地初始化这一常量对象. 而第二条规则是有关编译器如何对待常量的. *对于常量, 编译器可能只在编译时使用它们, 因此, 这个对象可能不会存在于运行时, 也就不会被析构, 这就需要一条约束, 使得这个对象即使不析构也不产生任何问题*.

如果不满足字面类型的定义, 那么用此类型就无法定义常量. 比如字符串类型 `std::string`, 它的析构函数会释放其所持有的堆上资源, 因此不是字面类型

```cpp
constexpr std::string S("hello, world");  // 错误: string 不是一个字面类型
constexpr size_t sz = S.size();           // 连带错误: string::size() 也不可能是常量
```

字面类型除了用来直接定义常量之外, 也可以作为 `constexpr` 函数的参数类型或返回值类型使用. 比如

```cpp
constexpr Vector2d multi(Vector2d const& a, double times)
{
    return Vector2d(a.x * times, a.y * times);
}

constexpr Vector2d m = multi(Vector2d{1, 2}, 2);
constexpr double xx = m.x; // 2.0
constexpr double yy = m.y; // 4.0
```

或者, 将这一功能定义为算符重载, 显得更简洁

```cpp
struct Vector2d {
    // ...

    // 算符重载成员函数也可以加上 constexpr 修饰, 与其他成员函数规则一样
    constexpr Vector2d operator*(double times) const
    {
        return Vector2d(x * times, y * times);
    }
};

constexpr Vector2d m = Vector2d{1, 2} * 2;
constexpr double xx = m.x; // 2.0
constexpr double yy = m.y; // 4.0

// constexpr 也可以用于定义全局的算符重载, 与其他全局 constexpr 函数规则一样
constexpr Vector2d operator*(double times, Vector2d const& a)
{
    return a * times;
}
```

需要指出的是, 若 `constexpr` 修饰一个泛型函数, *其泛型参数用非字面类型特化时, 不构成编译错误, 只不过, 这一特化退化为非 `constexpr` 修饰的*.

比如标准库中, `std::pair` 泛型类的构造函数是 `constexpr` 修饰的, 这意味着在使用两个字面类型特化 `std::pair` 模板类型的情况下, 其实例可以是常量

```
constexpr std::pair<int, Vector2d> velocity{70, Vector2d{1, 0}};
constexpr int speed = velocity.first;               // 70
constexpr bool toward_east = velocity.second.x > 0; // true
```

当然谁也不能料定模板参数类型不含 `string` 之类的非字面类型, 因此需要有这条规则保证在这种情况下不出现编译错误.

```cpp
// 正确
std::pair<int, std::string> x{0, ""};

// 错误: 特化出的 pair<int, string>(int, string) 构造函数退化为非 constexpr 函数
constexpr std::pair<int, std::string> y{0, ""};
```

### 优化意义上的 `constexpr` 函数

在上面的介绍中指出了 `constexpr` 与字面类型之间的联系. 一个 `constexpr` 函数的返回值类型和各形式参数类型, 如果不是模板类型参数, 那么必须都是字面类型. 理由也很明显, 因为这些函数可用以定义只存在于编译期的常量, 因此, 它们不应该有非平凡的析构函数.

不过相对于其他函数而言, 构造函数有点特殊, 它并没有返回值. 更准确地说, 构造函数在给定地址空间上进行的一系列初始化对象的行为, 虽然将对象构造的调用放在表达式里其值是这个对象, 但这个构造调用并没有 "返回" 一个对象. 这样一来, 如果一个非字面类型的构造函数的各个参数类型是字面类型, 并且满足其他 `constexpr` 修饰函数时的规则, 那么这个构造函数仍然可以是 `constexpr` 修饰的.

比如, 实现一个这样的指针包装类型

```cpp
class IntPtr {
    int* ptr;
public:
    // 此类型实例内部的 ptr 指向堆上空间
    explicit IntPtr(int x)
        : ptr(new int(x))
    {}

    // 析构时, 需要归还堆上空间
    // 因此, 这不是一个字面类型
    ~IntPtr()
    {
        delete ptr;
    }

    IntPtr(IntPtr const&) = delete; // 简单起见, 不允许复制

    // 但是, 其某些构造函数可以是 constexpr 修饰
    // 如下面这个, 满足 constexpr 构造函数的各个规则约束就行
    constexpr IntPtr()
        : ptr(nullptr)
    {}
};

constexpr IntPtr p; // (a) 编译错误: IntPtr 不是字面类型不能用来定义常量
IntPtr q;           // (b) 编译通过
```

上面例子中, `IntPtr` 类型虽然不是字面类型, 但可以拥有 `constexpr` 修饰的构造函数; 然而, 即使有 `constexpr` 修饰的构造函数, 却不能用这个构造函数定义常量, 因此 (a) 处无法编译.

这样绕来绕去的, 看起来这好像是绕过规则而产生的一个漏洞, 但它仍然是有意义的.

实际上, 当一个函数被 `constexpr` 修饰时, 其真正的作用是, 若该其参数为编译时常数, 那么编译器会将直接编译时初始化该函数返回的对象地址空间, 即有可能的话, 编译器会在编译时计算将该函数的返回值, 然后生成直接写入常数的代码, 减少运行时开销. 这使人感觉像一个更加高级的 `inline` 修饰, 反而跟编译时常量关系不大, 只不过恰好利用函数计算编译时常量可以藉由这样的函数来完成. 而用 `constexpr` 修饰非字面类型的构造函数 (或字面类型的构造函数) 就是仅运用了这一高级 `inline` 机制, 避免构造函数调用开销, 生成直接将实例的各成员的值设为常数的运行时代码. 因此如果程序执行到上述代码的 (b) 处, 它并不会调用构造函数, 而是根据构造函数的指示, 直接在对象的地址上写入一个空指针的值, 对于 x64 架构而言, 就是填上 8 字节的零.

所以, 即使不是用来定义常量, 也可以将一些简单的函数定义为 `constexpr` 函数, 让编译器尽情优化之.


## unicode 常量
在 C++11 标准中新引入了 UTF-8 预编码字符串的机制, 可以*让编译器在编译时对字符串字面常量进行转码*. 如以下代码

```cpp
#include <iostream>

char u[] = u8"汉";

int main()
{
    std::cout << u << std::endl;
    return 0;
}
```

这样在程序运行时将以 UTF-8 的编码输出 "汉" 字, 前提条件之一是编译器能正确处理输入文件的编码, 如 GCC 会从系统上下文获取默认的输入编码方式, 或以 `-finput-charset=` 来指定编码, 此编码应当与输入文件的编码方式一致, 换言之编译器在这时也扮演一个编码器的角色. 另一个前提条件是命令行软件本身能支持 UTF-8 内容的显示, 比如 Linux 的 xterm 能正确显示 UTF-8 编码的内容, 但 Windows 自带的 cmd 则不能正确显示.

由于编译时完成了编码, 得到的结果就是字节序列, 因此定义的 `u` 的类型为 `char[]`.

如果要以宽字符存储字符串字面量, 以前的 `L` 前缀仍然可以用, 但定义出的 `wchar_t` 的宽度仍然是一个编译器确定的值, 这实在是容易引起问题的地方. 所以 C++11 又加入了两个新的固定宽度的字符类型, 以及相应的前缀, 如

```cpp
char16_t c16 = u'汉';   // 小写 u 开头表示以 UTF-16 编码的字符或字符串
char32_t c32 = U'汉';   // 大写 U 开头表示以 UTF-32 编码的字符或字符串
char16_t s16[] = u"汉";
char32_t s32[] = U"汉";
```

请注意, 由于 UTF-8 编码得出的序列不是宽字符, 因此并不存在 `u8'汉'` 字符形式, 只有字符串形式.

然而标准中很尴尬的一点是, 并没有新增对应预定义输出流 (比如 `std::cout` 之于 `char[]` 或 `std::wcout` 之于 `wchar_t[]`), 因此如果在程序中用适于一般字符或宽字符的流来输出它们, 这些字符类型将转换成整数输出, 而字符串将转换为地址输出.

当然, 文本编码并不是简单的几个数据类型换来换去就能解决的, 要按照具体的情况选择合适的方法. 比如 HTTP 通信中向客户端发送内容, 宜用 UTF-8 编码的字节序列; 而本地程序的用户界面最好还是使用专门的国际化工具来转换程序中的字符串.

## 免转义字符串常量

C++11 中开始支持免转义以及多行字符串字面量来降低在源代码中编写复杂文本内容的难度. 其形式为

```cpp
R"自定义分隔符(任意字符内容)自定义分隔符"
```

其中 "自定义分隔符" 可以是任意内容, 圆括号前后的两部分自定义分隔符必须相同. 比如

```cpp
auto x = R"delim(Print "hello, world".)delim";
//               ^^^^^^^^^^^^^^^^^^^^^
// 字符串内容为圆括号中间的部分, 不含圆括号, 双引号不会引起字符串结束
// 必须由一个反圆括号, 分隔符, 引号结束
std::cout << x << std::endl;

/* 输出

Print "hello, world".

输出结束 */
```

如果要指定编码前缀, 这个前缀要出现在 `R` 之前, 如

```
auto x = u8R"""(汉字)"""; // 正确, 等价于 u8"汉字"
auto y = Ru8"""(汉字)"""; // 错误, u8 前缀必须出现在 R 之前
```

此外, 这种方式还可以定义多行字符串, 比如

```
auto x = R"""(
hello
world
)""";
// 等价于 "\nhello\nworld\n", 请注意开始的圆括号之后和结束的圆括号之前的换行符也计入

auto y = R"""(
 ________   _____     _____    ________  ________
/       |   |   |     |   |   /       | /       |
|       | --'   '-- --'   '-- |_      | |_      |
|     --  |       | |       |   |     |   |     |
|       | --.   .-- --.   .--   |     |   |     |
\_______|   |___|     |___|     |_____|   |_____|
)""";
// 请注意最后一行文本第一个字符反斜线 (\) 不再有转义功能, 而被作为普通字符进入字符串定义

std::cout << x << std::endl;
std::cout << "====" << std::endl;
std::cout << y << std::endl;

/* 输出

(空行)
hello
world
(空行)
====
(空行)
 ________   _____     _____    ________  ________
/       |   |   |     |   |   /       | /       |
|       | --'   '-- --'   '-- |_      | |_      |
|     --  |       | |       |   |     |   |     |
|       | --.   .-- --.   .--   |     |   |     |
\_______|   |___|     |___|     |_____|   |_____|
(空行)

输出结束 */
```