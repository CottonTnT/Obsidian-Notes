-  编写时不指定具体类型，直到使用时才能确定，这个概念就是泛型。函数模板通常不用声明为 inline，唯一例外的是特定类型的全特化，因为编译器可能忽略 inline，函数模板是否内联取决于编译器的优化策略

```cpp

```

# 模板实参推断

1. 调用模板时，如果不显式指定模板参数类型，则编译器会根据传入的实参推断模板参数类型. 实参的推断要求一致，其*本身不会为了编译通过自动做类型转换*
``` cpp
#include <cassert>
#include <string>

namespace jc {

template <typename T>
T max(const T& a, const T& b) {
  return a < b ? b : a;
}

}  // namespace jc

int main() {
  assert(jc::max(1, 3) == 3);          // T 推断为 int
  assert(jc::max(1.0, 3.14) == 3.14);  // T 推断为 double
  std::string s1 = "down";
  std::string s2 = "demo";
  assert(jc::max(s1, s2) == "down");  // T 推断为 std::string
  jc::max(1, 3.14);  // 错误，T 分别推断出 int 和 double，类型不明确
}
```


**怎么解决**

-  对于推断不一致的情况，显式指定类型而不使用推断机制，或者强制转换实参为希望的类型使得推断结果一致

- 增加一个模板参数，这样每个实参的推断都是独立的，不会出现矛盾

```cpp
#include <cassert>
#include <string>

namespace jc {

template <typename T, typename U>
T max(const T& a, const U& b) {
  return a < b ? b : a;
}

}  // namespace jc

int main() {
  std::string s = "demo";
  assert(jc::max<std::string>("down", "demo") == "down");
  assert(jc::max(std::string{"down"}, s) == "down");
}
```


