-  编写时不指定具体类型，直到使用时才能确定，这个概念就是泛型。函数模板通常不用声明为 inline，唯一例外的是特定类型的全特化，因为编译器可能忽略 inline，函数模板是否内联取决于编译器的优化策略

```cpp

```

# 模板实参推断


## 类型推断中的类型转换
在类型推断的时候自动的类型转换是受限制的：
1. 如果调用参数是*按引用传递*的，任何类型转换都不被允许
2. 如果调用参数是按值传递的，那么只有*退化（decay）这一类简单转换是被允许*的：const 和 volatile 限制符会被忽略，引用被转换成被引用的类型，raw array 和函数被转换为相应的指针类型。*通过模板类型参数 T 定义的两个参数，它们实参的类型在退化（decay） 后必须一样*。
> [[item1 | 理解模板参数的推断]]
``` cpp
template T mx (T a, T b); …
int const c = 42; 
int i = 1; //原书缺少 i 的定义 
max(i, c); // OK: T 被推断为 int，c 中的 const 被 decay 掉 
max(c, c); // OK: T 被推断为 int 
int& ir = i;
max(i, ir); // OK: T 被推断为 int， ir 中的引用被 decay 掉 
int arr[4]; 
foo(&i, arr); // OK: T 被推断为 int* 
//但是像下面这样是错误的： 
max(4, 7.2); // ERROR: 不确定 T 该被推断为 int 还是 double std::string s; 
foo("hello", s); //ERROR: 不确定 T 该被推断为 const[6] 还是 std::strin
```


**怎么解决**
- 对参数做类型转换

-  显示指出类型参数T

-  增加模板参数，指明调用参数可能有不同类型
```cpp
//1.类型转换
max(static_cast(4), 7.2); // OK 
//2. 显式地指出类型参数 T 的类型，这样编译器就不再会去做类型推导。
max(4, 7.2); 
```

## 对默认调用参数的类型推断(Edge Case)

- 类型推断并不适用于默认调用参数

```cpp
template <typename T>
void f(T = "");
...
f(1); //ok, T推断为int
f(); //Error:无法推断出T的类型，即使有默认参数=“”
```

**解决方案**

- 给模板类型参数也声明一个默认参数
```cpp
template <typename T = std::string>
void f(T = "");
...
f(1)
```



