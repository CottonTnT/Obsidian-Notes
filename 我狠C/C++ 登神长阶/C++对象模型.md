# C++ 与 C的区别

> 	语言特性支持不一样，C++ 编译器高效实现了面向对象的特性,增加一些开销，其实对一个优秀的编译器而言，C++的各种特性本身就是使用C/汇编加以千锤百炼而最优化实现的。可以说，想用C甚至汇编比编译器更高效地实现某个C++特性几乎是不可能的。


- **总结** 不要将C++简单看作C语言的扩展，而要看作一门兼容C语言的新语言

[C通过结构体实现面向对象](https://www.zhihu.com/question/59292999)
 
# `class` 与 `struct`的区别

- 因为struct修饰的类的成员的默认访问权限是public, 而用class修饰的类的成员的默认访问权限是private
- struct 用于元编程


# 类成员变量

```cpp
class Var{
int a;
static int b;
const static int c =3;
Var d;
Var(){};
}
```

## non-static

-  每个类对象一份
```cpp
int main(){
	 Var var;
	 var.a = 3;
}
```


- **引用与const变量** 需在[[#成员初始化列表]] 初始化
- **类类型成员变量**  最好在[[#成员初始化列表]] 初始化

- **编译器生成的成员变量**  非静态类成员变量还包括一些编译器为实现多态特性而产生的变量，如`vftbl_ptr,vbtbl_ptri,etc`


## static

- 每个类一份，*所以定义及初始化时放在类外，防止static被重复[[terms in CPP#define | 定义]]*, 对定义为`const static`能在类里定义并初始化，是因为编译时直接被作为字面量

* *一些参考*
   *[如何保证static变量只初始化一次](https://cloud.tencent.com/developer/article/1495892)


# 类成员函数


```cpp
class Item{
int a;
...
void f1(){};//等价于 void f1(ITem*)
void static f2(){};
void f3() const {};  //等价于 void f3(Item * const )
void virtual f4(){};
}

```
## non-static
> 类的非静态函数就是一个普通函数，有一个隐藏的参数为调用对象的指针,每个类只有一份


```cpp
int main(){
	Item ins;
	ins.f1();	
	//等价于 f1(&ins);
	ins.f3();
 //等价于f3(&ins);
	ins.f4();
	//long *vftbl_ptr = (long*)&ins;获取虚函数表指针
	//long *vf4_ptr = (long*)(*vftbl_ptr);获取虚函数表的第一项，即为指向f4的函数指针
	// void (*f4)();
	// f4 = (vf4_ptr);
 // f4(&ins);
}
```


## static member function
> 类的静态函数也是一个普通函数，每个类只有一份, 没有一个隐藏的参数来传入一个指向调用对象的指针，故该函数中不能访问类的非静态成员，非静态成员函数等等


```cpp
int main(){
	Item ins;
	ins.f2();//等价于 Item.f2()
}
```

# 类构造函数

> 用于初始化类对象的数据成员, 故创建对象时，编译器会根据情况调用合适的构造函数为类对象进行初始化,其本质也是一个类

## 成员初始化列表


### 成员初始化列表与构造函数体的区别

* 成员初始化列表*使用初始化的方式*来为数据成员指定初值，而构造函数的函数体是*通过赋值的方式*来给数据成员指定初值。*即成员初始化列表是在数据成员定义的同时赋初值，但是构造函数的函数体是采用先定义后赋值的方式来做*。以下三种情况需要使用初始化列表，
   1.  需要初始化的数据成员是对象
   2.  需要初始化`const`修饰的类成员  
   3.  需要初始化引用成员数据

### 成员初始化列表的行为 

- 成员初始化列表的初始化顺序是按照类成员的声明顺序来的
- 初始化操作安排在构造函数所有usercode的前面.(I guess 估计也在编译器在构造函数体插入的一系列初始化虚函数表指针等代码之前)


## 默认构造函数(缺省构造函数)


### 编译器什么时候帮忙合成默认构造函数

> 没有定义任何构造函数，编译器某些特定的情况下就会帮我们定义 (合成) 一个默认构造函数


- 以下情况，均默认类中无任何构造函数

| num     | time     |
|:-----|:-----|
| 1     | 父类带缺省 $^{1}$ 的构造函数  |
| 2     | 父类或子类带虚函数     |
| 3 |  含有虚基类    |
| 4     | 类类型成员含有缺省的构造函数或虚函数或虚基类     |

**总结**   当编译器需要为我们在构造函数中插入一些代码如初始化 vftbl、vbtbl、调用父类缺省构造函数时，会合成一个默认构造函数

--- 
$^{1}$  缺省构造函数: 构造函数*没有参数*，或者构造函数的*所有参数都有默认值*, *一个类中只能有一个缺省构造函数*.


## 拷贝构造函数 


### 编译器什么时候帮忙合成拷贝构造函数

> 当类中没有定义任何拷贝构造函数，且满足一些条件，会帮忙合成构造函数


- 一下情况均默认类中无任何构造函数

|  num    |   time   |
|:-----|:-----|
|  1   |  类类型成员含有拷贝构造函数    |
|  2    |  父类含有拷贝构造函数    |
|  3    |  声明或继承类虚函数   |
| 4| 虚基类|

**总结**  当编译需要为我们的构造函数中插入一些代码如初始化 vftbl、vbtbl、调用父类拷贝构造函数时，会合成一个拷贝构造函数，其余情况均采用 bitwise 拷贝, 是一种浅拷贝。

## 移动构造函数


## C++ 参数传递机制


# 类对象所占内存空间


| name     | 占据空间    |
|:-----|:-----|
| 静态成员 (函数)    |  类本身   |
| 虚函数     | 类本身     |
| 虚函数指针     | 类本身     |
| 成员函数     | 类本身     |
| 虚基类表| |
| 成员变量 | 类对象|
| 虚函数表 | 列对象 |




# 多态的实质


# 虚函数

> 一个类有虚函数时，该类会产生一个虚函数表为该类共享，每个类对象会有一个虚函数表指针，用于指向类的虚函数表的开始地址



- 虚函数表可以看成一个数组，每个元素是一个虚函数的开始地址。可以使用函数类型来调用虚函数表的虚函数，可以绕过 private 的审查, 因为这是运行时确定的。

- 父类中有虚函数，子类中肯定有虚函数，故不管子类 overwrite 的函数中写不写 virtual, 依然是虚函数

- 子类父类的虚函数表内容可能相同，但虚函数表的位置不同

- 使用子类对象初始化父类时，子类的虚函数表的内容不会去覆盖父类对象的虚函数表, 这也是为什么不使用引用或指针无法出现多态；


- 以下 vftbl_ptr 位置的一些结论

|  time    | conclusion     |
|:-----|:-----|
| 没有虚基类时     |  vftbl_ptr 位于对象内存布局开始的位置    |
| 单继承     | 子类只有一个虚函数表     |
| 多继承     | 多个基类则有多个 vftbl, 多个 vftbl_ptr 且按继承顺序 $^{2}$ 依次放置在类的内存空间     |
| | |


**vftbl 的创建时机** 实际上，虚函数表是编译器在编译期间就为每个类确定好了对应的虚函数表 vtbl 的内容。然后在编译期间给相应的类的构造函数中添加给 vptr 赋值的代码。这样程序运行到创建对象时候调用构造函数，进行把虚函数表地址赋值给虚函数表指针。

**vftblptr 的创建时机**  vptr 跟着对象走，所以对象什么时候创建出来，vptr 就什么时候创建出来。


**静态联编** 编译的时候确定调用那一个函数, 栈上分配的对象采用静态联编

**动态联编** 在程序运行时，根据时机情况，动态把调用语句与函数绑定在一起。堆上分配的对象采用动态联编。


**静态绑定**  函数缺省参数是静态绑定的。

**动态绑定**  一般虚函数是动态绑定的.


--- 
$^{2}$ 在 msvc 中子类和第一个基类公用一个 vftbl_ptr





# 虚基类

> 解决多继承时的命名冲突和冗余数据问题，使得派生类中只保留一份间接基类的成员

- **什么是虚基类** 其本质是是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class）


- 在整个继承结构中，直接或间接继承虚基类的*所有派生类*，都必须在构造函数的成员初始化表中为虚基类的构造函数列出参数。如果未列出，则表示调用该虚基类的默认构造函数。
- 在建立对象时，只有最远派生类 $^{3}$ 的构造函数调用虚基类的构造函数，其他类对虚基类构造函数的调用被忽略。


- **虚基类表** 每个虚继承的子类都有一个虚基类表


--- 
$^3$  最远派生类: 建立对象时所指定的类

