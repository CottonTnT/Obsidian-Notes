# 1 copy elison

- 一道经典的面试题, 如下代码请问创建了几个string
```cpp
std::string s = "hello c++";

答案是1-2k```

>答案是1-2个

我们分情况讨论。首先是c++11之前。

在c++11前题目里的表达式实际上会导致下面的行为：

1. 首先`"hello c++"`是`const char[N]`类型的，不过它在表达式中于是退化成`const char *`
2. 然后因为s实际上是处于“声明即定义”的表达式中，因此适用的只有复制构造函数，而不是重载的=
3. 因此等号的右半边必须也是`string`类型
4. 因为正好有从`const char *`到`string`的转换规则，因此把它转换成合适的类型
5. 转换完会返回一个新的`string`的临时量，它会作为参数调用复制构造函数
6. 复制构造函数调用完成后s也就创建完毕了。


很快`c++11`就出现了，同时还带来了移动语义，然而结果并没有改变：

1. 前面步骤相同，字符串字面量隐式转换成string，创建了一个临时量
2. 临时量是个右值，所以绑定给右值引用，因此移动构造函数被选择
3. 临时量里的数据移动到s里，s创建完成

移动语义减少了不必要的内部数据的复制，但是临时量还是会被创建的。


`copy elision`复制省略在c++11里就已经被提到了，不过那时候它是可选的，并不强制编译器支持这一优化。复制省略*在c++17里成为了被标准化的行为*。

- 在c++17里除非必要，否则临时量（现在叫做右值的结果对象，一个右值只有在实际需要存在一个临时变量的情况下才会创建一个临时变量，这个过程叫做实质化，创建出来的那个临时量就是该右值的结果对象）不会被创建，换而言之，`T obj = expr`*这样的形式会以expr产生结果直接调用合适的构造函数，而不会进行临时量的创建和复制构造函数的调用*，*不过为了保证语义的完整性，复制构造函数仍然被要求是可访问的，毕竟类本身不允许复制构造的话复制初始化本身就是不正确的，不能因为复制省略而导致错误的代码被编译通过*。


所以现在过程变成了下面这样子：

1. 编译器发现表达式是string的复制初始化
2. 右侧是表达式会隐式转换产生一个string的纯右值用于初始化同一类型的s
3. 判断复制构造函数是否可用，然后发现符合复制省略的条件
4. 寻找string里是否有符合要求的构造函数
5. 找到了`string::string(const char *)`，于是直接调用
6. s初始化完成

因此，在c++17下只会创建一个string对象，这比移动语义更加高效。这也是为什么我说题目的答案既可以是1也可以是2的原因。

同时我们还发现，在复制构造时的类型转换不管复制有没有被省略都是存在的，只不过换了一个形式，这就是我们后面要讲的内容。



# RVO

