# inline

## 作用
- 在 c/c++中，为了解决一些频繁调用的*小函数*大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。
- 作用在编译阶段


## 限制 


1. inline 是开发者对编译器的一个建议，*编译器可以做，也可以不做*，取决于编译器的选择。使用 inline 之后，编译器内部会有一个比较复杂的测试算法来评估这个 inline 函数的复杂度,如果编译器评估这个 inline 函数复杂度过高，这个 inline 建议就被编译器忽略，当作一个常规函数处理。

2. inline 的使用是**有所限制的**，inline 只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数  ,这些都会导致内联失败


## 使用建议

- 内联函数最好放在头文件中
- 内联函数中尽量少的使用局部变量


## 细节

1. 关键字inline 必须与**函数定义体**放在一起才能使函数成为内联，仅将inline 放在函数声明前面**不起任何作用**。
2. **定义**在类中的**成员函数**缺省都是**内联的**，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的。


# const

## 作用
- 作用在编译期


## 用法

[const具体用法](https://blog.csdn.net/weixin_56935264/article/details/125760242?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-125760242-blog-50948667.235^v38^pc_relevant_anti_vip_base&spm=1001.2101.3001.4242.1&utm_relevant_index=3)


## 顶层 const 与底层 const

*顶层 const* ：表示指针本身是一个常量, 放在\*右边

*底层 const*：表示指针所指的对象是一个常量\*左边


```c
const int a = 10;//顶层
const int * const p = new int(10); //底层， 顶层
const int & ra = 10; //底层，引用机制类似指针, 一个引用变量相当于一个指针常量
```


### 一个规则

- **当执行对象拷贝操作是，常量的顶层 const 不受什么影响，而底层的 const 必须一致
 
# define


## 作用

- 类型表示符、定义宏
- 作用在预处理阶段


## 用法

```c
#define <宏名>(<参数表>) <字符串>

```
- 带参数的宏定义，除了一般的字符串替换，还要做参数代换
- 对于“”的宏不会做替换

## 宏与函数对比 

1. 宏没有类型检查
2. 宏单纯只是文本替换，故不能调试，没有函数调用的开销，但会使代码膨胀，容易产生宏污染
3. 函数的参数如果是表达式，会计算出表达式的结果后传入参数，而宏的参数只会进行文本替换
## 宏嵌套 


**宏嵌套展开规则** 
1. 如同函数的参数一样：先展开参数，再分析函数，由内向外
2. 当宏中有 `#` 的时候，不展开参数
3. 当宏中有##的时候，先展开函数，再分析参数
4. `##` 运算符用于将参数链接到一起，预处理过程把出现在 `##` 两侧的参数合并成一个符号，不是字符串

	具体嵌套不追究，有点 nt



**`#` 与 `##` 的使用规则** 

```cpp
#define T(x) #(x) //将宏参数转为字符串，不展开参数
#define T(x) x##[2] //展把宏参数与之前的token(参数/字符串等)链接起来。
```

## 使用建议

- 使用宏时，替换的表达式一定用 ()包起来
- 一般全大写命名


# decltype


## 作用
- c++11 新增关键字，和 auto 功能一样用于**编译时期**的自动类型推导
- 根据 exp 表达式推导出变量的类型




# constexpr

## 作用

**标识符**
1. `constexpr` 说明符*声明编译时*可以对函数或变量求值

2.
  1. `constexpr`声明对象或非静态成员函数时*蕴含const*
  2. `constexpr` 声明函数或静态成员变量时 *蕴含inline*






#  noexcept


## 作用


- **用作运算符**  noexcept运算符*进行编译时检查*，如果表达式不会抛出任何异常则返回true
- **标识符** 指定函数是否抛出异常

