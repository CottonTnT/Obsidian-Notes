
# 用 complier 取代 preprocessor


***即用 consts, enums 和 inlines 取代  \#defines***


```c
#define ASPECT_RATIO 1.653 //No!
const double AspectRation = 1.653 //Yes!
```



### define 与 const 的优缺点

  https://blog.csdn.net/weibo1230123/article/details/81981384 




## 用 const 替换 defines 注意情况


- 常量字符串
```c
#define str "Scott Meyers"
const char * const str = "Scott Meyers"; //放在头文件中时，肯定不希望指针本身、指针指向的内容改变
const std::string str = ("Scott Meyers");
```
  


- 涉及到 class-specific constants



## 用 enum 替代




## 用 inline 替代

```c
//call f with the maximum of a and b
// #define版

#define CALL_WITH_MAX(a, b) f((a) > (b) ? (a) : (b))
int a = 5, b = 0;
CALL_WITH_MAX(++a, b); // a is incremented twice
CALL_WITH_MAX(++a, b+10); // a is incremented once

// inline 版
template<typename T>                               // because we don't
inline void callWithMax(const T& a, const T& b)    // know what T is, we
{                                                  // pass by reference-to-
  f(a > b ? a : b);                                // const - see Item 20
}

```



# 只要可能就用const


## 顶层 const 与底层 const


*顶层 const* ：表示指针本身是一个常量, 放在\*右边

*底层 const*：表示指针所指的对象是一个常量\*左边


```c
const int a = 10;//顶层
const int * const p = new int(10); //底层， 顶层
const int & ra = 10; //底层，引用机制类似指针, 一个引用变量相当于一个指针常量
```



### 一个规则

- **当执行对象拷贝操作是，常量的顶层 const 不受什么影响，而底层的 const 必须一致
 



## iterator 与 const


STL iterators（迭代器）以 pointers（指针）为原型，所以一个 iterator 在行为上非常类似于一个 T* pointer（指针）


```cpp
std::vector<int> vec;
...
const std::vector<int>::iterator iter =     // iter acts like a T* const
  vec.begin();
*iter = 10;                                 // OK, changes what iter points to
++iter;                                     // error! iter is const

std::vector<int>::const_iterator cIter =    // cIter acts like a const T*
  vec.begin();
*cIter = 10;                                // error! *cIter is const
++cIter;                                    // fine, changes cIter
```


## const in function declarations


在一个 function declaration（函数声明）中，const 既可以用在函数的 return value（返回值）上，也可以用在个别的 parameters（参数）上，对于 member functions（成员函数），还可以用于整个函数。


### 利用 const 有效避错


```cpp
class Rational{ ... };
const Rational operator*{const Rational& lhs, const Rational& rhs};

Rational a, b, c;
//if no const before line 2 
(a * b) = c //right, invoke operator= on the result of a*b
//how about next?
if((a*b) = c) //missing a =,but stll work,horrible! meant to do a comparison!
```


### const member functions


- member functions（成员函数）被声明为 const 的目的是标明这个 member functions（成员函数）可能会被 const objects（对象）调用, 且该函数。


```c
//1.member functions 在只有constness不同时是可以重载的，如下
class TextBlock{
public:
	const char& operator[](std::size_t position) const{
		return text[position];}

	char& operator[](std::size_t position){
		return text[position]};

private:
	std::string text;
}
```


```c
TextBlock tb("Hello");
std::cout << tb[0];                    // calls non-const TextBlock::operator[]
const TextBlock ctb("World");
std::cout << ctb[0];                   // calls const TextBlock::operator[]
ctb[0] = 'x';                          // error! — writing a
                                       // const TextBlock
//再请注意 non-const 版本的 operator[] 的 return type（返回类型）是 reference to a char（一个 char 的引用）而不是一个 char 本身。如果 operator[] 只是返回一个简单的 char，下面的语句将无法编译：
tb[0] = 'x';
```



