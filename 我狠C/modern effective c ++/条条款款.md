
# 用 complier 取代 preprocessor


***即用 consts, enums 和 inlines 取代  \#defines***


```c
#define ASPECT_RATIO 1.653 //No!
const double AspectRation = 1.653 //Yes!
```



### define 与 const 的优缺点

  https://blog.csdn.net/weibo1230123/article/details/81981384 




## 用 const 替换 defines 注意情况


- 常量字符串
```c
#define str "Scott Meyers"
const char * const str = "Scott Meyers"; //放在头文件中时，肯定不希望指针本身、指针指向的内容改变
const std::string str = ("Scott Meyers");
```
  


- 涉及到 class-specific constants



## 用 enum 替代




## 用 inline 替代

```c
//call f with the maximum of a and b
// #define版

#define CALL_WITH_MAX(a, b) f((a) > (b) ? (a) : (b))
int a = 5, b = 0;
CALL_WITH_MAX(++a, b); // a is incremented twice
CALL_WITH_MAX(++a, b+10); // a is incremented once

// inline 版
template<typename T>                               // because we don't
inline void callWithMax(const T& a, const T& b)    // know what T is, we
{                                                  // pass by reference-to-
  f(a > b ? a : b);                                // const - see Item 20
}

```



# 只要可能就用const


## 顶层 const 与底层 const


*顶层 const* ：表示指针本身是一个常量, 放在\*右边

*底层 const*：表示指针所指的对象是一个常量\*左边


```c
const int a = 10;//顶层
const int * const p = new int(10); //底层， 顶层
const int & ra = 10; //底层，引用机制类似指针, 一个引用变量相当于一个指针常量
```



### 一个规则

- **当执行对象拷贝操作是，常量的顶层 const 不受什么影响，而底层的 const 必须一致
 



## iterator 与 const


STL iterators（迭代器）以 pointers（指针）为原型，所以一个 iterator 在行为上非常类似于一个 T* pointer（指针）


```cpp
std::vector<int> vec;
...
const std::vector<int>::iterator iter =     // iter acts like a T* const
  vec.begin();
*iter = 10;                                 // OK, changes what iter points to
++iter;                                     // error! iter is const

std::vector<int>::const_iterator cIter =    // cIter acts like a const T*
  vec.begin();
*cIter = 10;                                // error! *cIter is const
++cIter;                                    // fine, changes cIter
```


## const in function declarations


在一个 function declaration（函数声明）中，const 既可以用在函数的 return value（返回值）上，也可以用在个别的 parameters（参数）上，对于 member functions（成员函数），还可以用于整个函数。


### 利用 const 有效避错


```cpp
class Rational{ ... };
const Rational operator*{const Rational& lhs, const Rational& rhs};

Rational a, b, c;
//if no const before line 2 
(a * b) = c //right, invoke operator= on the result of a*b
//how about next?
if((a*b) = c) //missing a =,but stll work,horrible! meant to do a comparison!
```


### const member functions


- member functions（成员函数）被声明为 const 的目的是标明这个 member functions（成员函数）可能会被 const objects（对象）调用, 且该函数。


```c
//1.member functions 在只有constness不同时是可以重载的，如下
class TextBlock{
public:
	const char& operator[](std::size_t position) const{
		return text[position];}

	char& operator[](std::size_t position){
		return text[position]};

private:
	std::string text;
}
```


```c
TextBlock tb("Hello");
std::cout << tb[0];                    // calls non-const TextBlock::operator[]
const TextBlock ctb("World");
std::cout << ctb[0];                   // calls const TextBlock::operator[]
ctb[0] = 'x';                          // error! — writing a
                                       // const TextBlock
//再请注意 non-const 版本的 operator[] 的 return type（返回类型）是 reference to a char（一个 char 的引用）而不是一个 char 本身。如果 operator[] 只是返回一个简单的 char，下面的语句将无法编译：
tb[0] = 'x';
```


-  



# 对象使用前应该被初始化

 - **确保 all constructors 都初始化了 object 中的每一样东西**
 
```c
int x;//某些情况下，x会被初始为0,某些情况不会
---
class Point{
int x, y;
};
Point p;//p的data member有时会初始化为0,有时不会

//处理这种事情的表面不确定状态的最好方法就是总是在使用之前初始化你的对象。
```



## 成员初始化列表优于体内赋值
```c
class PhoneNumber { ... };

class ABEntry {                         // ABEntry = "Address Book Entry"

public:

  ABEntry(const std::string& name, const std::string& address,
          const std::list<PhoneNumber>& phones);

private:

  std::string theName;

  std::string theAddress;

  std::list<PhoneNumber> thePhones;

  int num TimesConsulted;

};

// asignment-based版本 //ABEntry::ABEntry(const std::string& name, const std::string& address,const std::list<PhoneNumber>& phones){

//  theName = name;                       // these are all assignments,
// theAddress = address;                 // not initializations
//  thePhones = phones;
//  numTimesConsulted = 0;
//}

//member initializaion list 版 
ABEntry::ABEntry(const std::string& name, const std::string& address,
                 const std::list<PhoneNumber>& phones)

: theName(name),
  theAddress(address),                  // these are now all initializations
  thePhones(phones),
  numTimesConsulted(0)    //内置类型都差不多

{}                                      // the ctor body is now empty

//assignment-based 的版本会首先调用 default constructors初始化 theName，theAddress 和 thePhones，然而很快又在 default-constructed的值之上赋予新值。那些 default constructions（缺省构造函数）所做的工作被浪费了。而 member initialization list（成员初始化列表）的方法避免了这个问题，因为 initialization list（初始化列表）中的 arguments（参数）就可以作为各种 data members（数据成员）的 constructor（构造函数）所使用的 arguments（参数）。在这种情况下，theName 从 name 中 copy-constructed（拷贝构造），theAddress 从 address 中 copy-constructed（拷贝构造），thePhones 从 phones 中 copy-constructed（拷贝构造）。对于大多数类型来说，只调用一次 copy constructor（拷贝构造函数）的效率比先调用一次 default constructor（缺省构造函数）再调用一次 copy assignment operator（拷贝赋值运算符）的效率要高（有时会高很多）。


```



- 有时，即使是 built-in types，initialization list 也必须使用。比如，const 或 references data members 是必须 be initialized（被初始化）的，它们不能 be assigned
- 初始化列表的顺序与类数据成员定义的先后有关，与初始化列表里的前后无关


## 定义在不同转换单元内的非局部静态对象的初始化的相对顺序是没有定义的 


一个 translation unit 是可以形成一个单独的 object file 的 source code（源代码）。基本上是一个单独的 source file，再加上它全部的 include 文件。


```cpp
class FileSystem{
public;
	std::size_t numDisks() const;

};

---
extern FileSystem tfs;

class Directory{
public:
	Directory(params);
};

Directory::Directory(params){
	std::size_t disks = tfs.numDisks(); //use the tfs
}

Directory tempDir(params); //directory for temporary files

//现在 initialization order（初始化顺序）的重要性变得明显了：除非 tfs 在 tempDir 之前初始化，否则，tempDir 的 constructor（构造函数）就会在 tfs 被初始化之前试图使用它。但是，tfs 和 tempDir 是被不同的人于不同的时间在不同的 source files（源文件）中创建的——它们是定义在不同 translation units（转换单元）中的 non-local static objects（非局部静态对象）。


```
```c
//改良版
class FileSystem { ... };           // as before

FileSystem& tfs()                   // this replaces the tfs object; it could be
{                                   // static in the FileSystem class
  static FileSystem fs;             // define and initialize a local static object
  return fs;                        // return a reference to it
}

--- 

class Directory { ... };            // as before

Directory::Directory( params )      // as before, except references to tfs are
{                                   // now to tfs()
  ...
  std::size_t disks = tfs().numDisks();
  ...
}

Directory& tempDir()                // this replaces the tempDir object; it
{                                   // could be static in the Directory class
  static Directory td;              // define/initialize local static object
  return td;                        // return reference to it
}
```



# 了解 c ++默认生成的函数 


```c
class Bar{
public:
	explicit Bar(std::string &name, int intValue = 10)
		:name_(name), intValue_(intValue){}

public:
	std::string &name_;
	const int intValue_;
	//std::mutex mutex; 17,18行失效，因为该变量不可拷贝与移动
}


int main(){

	std::string name1 = "bar1";
	std::string name2 = "bar2";
	Bar bar1(name1), bar2(name2);
	Bar bar3(bar1);//使用拷贝构造函数，编译器帮我们生成
	Bar bar4(std::move(bar1));//使用移动构造函数，编译器帮我们生产
	bar3 = bar2;//wrong,因为我们定义了引用和常量数据成员
	bar4 = std::move(bar2);//wrong, 同上
	return 0;
}
```


# 对于不想要的特种成员函数，明确禁止编译器自动生成

```c
//how to solve？
HomeForSale h1;
HomeForSale h2;
HomeForSale h3(h1); // attempt to copy h1 -- should not compile!
h1 = h2; //attempt to copy h2 -- should not compile!

//modern c++
class HomeForSale{
public:

HomeForSale(const HomeForSale&) = delete; //declaration only
HomeForSale& operator=(const HomeForSale&) = delete; //declaration only




}

//c ++ 98
class HomeForSale{
public:

private:

HomeForSale(const HomeForSale&); //declaration only
HomeForSale& operator=(const HomeForSale&); //declaration only
}
//编译阶段可过，链接阶段报错

//如何做到编译阶段都不行ne？

class Uncopyable {
protected:                                   // allow construction
  Uncopyable() {}                            // and destruction of
  ~Uncopyable() {}                           // derived objects...

private:
  Uncopyable(const Uncopyable&);             // ...but prevent copying
  Uncopyable& operator=(const Uncopyable&);
};

class HomeForSale: private Uncopyable {      // class no longer
  ...                                        // declares copy ctor or
};                                           // copy assign. operator

```


# 7. 在 polymorphic base classes 中将 destructor 声明为 virtual


- destructors（析构函数）的工作方式是：most derived class（层次最低的派生类）的 destructor（析构函数）最先被调用，然后调用每一个 base class（基类）的 destructors（析构函数）。所以你必须为纯虚构函数提供一个定义，不然链接程序会抗议滴！

-  C++ 规定：当一个 derived class object（派生类对象）通过使用一个 pointer to a base class with a non-virtual destructor（指向带有非虚拟析构函数的基类的指针）被删除，则结果是未定义的。运行时比较典型的后果是 derived part of the object（这个对象的派生部分）不会被析构。
```c
class TimeKeeper {
public:
  TimeKeeper();
  ~TimeKeeper();//no
	//cmp 
  virtual ~TimeKeeper();//yes
  ...
};

class AtomicClock: public TimeKeeper { ... };

class WaterClock: public TimeKeeper { ... };

class WristWatch: public TimeKeeper { ... };

TimeKeeper *ptk = getTimeKeeper();

delete ptk;    
```


- 当一个 class（类）不打算作为 base class（基类）时，将 destructor（析构函数）虚拟通常是个坏主意。
- 
```text
virtual functions（虚拟函数）的实现要求 object（对象）携带额外的信息，这些信息用于在运行时确定该 object（对象）应该调用哪一个 virtual functions（虚拟函数）。典型情况下，这一信息具有一种被称为 vptr ("virtual table pointer")（虚拟函数表指针）的指针的形式。vptr 指向一个被称为 vtbl ("virtual table")（虚拟函数表）的 array of function pointers（函数指针数组），每一个带有 virtual functions（虚拟函数）的 class（类）都有一个相关联的 vtbl。当在一个 object（对象）上调用 virtual functions（虚拟函数）时，实际的被调用函数通过下面的步骤确定：找到 object（对象）的 vptr 指向的 vtbl，然后在 vtbl 中寻找合适的 function pointer（函数指针）。
```


- **declare a virtual destructor in a class if and only if that class contains at least one virtual function（当且仅当一个类中包含至少一个虚拟函数时，则在类中声明一个虚拟析构函数）**。


- **不是设计用来作为 base classes（基类）或不是设计用于 polymorphically（多态）的 classes（类）就不应该声明 virtual destructor（虚拟析构函数）**




# 8.防止因为 exceptions 而离开 destuctors


```cpp
class DBConnection {
public:
  ...

  static DBConnection create();        // function to return
                                       // DBConnection objects; params
                                       // omitted for simplicity

  void close();                        // close connection; throw an
};       
```

```cpp
class DBConn {                          // class to manage DBConnection
public:                                 // objects
  ...
  ~DBConn()                             // make sure database connections
  {                                     // are always closed
   db.close();
  }
private:
  DBConnection db;
};
```
```cpp
{                                       // open a block
   DBConn dbc(DBConnection::create());  // create DBConnection object
                                        // and turn it over to a DBConn
                                        // object to manage
 ...                                    // use the DBConnection object
                                        // via the DBConn interface
}                                       // at end of block, the DBConn
                                        // object is destroyed, thus
                                        // automatically calling close on
                                        // the DBConnection object
```
只要能成功地调用 close 就可以了，但是如果这个调用导致一个 exception（异常），DBConn 的 destructor（析构函数）将传播那个 exception（异常），也就是说，它将离开 destructor（析构函数）。


*有如下解决办法*

- Terminate the program if close tHRows
```cpp

DBConn::~DBConn()
{
 try { db.close(); }
 catch (...) {
   make log entry that the call to close failed;
   std::abort();
 }
}

```
- Swallow the exception arising from the call to close
```cpp
DBConn::~DBConn()
{
 try { db.close(); }
 catch (...) {
      make log entry that the call to close failed;
 }
}
```
- better interface design
```c

class DBConn {
public:
  ...

  void close()                                     // new function for
  {                                                // client use
    db.close();
    closed = true;
  }

  ~DBConn()
  {
   if (!closed) {
   try {                                            // close the connection
     db.close();                                    // if the client didn't
   }
   catch (...) {                                    // if closing fails,
     make log entry that call to close failed;      // note that and
     ...                                            // terminate or swallow
   }
  }

private:
  DBConnection db;
  bool closed;
};

```


Things to Remember

- destructor（析构函数）应该永不引发 exceptions（异常）。如果 destructor（析构函数）调用了可能抛出异常的函数，destructor（析构函数）应该捕捉所有异常，然后抑制它们或者终止程序。
    
- 如果 class（类）客户需要能对一个操作抛出的 exceptions（异常）做出回应，则那个 class（类）应该提供一个常规的函数（也就是说，non-destructor（非析构函数））来完成这个操作。


# 9. 绝不要在 construction或 destruction期间调用 virtual functions


因为 base class constructors（基类构造函数）在 derived class constructors（派生类构造函数）之前执行，当 base class constructors（基类构造函数）运行时，derived class data members（派生类数据成员）还没有被初始化。如果 base class construction（基类构造）期间 virtual functions（虚拟函数）的调用 went down（向下匹配）到 derived classes（派生类），derived classes（派生类）的函数差不多总会涉及到 local data members（局部数据成员），但是那些 data members（数据成员）至此还没有被初始化。这就会为 undefined behavior（未定义行为）和通宵达旦的调试噩梦开了一张通行证。调用涉及到一个 object（对象）还没有被初始化的构件自然是危险的，所以 C++ 告诉你此路不通。直到 derived class constructor（派生类构造函数）的执行开始之前，一个 object（对象）不会成为一个 derived class object（派生类对象）。


```cpp
class Base{
public:
	Base(){
		sayHello();
	}
	virtual void sayHello(){
		std::cout<<"Hello, Base!" << std::endl;
	}
	virtual void sayBye(){
		std::cout <<"Bye, Base!" << std::endl;
	}

	virtual ~Base(){
		sayBye();
	}
}

class Derived:public Base{
public:
	Derived(){}

	void sayHello()override{
		std::cout<<"Hello, Derived!" << std::endl;
	}	
	void sayBye()override{
		std::cout<<"Bye, Derived!" << std::endl;
	}
	
}
```
- 运行结果
![[Pasted image 20230720141823.png]]


# 10. 让 assignment operators（赋值运算符）返回一个 reference to \*this



```cpp
class Widget {
public:

//right
Widget& operator=(const Widget& rhs)   // return type is a reference to
{                                      // the current class
  ...
  return *this;                        // return the left-hand object
  }
  ...
};
//wrong
void operator=(const Widget& rhs){
  ...
}
---

Widget w1(1), w2(2), w3(3);
w2 = w1;
w3 = w2 = w1; //采用wrong版就wrong了
```

这个惯例适用于所有的 assignment operators（赋值运算符），而不仅仅是上面那样的标准形式。因此：

```
class Widget {
public:
  ...
  Widget& operator+=(const Widget& rhs   // the convention applies to
  {                                      // +=, -=, *=, etc.
   ...
   return *this;
  }
   Widget& operator=(int rhs)            // it applies even if the
   {                                     // operator's parameter type
      ...                                // is unconventional
      return *this;
   }
   ...
};
```


# 在 operator=中处理 assignment to self

```
class Widget { ... };

Widget w;
...

w = w;  
```

```
class Bitmap { ... };

class Widget {
  ...

private:
  Bitmap *pb;                                     // ptr to a heap-allocated object
};
```

```
Widget&
Widget::operator=(const Widget& rhs)              // unsafe impl. of operator=
{
  delete pb;                                      // stop using current bitmap
  pb = new Bitmap(*rhs.pb);                       // start using a copy of rhs's bitmap

  return *this;                                   // see Item 10
}
```
```
Widget& Widget::operator=(const Widget& rhs)
{
  if (this == &rhs) return *this;   // identity test: if a self-assignment,
                                    // do nothing
  delete pb;
  pb = new Bitmap(*rhs.pb);

  return *this;
}
```
```
Widget& Widget::operator=(const Widget& rhs)
{
  Bitmap *pOrig = pb;               // remember original pb
  pb = new Bitmap(*rhs.pb);         // make pb point to a copy of *pb
  delete pOrig;                     // delete the original pb

  return *this;
}
```
```
class Widget {
  ...
  void swap(Widget& rhs);       // exchange *this's and rhs's data;
  ...                           // see Item 29 for details
};

Widget& Widget::operator=(const Widget& rhs)
{
  Widget temp(rhs);             // make a copy of rhs's data

  swap(temp);                   // swap *this's data with the copy's
  return *this;
}
```
```
Widget& Widget::operator=(Widget rhs)   // rhs is a copy of the object
{                                       // passed in — note pass by val

  swap(rhs);                            // swap *this's data with
                                        // the copy's
  return *this;
}
```


# 12. 拷贝一个对象的所有组成部分




# 13. 使用对象管理资源 (已过时)

- RAII：因为获取一个资源并在同一个语句中初始化资源管理对象是如此常见，所以使用对象管理资源的观念也常常被称为 Resource Acquisition Is Initialization (RAII)

# 14.谨慎考虑资源管理类的拷贝行为



![[Pasted image 20230720150111.png]]


# 15. 在资源管理类中准备访问裸资源




# 16. 使用相同形式的 new 与 delete

![[Pasted image 20230720155333.png]]