
# 用 complier 取代 preprocessor


***即用 consts, enums 和 inlines 取代  \#defines***


```c
#define ASPECT_RATIO 1.653 //No!
const double AspectRation = 1.653 //Yes!
```



### define 与 const 的优缺点

  https://blog.csdn.net/weibo1230123/article/details/81981384 




## 用 const 替换 defines 注意情况


- 常量字符串
```c
#define str "Scott Meyers"
const char * const str = "Scott Meyers"; //放在头文件中时，肯定不希望指针本身、指针指向的内容改变
const std::string str = ("Scott Meyers");
```
  


- 涉及到 class-specific constants



## 用 enum 替代




## 用 inline 替代

```c
//call f with the maximum of a and b
// #define版

#define CALL_WITH_MAX(a, b) f((a) > (b) ? (a) : (b))
int a = 5, b = 0;
CALL_WITH_MAX(++a, b); // a is incremented twice
CALL_WITH_MAX(++a, b+10); // a is incremented once

// inline 版
template<typename T>                               // because we don't
inline void callWithMax(const T& a, const T& b)    // know what T is, we
{                                                  // pass by reference-to-
  f(a > b ? a : b);                                // const - see Item 20
}

```



# 只要可能就用const


## 顶层 const 与底层 const


*顶层 const* ：表示指针本身是一个常量, 放在\*右边

*底层 const*：表示指针所指的对象是一个常量\*左边


```c
const int a = 10;//顶层
const int * const p = new int(10); //底层， 顶层
const int & ra = 10; //底层，引用机制类似指针, 一个引用变量相当于一个指针常量
```



### 一个规则

- **当执行对象拷贝操作是，常量的顶层 const 不受什么影响，而底层的 const 必须一致
 



## iterator 与 const


STL iterators（迭代器）以 pointers（指针）为原型，所以一个 iterator 在行为上非常类似于一个 T* pointer（指针）


```cpp
std::vector<int> vec;
...
const std::vector<int>::iterator iter =     // iter acts like a T* const
  vec.begin();
*iter = 10;                                 // OK, changes what iter points to
++iter;                                     // error! iter is const

std::vector<int>::const_iterator cIter =    // cIter acts like a const T*
  vec.begin();
*cIter = 10;                                // error! *cIter is const
++cIter;                                    // fine, changes cIter
```


## const in function declarations


在一个 function declaration（函数声明）中，const 既可以用在函数的 return value（返回值）上，也可以用在个别的 parameters（参数）上，对于 member functions（成员函数），还可以用于整个函数。


### 利用 const 有效避错


```cpp
class Rational{ ... };
const Rational operator*{const Rational& lhs, const Rational& rhs};

Rational a, b, c;
//if no const before line 2 
(a * b) = c //right, invoke operator= on the result of a*b
//how about next?
if((a*b) = c) //missing a =,but stll work,horrible! meant to do a comparison!
```


### const member functions


- member functions（成员函数）被声明为 const 的目的是标明这个 member functions（成员函数）可能会被 const objects（对象）调用, 且该函数。


```c
//1.member functions 在只有constness不同时是可以重载的，如下
class TextBlock{
public:
	const char& operator[](std::size_t position) const{
		return text[position];}

	char& operator[](std::size_t position){
		return text[position]};

private:
	std::string text;
}
```


```c
TextBlock tb("Hello");
std::cout << tb[0];                    // calls non-const TextBlock::operator[]
const TextBlock ctb("World");
std::cout << ctb[0];                   // calls const TextBlock::operator[]
ctb[0] = 'x';                          // error! — writing a
                                       // const TextBlock
//再请注意 non-const 版本的 operator[] 的 return type（返回类型）是 reference to a char（一个 char 的引用）而不是一个 char 本身。如果 operator[] 只是返回一个简单的 char，下面的语句将无法编译：
tb[0] = 'x';
```


-  



# 对象使用前应该被初始化

 - **确保 all constructors 都初始化了 object 中的每一样东西**
 
```c
int x;//某些情况下，x会被初始为0,某些情况不会
---
class Point{
int x, y;
};
Point p;//p的data member有时会初始化为0,有时不会

//处理这种事情的表面不确定状态的最好方法就是总是在使用之前初始化你的对象。
```



## 成员初始化列表优于体内赋值
```c
class PhoneNumber { ... };

class ABEntry {                         // ABEntry = "Address Book Entry"

public:

  ABEntry(const std::string& name, const std::string& address,
          const std::list<PhoneNumber>& phones);

private:

  std::string theName;

  std::string theAddress;

  std::list<PhoneNumber> thePhones;

  int num TimesConsulted;

};

// asignment-based版本 //ABEntry::ABEntry(const std::string& name, const std::string& address,const std::list<PhoneNumber>& phones){

//  theName = name;                       // these are all assignments,
// theAddress = address;                 // not initializations
//  thePhones = phones;
//  numTimesConsulted = 0;
//}

//member initializaion list 版 
ABEntry::ABEntry(const std::string& name, const std::string& address,
                 const std::list<PhoneNumber>& phones)

: theName(name),
  theAddress(address),                  // these are now all initializations
  thePhones(phones),
  numTimesConsulted(0)    //内置类型都差不多

{}                                      // the ctor body is now empty

//assignment-based 的版本会首先调用 default constructors初始化 theName，theAddress 和 thePhones，然而很快又在 default-constructed的值之上赋予新值。那些 default constructions（缺省构造函数）所做的工作被浪费了。而 member initialization list（成员初始化列表）的方法避免了这个问题，因为 initialization list（初始化列表）中的 arguments（参数）就可以作为各种 data members（数据成员）的 constructor（构造函数）所使用的 arguments（参数）。在这种情况下，theName 从 name 中 copy-constructed（拷贝构造），theAddress 从 address 中 copy-constructed（拷贝构造），thePhones 从 phones 中 copy-constructed（拷贝构造）。对于大多数类型来说，只调用一次 copy constructor（拷贝构造函数）的效率比先调用一次 default constructor（缺省构造函数）再调用一次 copy assignment operator（拷贝赋值运算符）的效率要高（有时会高很多）。


```



- 有时，即使是 built-in types，initialization list 也必须使用。比如，const 或 references data members 是必须 be initialized（被初始化）的，它们不能 be assigned
- 初始化列表的顺序与类数据成员定义的先后有关，与初始化列表里的前后无关


## 定义在不同转换单元内的非局部静态对象的初始化的相对顺序是没有定义的 


一个 translation unit 是可以形成一个单独的 object file 的 source code（源代码）。基本上是一个单独的 source file，再加上它全部的 include 文件。