# gcc hello.c的完整过程

$$
Preprocessing{\rightarrow}Compilation{\rightarrow}Assembly{\rightarrow}Liking

$$
- 下面是 gcc 编译过程的分解

![[Pasted image 20230721201458.png]]

*第一步预编译过程相当于* 

<center>gcc -E hello. c -o hello. i</center>
<center>cpp hello. c > hello. i</center>
*编译过程*
<center>gcc -S hello. i -o hello.s</center>
	现在 gcc 一般把预编译与编译两个步骤合并为一个步骤
<center>cc 1 hello.c</center>

	
*汇编*
<center>gcc -c hello.s -o hello.o </center>
或者
<center>as hello. s -o hello.o</center>
*链接*

![[Pasted image 20230721221711.png]]

# 编译器做了什么


- 编译器编译的过程一般可以分为 6 步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。

- 整个过程如下图所示
![[Pasted image 20230721222126.png]]

## 词法分析


### scanner 
- 首先 source code 被输入到扫描器 (scanner：简单进行词法分析，运用类似于有限状态机算法将源代码的字符序列分割成一系列的记号，即 Token). 如下程序
```c
array[index]=(index + 4) * (2 + 6);
```
![[Pasted image 20230721222943.png]]

>词法分析中的记号一般分为如下几类: 关键字、表示符、字面量（数字、字符串等）、和特殊符号 (+、-等)

 

- 在识别记号的同时, scanner 也完成了如将 `将表示符存放到符号表，将数字、字符串常量存放到文字表` 等工作


###  lex

- lex 可以按照用户之前描述好的词法规则将输入的字符串分割成一个个 token，这样编译器的开发者无需为每个编译器开发一个独立的词法扫描器了，只需根据需要改变语法规则


### 预处理


- 如 C 语言，它的预处理工作一般不归入编译器的范围而交给一个独立的预处理器


## 语法分析


### Grammer parser (语法分析器)

- 对 scanner 产生的 tokens, 通过*上下文无关文法*(context-free grammer)的分析手段进行语法分析，产生*语法树*（syntax tree）。
- 语法树就是表达式 (expression)为节点的树，如 c 语言的一个语句就是一个表达式，复杂的语句就是很多表达式的组合。如下程序语法树如下
```c
array[index]=(index + 4) * (2 + 6);
```

![[Pasted image 20230722095303.png]]

- 如果表达式不合法，比如括号各种括号不匹配、表达式中缺少操作符等，编译器会报告法分析阶段的错误


### yacc 


- yacc (yet another compiler compiler), 可以根据用户给定的语法规则对输入的 token 序列解析。对于不同的编程语言，编译器的开发者只需改变语法规则，而无需为每个编译器写一个语法分析器。


## 语义分析 


### 语义分析器 (semantic analyzer)


- 确定语句的意义，如 C 语言两个指针相 \*没有意义，但在语法上是合法的等等

### 静态语义


- 在编译期可以确定的语义。
- 通常包括声明和类型的匹配，类型的转换。如 `int = float ` 隐含了整型从浮点型的转换，语义分析需要完成这个步骤


### 动态语义

- 指运行期间出现的语义相关问题，如 0 作为除数。



### 结果


- 整个语法树的表达式都被标识了类型，如下图
![[Pasted image 20230722103354.png]]
- 如果有些类型需要隐式转换，语义分析程序会在语法树插入相应的转换节点

- 语义分析器还更新了符号表里的符号类型



## 中间语言生成


### 源码级优化器 (source code optimizer)


- 在不同编译器中可以有不同定义或其他差异，whatever.


#### 中间代码 (intermediate code)

源码级优化器直接在语法树上做优化困难，往往将语法树转换成中间代码

- 语法树的顺序表示 

- 跟目标机器的运行时环境无关
- 不同编码器形式不同，常见有：三地址码，P-Code


最基本的三地址码如下
$$
x = y{\space}op{\space}z
$$
上例的语法树经过三地址码翻译为
```c
t1 = 2 + 6
t2 = index + 4
t3 = t2 * t1
array[index] = t3
```
经过优化后

```c
t2 = index + 4
t2 = t2 * 8 
```

