# 类对象所占内存空间


| name     | 占据空间    |
|:-----|:-----|
| 静态成员 (函数)    |  类本身   |
| 虚函数     | 类本身     |
| 虚函数指针     | 类本身     |
| 成员函数     | 类本身     |
| 虚基类表| |
| 成员变量 | 类对象|
| 虚函数表 | 列对象 |



# 编译器什么时候合成默认构造函数


> 没有定义任何构造函数，编译器某些特定的情况下就会帮我们定义 (合成) 一个默认构造函数





- 以下情况，均默认类中无任何构造函数

| num     | time     |
|:-----|:-----|
| 1     | 父类带缺省 $^{1}$ 的构造函数  |
| 2     | 父类或子类带虚函数     |
| 3 |  含有虚基类    |
| 4     | 类类型成员含有缺省的构造函数或虚函数或虚基类     |

**总结**   当编译器需要为我们在构造函数中插入一些代码如初始化 vftbl、vbtbl、调用父类缺省构造函数时，会合成一个默认构造函数

--- 
$^{1}$  缺省构造函数: 构造函数*没有参数*，或者构造函数的*所有参数都有默认值*, *一个类中只能有一个缺省构造函数*.



# 编译器什么时候合成拷贝构造函数
> 当类中没有定义任何拷贝构造函数，且满足一些条件，会帮忙合成构造函数


- 一下情况均默认类中无任何构造函数

|  num    |   time   |
|:-----|:-----|
|  1   |  类类型成员含有拷贝构造函数    |
|  2    |  父类含有拷贝构造函数    |
|  3    |  声明或继承类虚函数   |
| 4| 虚基类|

**总结**  当编译需要为我们的构造函数中插入一些代码如初始化 vftbl、vbtbl、调用父类拷贝构造函数时，会合成一个拷贝构造函数，其余情况均采用 bitwise 拷贝, 是一种浅拷贝。



# 虚函数

> 一个类有虚函数时，该类会产生一个虚函数表为该类共享，每个类对象会有一个虚函数表指针，用于指向类的虚函数表的开始地址



- 虚函数表可以看成一个数组，每个元素是一个虚函数的开始地址。可以使用函数类型来调用虚函数表的虚函数，可以绕过 private 的审查, 因为这是运行时确定的。

- 父类中有虚函数，子类中肯定有虚函数，故不管子类 overwrite 的函数中写不写 virtual, 依然是虚函数

- 子类父类的虚函数表内容可能相同，但虚函数表的位置不同

- 使用子类对象初始化父类时，子类的虚函数表的内容不会去覆盖父类对象的虚函数表, 这也是为什么不使用引用或指针无法出现多态；


- 以下 vftbl_ptr 位置的一些结论

|  time    | conclusion     |
|:-----|:-----|
| 没有虚基类时     |  vftbl_ptr 位于对象内存布局开始的位置    |
| 单继承     | 子类只有一个虚函数表     |
| 多继承     | 多个基类则有多个 vftbl, 多个 vftbl_ptr 且按继承顺序 $^{2}$ 依次放置在类的内存空间     |
| | |


**vftbl 的创建时机** 实际上，虚函数表是编译器在编译期间就为每个类确定好了对应的虚函数表 vtbl 的内容。然后在编译期间给相应的类的构造函数中添加给 vptr 赋值的代码。这样程序运行到创建对象时候调用构造函数，进行把虚函数表地址赋值给虚函数表指针。

**vftblptr 的创建时机**  vptr 跟着对象走，所以对象什么时候创建出来，vptr 就什么时候创建出来。

**静态联编** 编译的时候确定调用那一个函数, 栈上分配的对象采用静态联编

**动态联编** 在程序运行时，根据时机情况，动态把调用语句与函数绑定在一起。堆上分配的对象采用动态联编。

--- 
$^{2}$ 在 msvc 中子类和第一个基类公用一个 ptr



i
