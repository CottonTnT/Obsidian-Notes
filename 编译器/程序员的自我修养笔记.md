# 1 gcc hello.c的完整过程

$$
Preprocessing{\rightarrow}Compilation{\rightarrow}Assembly{\rightarrow}Liking

$$
- 下面是 gcc 编译过程的分解

![[Pasted image 20230721201458.png]]

*第一步预处理过程相当于* 
<center>gcc -E hello. c -o hello. i</center>
<center>cpp hello. c > hello. i</center>
- 展开所有的宏定义,
- 处理所有预编译指令
- 添加调试信息，如行号等
- 保留所有编译器指令, 如#progma
*编译过程*

<center>gcc -S hello. i -o hello.s</center>
	现在 gcc 一般把预编译与编译两个步骤合并为一个步骤
<center>cc 1 hello.c</center>

- 编译过程就是预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件
*汇编*
<center>gcc -c hello.s -o hello.o </center>
或者
<center>as hello. s -o hello.o</center>

- 把汇编代码转变成机器可以执行的指令, 根据汇编代码和机器指令的对照表一一翻译

*链接*

![[Pasted image 20230721221711.png]]

# 2 编译器做了什么


- 编译器编译的过程一般可以分为 6 步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。

- 整个过程如下图所示
![[Pasted image 20230721222126.png]]

## 2.1 词法分析

### 2.1.1 scanner 
- 首先 source code 被输入到扫描器 (scanner：简单进行词法分析，运用类似于有限状态机算法将源代码的字符序列分割成一系列的记号，即 Token). 如下程序
```c
array[index]=(index + 4) * (2 + 6);
```
![[Pasted image 20230721222943.png]]

>词法分析中的记号一般分为如下几类: 关键字、标识符、字面量（数字、字符串等）、和特殊符号 (+、-等)

 

- 在识别记号的同时, scanner 也完成了如将 `将标识符存放到符号表，将数字、字符串常量存放到文字表` 等工作


### 2.1.2 lex

- lex 可以按照用户之前描述好的词法规则将输入的字符串分割成一个个 token，这样编译器的开发者无需为每个编译器开发一个独立的词法扫描器了，只需根据需要改变语法规则


### 2.1.3 预处理


- 如 C 语言，它的预处理工作一般不归入编译器的范围而交给一个独立的预处理器


## 2.2 语法分析


### 2.2.1 Grammer parser (语法分析器)

- 对 scanner 产生的 tokens, 通过*上下文无关文法*(context-free grammer)的分析手段进行语法分析，产生*语法树*（syntax tree）。
- 语法树就是表达式 (expression)为节点的树，如 c 语言的一个语句就是一个表达式，复杂的语句就是很多表达式的组合。如下程序语法树如下
```c
array[index]=(index + 4) * (2 + 6);
```

![[Pasted image 20230722095303.png]]

- 如果表达式不合法，比如括号各种括号不匹配、表达式中缺少操作符等，编译器会报告法分析阶段的错误


### 2.2.2 yacc 


- yacc (yet another compiler compiler), 可以根据用户给定的语法规则对输入的 token 序列解析。对于不同的编程语言，编译器的开发者只需改变语法规则，而无需为每个编译器写一个语法分析器。


## 2.3 语义分析 


### 2.3.1 语义分析器 (semantic analyzer)


- 对表达式进行语法层面的分析, 不了解语句是否真正有意义，但如 C 语言两个指针相 \*没有意义，但在语法上是合法的等等


### 2.3.2 静态语义


- 在编译期可以确定的语义。
- 通常包括声明和类型的匹配，类型的转换。如 `int = float ` 隐含了整型从浮点型的转换，语义分析需要完成这个步骤


### 2.3.3 动态语义

- 指运行期间出现的语义相关问题，如 0 作为除数。



### 2.3.4 结果


- 整个语法树的表达式都被标识了类型，如下图
![[Pasted image 20230722103354.png]]
- 如果有些类型需要隐式转换，语义分析程序会在语法树插入相应的转换节点

- 语义分析器还更新了符号表里的符号类型



## 2.4 中间语言生成


### 2.4.1 源码级优化器 (source code optimizer)


- 在不同编译器中可以有不同定义或其他差异，whatever.


#### 2.4.1.1 中间代码 (intermediate code, 编译器前端)

源码级优化器直接在语法树上做优化困难，往往将语法树转换成中间代码

- 语法树的顺序表示 

- 跟目标机器的运行时环境无关
- 不同编码器形式不同，常见有：三地址码，P-Code


最基本的三地址码如下
$$
x = y{\space}op{\space}z
$$
上例的语法树经过三地址码翻译为
```c
t1 = 2 + 6
t2 = index + 4
t3 = t2 * t1
array[index] = t3
```
经过源码级优化器优化后

```c
t2 = index + 4
t2 = t2 * 8 
array[index]  = t2
```


- 中间代码使得编译器可以被分为前端和后端。前端负责产生机器无关的中间代码，编译器后端将中间代码转换成目标机器代码。这样跨平台的的编译器而言，他们可以针对不同的平台使用同一个前端和针对不同机器的数个后端


## 2.5 目标代码生成和优化 (编译器后端)


### 2.5.1 代码生成器 (Code Generator)

- 将中间代码翻译为目标机器代码
- 依赖目标机器，如字长、寄存器等

对于上例，代码生成器可能会生成如下代码序列（x86 汇编版）
```asm
movl index, %ecx;value of index to ecx
addl $4, %ecx;ecx = ecx + 4;
mull $8, %ecx;ecx = ecx * 8;
movl index, %eax;value of index to eax
movl %ecx, array(,eax, 4);array[index] = ecx
```

 
### 2.5.2 目标代码优化器 (Target Code Optimizer)


- 对目标机器代码进行优化,比如选择合适的寻址方式、使用位移来代替乘法、除法等多余命令。如下

```asm
movl index, %edx
leal 32(, %edx, 8), %eax
movl %eax, array(,%edx, 4)
```


### 2.5.3 to be solved

- index  的地址还未确定, *如果有变量定义在其他模块，该怎么办?*
## 2.6 链接
- 链接的实质：*把一些指令对其他符号地址的引用加以修正*

- 主要过程包括：*地址和空间分配、符号决议、重定位*

>符号决议别名符号绑定、名称绑定、名称决议、地址绑定、指令绑定


### 2.6.1 静态链接 (link)


- 基本链接过程如下图
![[Pasted image 20230722153247.png]]


结合具体 CPU 指令了解这个过程, 比如在目标文件 b 里面有一条如下指令：

```asm
mov1 $0x2a, var
```

相当于
```c
var = 42//var是全局变量，在目标文件A里
```
编译后目标文件 b ，所得机器码如下

![[Pasted image 20230722154321.png]]
![[Pasted image 20230722154356.png]]

# 3 目标文件里有什么


## 3.1 目标文件的种类


>目标文件指源代码编译后但未进行链接的那些中间文件



- 目标文件与可执行文件的内容结构很相似，所以一般跟可执行文件格式一起采用一种格式储存，动态链接库(DLL, win .dll | linux .so)、静态链接库(SLL, win .lib | linux .a)也按照可执行文件格式储存


- 可执行文件格式 (Executable) 分为如下两种
  - windows：PE-COFF (Portable Executable)
  - linux：ELF (Executable Linkable Format)


ELF 文件标准把系统中采用 ELF 格式的文件归为如下标四类


![[Pasted image 20230722194813.png]]

下图是一个简单的程序SimpleSection.o编译成目标文件后的结构
![[Pasted image 20230722213204.png]]
![[Pasted image 20240124135018.png]]
![[Pasted image 20240124135024.png]]
## 3.2 ELF 目标文件结构


>这些段的名字都是*由. 作为前缀，表示这些段表的名字是系统保留*的

![[Pasted image 20230722215407.png]]
### 3.2.1 ELF Header

>描述了整个文件的基本属性，比如 ELF 文件版本、是否可执行文件、目标操作系统、目标机器型号、程序入口地址、是静态还是动态链接等

![[Pasted image 20230722220500.png]]

- ELF 的文件头中定义了 *ELF 魔数、文件机器字节长度、数据储存方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量* 等等

- ELF 文件头结构及相关常数一般定义在“usr/include/elf.h”等

- ELF 文件头结构有两种版本，分别叫做 `Elf32_Ehdr` 、`Elf64_Ehdr`


#### 3.2.1.1 elf. h 的相关定义

- elf. h 使用 typedef 定义了一套自己的变量体系，如下图
![[Pasted image 20230722221108.png]]

- 以 Elf32_Ehdr 为例，实际代码如下
![[Pasted image 20230722221206.png]]
- ELF 文件头中各个成员的含义与 readelf 输出结果对照表如下
![[Pasted image 20230722221441.png]]
![[Pasted image 20230722221504.png]]

- **elf 魔数**：用来标识ELF文件的平台属性，如下图

![[Pasted image 20230722222323.png]]

- **文件类型** :系统通过这个常量来判断ELF的真正文件类型，而不是通过扩展名
![[Pasted image 20230722222603.png]]

- **机器类型**：表示该 ELF 文件能在那类机器下使用，相关常量如下如
![[Pasted image 20230722222711.png]]

### 3.2.2 段表 (Section Header Table)

> `ELF`文件与段有关的重要结构就是段表，用于保存`ELF`文件各个段的基本属性的结构，段表在 `ELF `文件中的位置由 `ELF `文件头的`e_shoff`决定,段的数量由`ELF header`的`e_shnum`决定


 `Section header table`描述了 `ELF `文件包含的所有段的信息，比如每个段的段名、长度、在文件中的偏移、读写权限等,即**段结构就是由段表决定的，编译器、连接器和装载器都是依靠段表来定位和访问各个段的属性的**

- 执行 `readelf -S SimpleSection.o `结果如图:

![[Pasted image 20230722223655.png]]

- 段表的结构是一个以 `Elf32_Shdr`结构体为元素的数组。结构如下图
![[Pasted image 20230722223723.png]]
- 该结构每个字段意义如下图
![[Pasted image 20230722223827.png]]

- **sh_name** 段的名字只是在连接和编译的过程中有意义，但不能真正的表示段的类型，*对于编译器和链接器来说，主要决定段的属性的是段的类型和段的标志位*.
- **sh_type**段的类型如下表所示

![[Pasted image 20230722224422.png]]
![[Pasted image 20230722224431.png]]

- **sh_flags** 段的标志位：表示该段在进程虚拟地址空间中的属性，比如是否可写、可执行等，相关定义常量如下表
![[Pasted image 20230722224626.png]]

- **sh_link、sh_info** 段表的链接信息: 如下图
![[Pasted image 20230722224821.png]]

- 对于系统保留段的属性, 如下表
![[Pasted image 20230808210845.png]]
![[Pasted image 20230808210911.png]]


### 3.2.3 .data 段

>保存已经初始化了的全局静态变量、局部静态变量


### 3.2.4 .rodata 段

> 存放的只读数据，如 c 语言中的 const 修饰的变量与字符串常量

### 3.2.5 .bss 段

>存放未初始化的全局变量与局部静态变量


.bss段预留了这些变量的空间，*却不占目标文件的空间*

### 3.2.6 字符串表

> ELF文件用到了很多字符串，比如段名、变量名等,一般字符串表也以段的形式保存

- 常见字符串表的段名为`strtab` 和 `shstrtab`,分别表示 _字符串表(String Table)_ 和 _段表字符串表(Section Header String Table)_
    
    - 字符串表用来保存普通的字符串
    - 段表字符串表用来保存段表用到的字符串，常见如段名(sh_name)
- 因为字符串的长度往往是不定的，所以用固定结构表示比较困难，常见做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串，如下图 ![Pasted image 20230809100157.png](app://b3af12502d3e4c76dd4f895af594af3aa180/D:/Obsidian-Notes/images/Pasted%20image%2020230809100157.png?1705912816063) 通常这种做法，在ELF文件中中引用字符串只须给出一个数字下标即可，不用考虑字符串长度问题
    

### 3.2.7 其他段

如图

![[Pasted image 20230722214437.png]]

### 3.2.8 自定义段


gcc 提供了一个扩展机制，使得程序员可以指定变量所处的段
![[Pasted image 20230722215223.png]]
- 查看可重定位表
![[Pasted image 20230816132725.png]]

- 对于32位的Intel x86系列处理器来说，重定位表的结构是一个Elf32_Rel结构的数组，每个数组元素对应一个重定位入口。`Elf32_Rel`的定义如下
```cpp
typedef struct {
	Elf32_Addr r_offset;
	Elf32_Word r_info;
}Elf32_Rel;
```

![[Pasted image 20230816133111.png]]


### 3.2.9 重定位表（Relocation Table）

> 链接器处理目标文件时，须对代码段和数据段中那些对绝对地址的引用的位置重定位,这些重定位的信息都记录在重定位表里. 一个重定位表也是ELF的一个段，sh_type 就是 `SHT_REL`


- `.rel.text` 就是针对`.text` 段的重定位表，`.rel.data`就是就是针对`.data`段的重定位表



### 3.2.10 符号表
#### 3.2.10.1 符号 (Symble Table,链接的接口)


> 在链接中，函数和变量统称为*符号*，函数名或变量名为*符号名*。


- 每个. o 文件都有自己的符号表(Symbol table), 记录了. o 文件用到的所有符号
- 整个链接过程是基于符号完成的
- 每个定义的符号有一个对应的*符号值*，对于变量和函数说，*符号值就是他们的地址*

-  **符号的类型**

![[Pasted image 20230723144243.png]]

>对于链接过程，只关心全局符号的“黏合”，即上面的一二类


#### 3.2.10.2 ELF 符号表的结构

>ELF文件的符号表往往是文件中的一个段，段名一般为`.symtab`


- 在 32 位 ELF 文件，符号表的结构是一个 `Elf32_Sym` 的数组，其中下标为 0 的元素无效。Elf32_Sym 结构定义如下图
```c
typedef struct{
	Elf32_Word st_name;
	Elf32_Addr st_value;
	Elf32_Word st_size;
	unsigned char st_info;
	unsigned char st_other;
	Elf32_Half st_shndx;
}
```


![[Pasted image 20230809101744.png]]

**符号类型和绑定信息 (st_info )**：低 4 位表示符号的类型，高 28 位表示符号绑定信息，如下图

![[Pasted image 20230723145356.png]]

- **符号所在段 (st_shndx)**: 
 ![[Pasted image 20230723145829.png]]


- **符号值 (st_value)**: 
![[Pasted image 20230723145941.png]]

#### 3.2.10.3 特殊符号
>被定义在ld 链接器的链接脚本中，只有使用 ld 链接生产最终可执行文件的时候这些符号才会存在

我们可以在程序中使用这些符号, 一些代表性的特殊符号如下
![[Pasted image 20230723150311.png]]
![[Pasted image 20230809104701.png]]

#### 3.2.10.4 函数签名与符号修饰 (cpp)

> 解决符号名冲突,如cpp的 `namespace` 用于解决多模块的的符号冲突


**函数签名**：通过一个函数的函数名、参数类型、所在类、所在命名空间及其他信息标识函数的唯一信息 

- 编译器及链接器在处理符号时，适用某种名称修饰的方法，使得每个函数签名对应一个*修饰后名称*(decorated name),即C++源代码编译后的目标文件中所使用的符号名是相应的函数和变量的修饰后名称。

- 如下代码
```cpp
int func(int)；
float func(float);

class C{
	int func(int);
	class C2{
		int func(int);
	};
};

namespace N{
	int func(int);
	class C{
		int func(int);
	};
}

```

在 GCC <sup>1</sup>编译器下，所得

![[Pasted image 20230723152125.png]]

- 该机制同样应用于 C++中的全局变量与静态变量，*但变量的类型如同函数的返回值一样没有加入到 decorated name 中*


- **extern "C"**
> C++为了与c兼容，在符号的管理上，C++有一个用来声明或定义一个C的符号的 `extern "C"` 关键字用法

```cpp
extern "C"{
	int func(int);
	int var;
}

//or
extern "C" int func(int);
extern "C" int var;
```

- C++编译器会将括号内部代码视为C语言代码处理，即C++名称修饰机制将不会起作用

---
<sup>1</sup> 由于不同的编译器采用的不同的名称修饰方法，故不同编译器编译产生的目标文件无法正常相互链接



#### 3.2.10.5 弱符号与强符号

> 用于指导符号重复定义时连接器的行为


- **Strong Symbol**: 普通函数和初始化了的全局变量,类静态变量
- **Weak Symbol**：未初始化的全局变量, 类成员函数


- 一个强符号可以转为弱符号

``` cpp
extern int ext;//符号引用

int weak;
int strong = 1;
__attribute__((weak)) weak2 = 2;
//GCC 通过__attribute__((weak))定义任何一个强符号为弱符号

int main(){
return 0:
}
```


- 链接器处理强弱符号的规则如下图

![[Pasted image 20230723154708.png]]


>强弱符号是针对定义的，而不是针对引用的


- **强引用**：没找到链接器就报符号未定义错误。

- **弱引用**：没找到链接器不报错, 对于未定义的弱引用，链接器默认为 0 或一个特殊值

- 可以声明一个外部函数的引用为弱引用
```cpp
__attribute__ ((weakref)) void foo();
int main(){ foo();}//运行会报错，因为foo地址为0

//改进版
int main(){
	if(foo) foo();
}
```

### 3.2.11 查看目标文件的各种指令

``` shell
objdump [-arg] SimpleSection.o
	-x 显示所有头部信息
	-h 显示二进制文件节，即打印各个段的基本信息
	-d  显示二进制文件的反汇编代码
	-s 将所有段的内容以十六进制的方式打印出来
	-r 查看重定位表

readelf [-arg] SimpleSection.o

	-h 查看ELF文件头
	-S 查看段表的内容 
	-s 查看符号表的内容

nm SimpleSection.o //查看目标文件的符号表

sizeSimpleSection.o //可用来查看ELF文件的代码段、数据段和BSS段的长度

```
## 3.3 调试信息

目标文件还有可能保存的是调试信息。几乎所有现代编译器都支持源代码级别的调试。gcc -g，编译器生成相关调试信息

![[Pasted image 20230723162141.png]]


# 4 静态链接


- 下面将以如下例子展开分析
```cpp
// a.c
extern int shared;
int main(){
	int a = 100;
	swap(&a, &shared);
}

//b.c
int shared = 1;

void swap(int *a, int *b){
	*a ^= *b ^= *a ^= *b;
}
```


## 4.1 空间与地址分配


### 4.1.1 相似段合并

> 即将相同性质的段合并在一起


 **两步走** 
![[Pasted image 20230812164010.png]]
 *当第一步完成后，各个段在链接后的虚拟地址就已经确定了*, 由于各个符号在段内的相对位置时固定的，故各个符号在段内的相对位置是固定的
 
- 用链接器进行链接
```shell
ld a.o b.o -e main -o ab
	-e <function_name>将该函数作为程序入口，默认为_start
```


![[Pasted image 20230812165739.png]]

## 4.2 重定位表的调整

> 重定位表的结构专门用来保存这些与重定位相关的信息，在ELF文件中往往是一个段或多个段



## 4.3 指令修正方式


- 略
## 4.4 COMMON块 
> 当不同文件需要的COMMON块 大小不一时，以最大的一块为准


* 当不同文件符号定义类型不一致时有如下三种情况
  * 两个或两个以上强符号类型不一致 (*直接报错*)
  * 有一个强符号，其他都是弱符号，出现类型不一致 (*以强符号那个为准*)
  *  两个或两个以上弱符号类型不一致(*以最大的COMMON块为准*)


- 所以编译器为何不直接把*未初始化的全局变量*也当作*未初始化的局部静态变量*一样处理，为它在`BSS`段分配空间，而是将其标记为一个`COMMON`类型的变量呢?
![[Pasted image 20230816135415.png]]

- **将位初始化的全局变量不以`COMMON`块处理** 
```shell
gcc -fno-common
```

```cpp
int globle __attribute__((nocommon)):
```

> 未初始化的全局变量不是以`COMMON`块的形式存在，那么它相当于一个强符号

 

## 4.5 C ++ 相关问题


### 4.5.1 消除重复代码

> C++很多时候会产生很多重复代码，比如模板、外部内联函数(Extern Inline Function) 和 虚函数表(Virtual Funciton Table)都有可能在不同的编译单元里生成相同的代码。


- **一个有效的解决方案**
![[Pasted image 20230816143430.png]]

### 4.5.2 函数级别的链接
> 由于现在的库和程序庞大，一个目标文件可能包含无数函数或变量，当我们需要使用其中一些时，须把整个链接进来，故很多没用到的函数也被一起链接了进来，导致最后的输出文件臃肿


- **一个有效的解决方案**
![[Pasted image 20230816144351.png]]

### 4.5.3 全局构造和析构



### 4.5.4 API 与 ABI

- 略

## 4.6 静态库链接

> 一组目标文件的集合，并且对其编号和索引, 通常一个静态运行库里面一个目标文件只包含一个函数，用以减少空间浪费


- 查看静态库
```shell
ar -t libc.a

```



## 4.7 链接控制



## 4.8 BFD库(Binary FIle Descriptor library)

> 希望通过统一的接口来处理不同的目标文件格式.


# 5 可执行文件的装载与进程


## 5.1 进程虚拟地址空间

> 	每个程序都拥有自己独立的VAS(Virtual Address Space),硬件决定了地址空间的最大`理论`上限，即硬件的寻址空间大小


- **PAE(Physical Address Extension)**
>如32位地址线最多访问4GB物理内存，将其扩展至36位，则能访问64GB

![[Pasted image 20230816153805.png]]G



# 6 动态链接

> 静态链接极大地浪费内存空间，且对程序的更新、部署和发布带来很多麻烦, 比如静态链接中的任何模块更新，整个程序都要重新链接.动态链接把链接这个过程推迟到了运行时


- Linux中，ELF动态链接文件被称为*动态共享对象*(DSO,Dynamic Shared Objects),一般扩展名为`.so`,在windows 中被称为 *动态链接库*（Dynamical Linking Library),扩展名为`.dll`
