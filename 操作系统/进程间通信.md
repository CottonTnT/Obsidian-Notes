# 1 匿名管道


 ![[Pasted image 20240520224658.png]]
- 管道通信时，需要产生两次拷贝，一次从用户空间拷贝进内核缓冲区，一次从内核缓冲区拷贝进用户空间,即两次拷贝，*两次用户态到内核态的切换*

## 1.1 匿名管道读写规则
1. 读写端正常，若管道如果为空，读端就要阻塞；
2. 读写端正常，若管道如果被写满，写端被阻塞；
3. 读端正常读，写端关闭，读端就会读到0，表明读到pipe文件末尾。这种情况，读端并不会阻塞。
4. 写端正常写，读端关闭，操作系统会用13号信号SIGPIPE杀死系统中正在写入的进程。


## 1.2 管道的特点
1. 具有血缘关系的进程才可以进行通信（常用于父子通信）；
2. 管道是半双工的，数据只能单向流动；
3. 父子进程是会进程协同的，匿名管道会提供同步与互斥机制——保护管道文件的数据安全；
4. 管道提供面向流式的通信服务——面向字节流；
5. 管道是基于文件的，而文件的生命周期是随进程的。当进程执行结束，则对应的匿名管道文件会被释放。


# 2 命名管道
![[Pasted image 20240521133313.png]]
整个通信过程中，*FIFO文件不会与磁盘进行任何交互*（落盘），故命名管道比普通文件快。但A、B进程无法直接将数据写入该文件或直接从该文件进行读取，故写入进程需要维护一个写入缓冲区，写入完毕后，再将缓冲区的内容拷贝到FIFO文件中；读取进程需要维护一个读取缓冲区，将FIFO文件中的内容拷贝到缓冲区，再进行读取，需要两次拷贝


函数接口创建命名管道
![[Pasted image 20240521023046.png]]
```c
#include <unistd.h>
int main(){
	mkfifo("fifo-file", 0666);
	return 0;
}
```


- 当读进程读取命名管道中的内容时，如果内部为空（写进程还没有写），则会阻塞等待；写进程执行`open`系统调用时就会开始阻塞
- 写进程写入命名管道的内容时，如果读进程还没有读，则会阻塞等待


如果不希望,则可以在`open`时，已`O_NONBLOCK`模式打开
```c
int fd = open("fifo_file", O_WDONLY  | O_NONBLOCK);
```



# 3 共享内存

**共享内存=共享内存块+对应的共享内存的内核数据结构**。
![[Pasted image 20240521134506.png]]共享的建立过程是：

- ①在内存中申请一块空间；
- ②将该内存挂接（映射）到通信进程的进程地址空间的共享区。

这样可以*避免两次拷贝*


共享内存对应的内核数据结构如下
```c
//共享内存对应的内核数据结构
 struct shmid_ds {
    struct ipc_perm shm_perm;    /* Ownership and permissions */
    size_t          shm_segsz;   /* Size of segment (bytes) */
    time_t          shm_atime;   /* Last attach time */
    time_t          shm_dtime;   /* Last detach time */
    time_t          shm_ctime;   /* Last change time */
    pid_t           shm_cpid;    /* PID of creator */
    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */
    shmatt_t        shm_nattch;  /* No. of current attaches */
    ...
};
```

共享内存是进程间通信**最快**的方式，一方面用它通信时，拷贝没有缓冲区拷贝问题；另一方面，共享内存通信时，仅涉及开始时的*一次系统调用*（即一次用户态和内核态的转换）。

## 3.1 共享内存的特点
- 共享没有没有同步和互斥机制。
- 共享内存是所有的进程通信中，速度最快的；
- 共享内存内部的数据由用户自己维护（读完要自己清空）;
- 共享内存的生命周期是随内核的，*用户不主动删除，共享内存会一直存在（除非内核重启或用户释放）*；

- 共享内存的大小一般建议是4096的整数倍，内存管理的一页大小为4096字节（4KB）。若申请4097，则系统会分配4096 * 2，但用户还是只能使用4097的空间，会存在4095字节空间的浪费
## 3.2 共享内存的使用
### 3.2.1 key值
在命名管道中，通过文件路径的唯一性，以保证多个通信进程能够看到同一个共享资源。在共享内存使用`key`来保证资源的唯一性

![[Pasted image 20240521135110.png]]
第一个参数`pathname`是值文件路径，第二个参数是项目`id`（用户自己指定，没有明确要求）。返回计算得到的key值，但如果传入的路径不存在，则会生成失败，返回-1。

- 为了保证多个进程能够看到同一个共享存，需要约定唯一的pathname和项目id，避免找到不是同一个共享内存


### 3.2.2 创建共享内存

```c
#include <sys/ipc.h>
#include <sys/shm.h>

int shmget(key_t key, size_t size, int shmflg);

//shmget返回值类似于文件描述符（但并不是文件描述符），我们可以像读写文件一样操纵该返回值（但共享内存创建失败则会返回-1）。由于传入了具有唯一性的key值，故共享内存的唯一性得以保证。
```



### 3.2.3 挂接共享内存

创建完共享内存后，需要将该共享内存挂接到进程的地址空间中.
```c
#include <sys/type.h>
#include <sys/shm.h>

void *shmat(int shmid, const void *shmaddr,  int shmflg);
```


解除挂接共享内存
```c
#include <sys/type.h>
#include <sys/shm.h>

int shmdt(const void *shmaddr);
```


### 3.2.4 删除共享内存

```c
#include <sys/ipc.h>
#include <sys/shm.h>

int shmctl(int shmid, int cmd, struct shmid_ds *buf);
```







