# 1 实现一个锁


- 需要获得什么硬件支持
- 需要获得什么操作系统的支持


## 1.1 评价锁
- 互斥，能否阻止多个线程进入临界区
- 公平性(fariness), 能否保证一个等待的线程会进入临界区，不会饿死
- 性能， 是使用锁之后增加的时间开销。一种是没有竞争的情况，即只有一个线程抢锁、释放锁的开支如何？另外一种是 一个 CPU 上多个线程竞争，性能如何？最后一种是多个 CPU、多个线程竞争时的性能。通 过比较不同的场景，我们能够更好地理解不同的锁技术对性能的影响


## 1.2 锁的演化


### 1.2.1 单处理器时代
>最早提供的互斥解决方案之一，就是在临界区关闭中断。

```c
void lock(){
	DisableInterupts();
}
void unlock(){
	 EnableInterupts();
}
```


缺点如下:

- 一个贪婪的程序可能在它开始时就调用 lock()，从而独占处理器。更糟的情况是，恶意程序调用 lock()后，一直死循环。后一种情况，系统无法重新获得控制，只能重启系统。关闭中断对应用要求太多，不太适合作 为通用的同步解决方案。
- 这种方案不支持多处理器。如果多个线程运行在不同的 CPU 上，每个线程都试 图进入同一个临界区，关闭中断也没有作用。线程可以运行在其他处理器上，因此能够进入临界区。多处理器已经很普遍了，我们的通用解决方案需要更好一些

- 第三，关闭中断导致中断丢失，可能会导致严重的系统问题。假如磁盘设备完成了读 取请求，但 CPU 错失了这一事实，那么，操作系统如何知道去唤醒等待读取的进程
- 第四，效率低，现代cpu对于关闭和打开中断的代码执行慢

### 1.2.2 test-and-set

因为关闭中断的方法无法工作在多处理器上，所以系统设计者开始让硬件支持锁.最简单的硬件支持是测试并设置指令（test-and-set instruction），也叫作原子交换（atomic exchangeoh）

在`x86`上是`xchg`指令,效果如下

```c
int TestAndSet(int *old_ptr, int new){
	int old = *old_ptr;
	*old_ptr = new;
	return old;
}

//x86还有一种Compare-and-Swap
int CompareAndSwap(int *ptr, int expected, int new){
	int actual = *ptr;
	if(actual == expected){
		*ptr = new;
	}
	return actual;
}
```

简单的自旋锁如下
```c
typedef struct lock_t{
	int flag;
}lock_t;

void init(lock_t* lock){
	lock->flat = 0;
}

void lock(lock_t* lock){
	while(TestAndSet(lock, 1) == 1){
			//spin-wait(do nothing);
	}
}

void unlock(lock_t* lock){
	lock->flag = 0;
}
```


- 在单处理器上，需要抢占式的调度器（preemptive scheduler，即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法 使用，因为一个自旋的线程永远不会放弃 CPU。


### 1.2.3 评价自旋锁

- 正确性:自旋锁一次只允许一个线程进入临界区。因此，这是正确的锁。
- 公平性:不提供任何公平性保证
- 性能:在单 CPU 的情况下，性能开销相当大。假设一个线程持有锁进入临界区 时被抢占。调度器可能会运行其他每一个线程（假设有 N−1 个这种线程）。而其他线程都在 竞争锁，都会在放弃 CPU 之前，自旋一个时间片，浪费 CPU 周期。 但是，在多 CPU 上，自旋锁性能不错（如果线程数大致等于 CPU 数）。假设线程 A 在 CPU 1，线程 B 在 CPU 2 竞争同一个锁。线程 A（CPU 1）占有锁时，线程 B 竞争锁就会自 旋（在 CPU 2 上）。然而，临界区一般都很短，因此很快锁就可用，然后线程 B 获得锁。自 旋等待其他处理器上的锁，并没有浪费很多 CPU 周期，因此效果不错


### 1.2.4 fetch-and-add

（fetch-and-add）指令，它能原子地 返回特定地址的旧值，并且让该值自增一。获取并增加的 C 语言伪代码如下

```cpp
int FetchAndAdd(int *ptr){
	int old = *ptr;
	*ptr = old + 1;
	return old;
}
```


