

## two files opened by a process


![[Pasted image 20240103143055.png]]![[Pasted image 20240103143420.png]]


## unix file descriptor

Three levels:
1. file descriptor table
   - 跟进程相关，每个进程都有自己的文件描述符表，一个进程的线程共享一个文件描述符表
2. file entry table, w/file offset
   - 跟打开一次文件相关，记录打开方式，以及当前文件偏移量,通常当前文件状态是放入此表的，
3. inode table, w/file sie
   - 纪录文件的大小，文件的权限


## open(2) twice vs. open(2) then dup(2)/fork(2)


- open 两次:每次调用`open`函数都会返回一个唯一的文件描述符。因此，第一次调用`open`会返回一个文件描述符，第二次调用`open`会返回另一个文件描述符。这些文件描述符是用于标识和访问打开的文件.当第一次调用`open`时，会在文件表中创建一个新的条目来表示该文件的打开状态。当第二次调用`open`时，会创建另一个条目来表示同一个文件的另一个打开状态。当第一次调用`open`时，会查询文件系统的索引节点表，找到对应的索引节点，并将其与文件表中的条目关联起来。当第二次调用`open`时，由于该文件已经在索引节点表中存在，不会创建新的索引节点。
- open 一次，dup 一次：使用`dup`函数复制文件描述符时，会在文件表中创建一个新的条目，但在索引节点表中不会创建新的索引节点。这样，通过复制的文件描述符和原始的文件描述符可以独立地操作同一个文件，并且它们共享相同的索引节点和文件元数据信息。

- open一次，fork一次:在`fork`之前，父进程已经打开了该文件并获得了一个文件描述符。在`fork`之后，子进程会继承父进程的文件描述符表，包括已打开的文件描述符。因此，子进程也会有一个指向相同打开文件的文件描述符。在`fork`之后，子进程会复制父进程的文件表，包括文件表中的条目。复制的文件表中会有一个新的条目，表示相同的打开文件。这样，父进程和子进程都拥有指向同一个文件的文件表条目。`fork`之后，父进程和子进程共享同一个索引节点表。因为索引节点表是文件系统级别的数据结构，不会在`fork`时进行复制。父进程和子进程的文件表条目指向相同的索引节点，即相同的文件元数据。需要注意的是，父进程和子进程可以在各自的上下文中进行文件操作，但如果有一个进程关闭了该文件的文件描述符，那么对于另一个进程来说，该文件描述符将变为无效。

