

**关键问题**

- 并发缺陷有很多常见的模式。了解这些模式是写出健壮、正确程序的第一步


# 1 非死锁缺陷

## 1.1 违反原子性缺陷


>违反了多次访问中预期的可串行性，即代码的本意是原子的，但在执行中并没有强制实现原子性


- 一个MySQL中出现的例子

```c
Thread1::
if(thd->proc_info){
	fputs(thd->proc_info, ...);
}

Thread2::
thd->proc_info = NULL;
```

- 修正后
```cpp
 pthread_mutex_t proc_info_lock = PTHREAD_MUTEX_INITIALIZER; 
Thread 1:: 
pthread_mutex_lock(&proc_info_lock); 
if (thd->proc_info) { 
	fputs(thd->proc_info, ...); 
} 
pthread_mutex_unlock(&proc_info_lock);  

Thread 2:: 
pthread_mutex_lock(&proc_info_lock); 
thd->proc_info = NULL;  pthread_mutex_unlock(&proc_info_lock);

```

## 1.2 违反顺序缺陷



