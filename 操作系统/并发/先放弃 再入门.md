# 1 放弃：状态迁移原子性的假设


- 任何时候，`load`读到的值都可能是别的线程写入的

```c
#include "thread.h"

unsigned long balance = 100;

void Alipay_withdraw(int amt)
{
    if (balance >= amt) {
        // Bugs may only manifest on specific timings. Sometimes
        // we reproduce bugs by inserting sleep()s.

        usleep(1);

        balance -= amt;
    }
}

void T_alipay()
{
    Alipay_withdraw(100);
}

int main()
{
    create(T_alipay);//创建一个线程
    create(T_alipay);
    join();//等待所有线程结束
    printf("balance = %lu\n", balance);
}

```

- 一行代码可能被编译为多条指令，且一条指令都可能不是原子的
```c
#include "thread.h"

#define N 100000000

long sum = 0;

void T_sum() {
    for (int i = 0; i < N; i++) {
        sum++; // will get a load and store instruction

        // Won't work even if we force a single-instruction
        // increment.

        // asm volatile(
        //     "incq %0" : "+m"(sum)
        // );
    }
}

int main() {
    create(T_sum);
    create(T_sum);

    join();

    printf("sum = %ld\n", sum);
    printf("2*n = %ld\n", 2L * N);
}

```