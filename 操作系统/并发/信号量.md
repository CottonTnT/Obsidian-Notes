
我们现在知道，需要锁和条件变量来解决各种相关的、有趣的并发问题。多年前， Dijkstra他引入了名为信号量的同步原语,事实上，Dijkstra 及其同事发明了信号量，作为与同步有关的所有工作的唯一原语。你会看到，可以使用信号量作为锁和条件变量。


**关键问题**
- 如何使用信号量代替锁和条件变量
- 什么是信号量
- 什么是二值信号量
- 用锁和条件变量来实现信号量是否简单
- 不用锁和条件变量，如何实现信号量


# 1 信号量的定义

在 `POSIX` 标准中，是 `sem_wait(sem_t*)`和 `sem_post(sem_t*)`。因为信号量的初始值能够决定其行为，所以首先要初始化信号量， 才能调用其他函数与之交互，
```c
#include <semaphore.h>
sem_t s;
sem_init(&s, 0, 1);
//其中申明了一个信号量 s，通过第三个参数，将它的值初始化为 1。sem_init()的第二个 参数，在我们看到的所有例子中都设置为 0，表示信号量是在同一进程的多个线程共享的。 读者可以参考手册，了解信号量的其他用法（即如何用于跨不同进程的同步访问），这要求 第二个参数用不同的值
```

- `sem_wait()`要么立刻返回(信号量的值大于等于 1, 减少后为0)，要么会让调用线程挂起(减少后为负),直到之后的post操作

- `sem_post()` 并没有等待某些条件满足。它直接增加信号量的值，如果有等待线程， 唤醒其中一个。

- 当信号量的值为负数时，这个值就是等待线程的个数


# 2 二值信号量(锁)

```c
sem_t m;
sem_init(&m, 0, X);

sem_wait(&m);
//critical section here
sem_post(&m);
```
- X = 1, 即为锁


# 3 用信号量做条件变量

```c
sem_t s;
void *child(void *arg){
	printf("child\n");
	sem_post(&s);
	return NULL;
}

int main(int argc char *argv[]){
	sem->init(&s, 0, X);
	printf("parent:begin\n");
	pthread_t  c;
	pthread_create(c, NULL, child, NULL);
	sem_wait(&s);
	printf("parent: end \n");
}
```
- 信号量的初始值`X`的值应该为0 


# 4 生产者/消费者问题


- 第一次尝试
```c
int buffer[MAX];
int  fill = 0;
int use = 0;

void put(int value){
	buffer[fill] = value;
	fill = (fill + 1) % MAX;
}

void get(){
	int tmp = buffer[use];
	use = (use + 1) % MAX;
	return tmp;
}

sem_t empty;
sem_t full;

void *producer(void *arg){
	int i; 
	for(i = 0; i < loops; i ++){
		sem_wait(&empty);
		put(i);
		sem_post(&full);
	}
}

void *consumer(void *arg){
	int i, tmp = 0
	while (tmp != -1){
		sem_wait(&full);
		tmp = get();
		sem_post(&empty);
		printf("%d\n", tmp);
	}
}

int main(int argc, char* argv[]){
//...
	sem_init(&empty, 0, MAX);
	sem_init(&full, 0, 0);
}
```

如果有多个生产者与消费者，`put()`和`get()`会发生数据覆盖


- 解决方案：增加互斥
```cpp
sem_t empty;
sem_t full;
sem_t mutex;

void *producer(void *arg){
	int i;
	for(i = 0; i < loops; i ++){
		sem_wait(&empty);
		sem_wait(&mutex);
		put(i);
		sem_post(&mutex);
		sem_post(&full);
	}
}

void *consumer(void *arg){
	int i;
	for(i = 0; i < loops; i ++){
		sem_wait(&full);
		sem_wait(&mutex);
		int tmp = get();
		sem_post(&mutex);
		sem_post(&empty);
		printf("%d\n", tmp);
	}
}

int main(int argc, char* argv[]){
	sem_init(&empty, 0, MAX);
	sem_init(&full,  0, 0);
	sem_init(&mutex, 0, 1);
	return 0;
}
```

锁的位置要加对


# 5 读者-写者锁

另一个经典问题源于对更加灵活的锁定原语的渴望，它承认不同的数据结构访问可能 需要不同类型的锁。例如，一个并发链表有很多插入和查找操作。插入操作会修改链表的 状态（因此传统的临界区有用），而查找操作只是读取该结构，只要没有进行插入操作，我 们可以并发的执行多个查找操作。读者—写者锁（reader-writer lock）就是用来完成这种操 272 第 31 章 信号量 作的。

```c
typedef struct _rwlock_t{
	sem_t lock;//binary semaphore(basic lock)
	sem_t writelock;//used to allow ONE writer or many readers
	int readers;//count of readers reading in critical section
}rwlokc_t;

void rwlock_init(rwlock_t *rw){
	rw->readers = 0;
	sem_init(&rw->lock, 0, 1);
	sem_init(&rw->writelock, 0 ,1);
}

void rwlock_acquire_readlock(rwlock_t *rw){
	sem_wait(&rw->lock);
	rw->readers ++;
	if(rw->readers == 1){
		sem_wait(&rw->writelock);
	}	
	sem_post(&rw->lock);
}

void rwlock_release_readlock(rwlock_t *rw){
	sem_wait(&rw->lock);
	rw->readers--;
	 if(rw->readers == 1)
		 sem_post(&rw->writelock);
	sem_post(&rw->lock);
}

void rwlock_acquire_writelock(rwlock_t *rw){
	sem_wait(&rw->writelock);
}

void rwlock_release_writelock(rwlock_t *rw){
	sem_post(&rw->writelock);
}
```





















