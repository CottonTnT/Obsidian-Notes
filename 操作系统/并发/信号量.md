
我们现在知道，需要锁和条件变量来解决各种相关的、有趣的并发问题。多年前， Dijkstra他引入了名为信号量的同步原语,事实上，Dijkstra 及其同事发明了信号量，作为与同步有关的所有工作的唯一原语。你会看到，可以使用信号量作为锁和条件变量。


**关键问题**
- 如何使用信号量代替锁和条件变量
- 什么是信号量
- 什么是二值信号量
- 用锁和条件变量来实现信号量是否简单
- 不用锁和条件变量，如何实现信号量


# 1 信号量的定义

在 `POSIX` 标准中，是 `sem_wait(sem_t*)`和 `sem_post(sem_t*)`。因为信号量的初始值能够决定其行为，所以首先要初始化信号量， 才能调用其他函数与之交互，
```c
#include <semaphore.h>
sem_t s;
sem_init(&s, 0, 1);
//其中申明了一个信号量 s，通过第三个参数，将它的值初始化为 1。sem_init()的第二个 参数，在我们看到的所有例子中都设置为 0，表示信号量是在同一进程的多个线程共享的。 读者可以参考手册，了解信号量的其他用法（即如何用于跨不同进程的同步访问），这要求 第二个参数用不同的值
```

- `sem_wait()`要么立刻返回(信号量的值大于等于 1)，要么会让调用线程挂起,知道之后的post操作

- `sem_post()` 并没有等待某些条件满足。它直接增加信号量的值，如果有等待线程， 唤醒其中一个。

- 当信号量的值为负数时，这个值就是等待线程的个数


# 2 二值信号量(锁)

```c
sem_t m;
sem_init(&m, 0, X);

sem_wait(&m);
//critical section here
sem_post(&m);
```
- X = 1, 即为锁


# 3 用信号量做条件变量

```c
```















