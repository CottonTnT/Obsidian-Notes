锁并不是并发程序设计所需的唯一原语。 具体来说，在很多情况下，线程需要检查某一条件（condition）满足之后，才会继续运行


# 1 背景


- 父线程需要检查子线程是否执行完毕，实现如下

```c
volatile int done  = 0;
void *child(void *arg){
	printf("child\n");
	done = 1;	
	return NULL;
}

int main(int argc, char* argv[]){
	printf("parent:begin\n");
	pthread_t c;
	pthread_create(&c, NULL, child, NULL);
	while(done == 0)
		;//spin
	printf("parent: end\n");
	return 0;
}
```


**缺陷**
- 这种解决方案一般能工作，但是效率 低下，因为主线程会自旋检查，浪费 CPU 时间。我们希望有某种方式让父线程休眠，直到 等待的条件满足（即子线程完成执行）


# 2 定义与程序
线程可以使用条件变量（condition variable），来等待一个条件变成真。条件变量是一个 显式队列，当某些执行状态（即条件，condition）不满足时，线程可以把自己加入队列，等 待（waiting）该条件。另外某个线程，当它改变了上述状态时，就可以唤醒一个或者多个 等待线程（通过在该条件上发信号），让它们继续执行。

- 声明 `pthread_cond_t c;`
- `pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m)`  
- `pthread_cond_signal(pthread_cond_t *c)`

```c
int done = 0;
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t c = PTHREAD_COND_INITIALIZER;

void thr_exit(){
	pthread_mutex_lock(&m);
	done = 1;
	pthread_cond_signal(&c);
	pthread_mutex_unlock(&m);
}

void *child(void *arg){
	printf("child\n");
	thr_exit();
	return NULL;
}

void thr_join(){
	pthread_mutex_lock(&m);
	while(done == 0){
		pthread_cond_wait(&c, &m)	;
	}
	pthread_mutex_unlock(&m);
}

int main(int argc, char* argv[]){
	printf("parent:begin\n");
	pthread_t p;
	pthread_create(&p, NULL, child, NULL);
	thr_join();
	printf("parent: end\n");
	return 0;
}
```

### 2.1.1 变量`done`的重要性

```c
void thr_exit(){
	pthread_mutex_lock(&m);
	pthread_cond_signal(&c);
	pthread_mutex_unlock(&m);
}

void thr_join(){
	pthread_mutex_lock(&m);
	pthread_cond_wait(&c, &m);
	pthread_mutex_unlock(&m);
}
```

假设子线程立刻运行，并且调用 thr_exit()。

在这种情况下，子 线程发送信号，但此时却没有在条件变量上睡眠等待的线程。父线程运行时，就会调用 wait 并卡在那里，没有其他线程会唤醒它。通过这个例子，你应该认识到变量 done 的重要性， 它记录了线程有兴趣知道的值。睡眠、唤醒和锁都离不开它

### 2.1.2 加锁的重要性
```c
void thr_exit(){
	done = 1;
	pthread_cond_signal(&c);
}

void thr_join(){
	if(done == 0){
		pthread_cond_wait(&c);
	}
}
```

如果父进程调用 thr_join()，然后检查完 done 的值为 0，然后试图睡眠。但在调用 wait 进入睡眠之前，父进程被中断。子线程修改变 量 done 为 1，发出信号，同样没有等待线程。父线程再次运行时，就会长眠不醒，这就惨了

# 3 生产者与消费者问题


假设有一个或多个生产者线程和一个或多个消费者线程。生产者把生成的数据项放入缓冲区；消费者从缓冲区取走数据项，以某种方式消费

